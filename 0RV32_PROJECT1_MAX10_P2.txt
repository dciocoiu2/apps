⚠️⚠️START WITH FIRST FILE THIS IS PART2⚠️⚠️
================================================================================
PHASE 2A: ADD HART1–HART3 (MULTI-CORE HAZARD3 TILES ON AHB M1–M3)
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 2A
----------------
Turn your single-core Hazard3 SoC into a **4-hart SoC** by:

- Instantiating **HART1, HART2, HART3** as additional Hazard3 tiles.
- Connecting them as AHB masters M1, M2, M3 in the existing AHB fabric.
- Defining a simple **boot discipline**:
  - HART0 (M0) is the primary boot hart.
  - HART1–3 enter a “parked” wait loop until firmware explicitly releases them.
- Keeping all existing peripherals, bootloader, HAL, and SDRAM unchanged.

Still:

- FPGA is configured via `.sof` into **SRAM only**.
- No flash programming; power-cycle → factory demo.
- All changes are in RTL and firmware only.

HIGH-LEVEL DESIGN
-----------------
- Each hart:
  - Has its own Hazard3 tile instance with unique HART_ID (0,1,2,3).
  - Shares the same Boot ROM and SDRAM/peripheral address map.
- Boot behavior:
  - Hardware: all harts reset together.
  - Software: HART0 follows full bootloader flow, HART1–3 park in a loop.
  - Later phases (2B/2C) will add CLINT-like start/wakeup, but 2A just gets
    all four cores instantiated and behaving safely.

================================================================================
STEP 1 — MULTI-HART ENTRY CONVENTION IN BOOT ROM
================================================================================

We’ll define how each hart behaves at reset. Hazard3 provides a hart ID (via CSR
or parameter). For now, we assume:

- Bootloader code can read mhartid via CSR and branch.
- HART0 runs the full bootloader logic.
- HART1–3 just park in WFI until future phases use them.

You can adapt your bootrom.c (Phase 1I) with a tiny shim:

----- PATCH CONCEPT FOR ~/hazard3_fw/bootrom/bootrom.c ------------------------

/* Add CSR read helper (inline asm) */
static inline uint32_t h3_read_mhartid(void)
{
    uint32_t v;
    __asm__ volatile ("csrr %0, mhartid" : "=r"(v));
    return v;
}

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;
    uint32_t hartid = h3_read_mhartid();

    /* Only HART0 runs the bootloader for now. */
    if (hartid != 0) {
        while (1) {
            __asm__ volatile ("wfi");
        }
    }

    uart_init(SYS_CLK_HZ, 115200u);
    select_console();
    con_puts("\nHazard3 Phase 1I Bootloader (H3BT) - HART0\n");
    ...
    bootloader_loop();
}

Rebuild `bootrom.hex` after this change, same as Phase 1I.

Note:
- HART1–3 are electrically alive but permanently parked in WFI until we add
  an inter-hart wake mechanism in Phase 2B/2C.
- This avoids spurious bus traffic from secondary harts.

================================================================================
STEP 2 — TOP-LEVEL RTL: ADD HART1–HART3 AND CONNECT TO AHB FABRIC
================================================================================

We now modify `top_soc.sv` to:

- Instantiate 3 more Hazard3 tiles.
- Connect them as AHB masters M1, M2, M3 on `ahb_interconnect_4m`.
- Provide them with the same clock/reset as HART0.
- Keep all downstream fabric/peripherals unchanged.

Assuming your `hazard3_tile` module has the same AHB-Lite master interface as in
Phase 1A and a parameter `HART_ID`, we do:

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv --------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n,

    // SDRAM pins
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq,

    // UART0 pins
    input  wire        uart0_rx,
    output wire        uart0_tx,

    // I2C0 pins
    inout  wire        i2c_sda,
    inout  wire        i2c_scl,

    // SPI0 pins
    output wire        spi_mosi,
    input  wire        spi_miso,
    output wire        spi_sck,
    output wire        spi_ss0,

    // GPIO pins
    inout  wire [19:0] gpio_pins
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    //==========================================================================
    // AHB master interfaces for 4 harts (M0..M3)
    //==========================================================================

    // HART0 (M0)
    wire [31:0] m0_haddr;
    wire [2:0]  m0_hsize;
    wire [1:0]  m0_hburst;
    wire [1:0]  m0_htrans;
    wire        m0_hwrite;
    wire [31:0] m0_hwdata;
    wire [31:0] m0_hrdata;
    wire        m0_hready;
    wire        m0_hresp;

    // HART1 (M1)
    wire [31:0] m1_haddr;
    wire [2:0]  m1_hsize;
    wire [1:0]  m1_hburst;
    wire [1:0]  m1_htrans;
    wire        m1_hwrite;
    wire [31:0] m1_hwdata;
    wire [31:0] m1_hrdata;
    wire        m1_hready;
    wire        m1_hresp;

    // HART2 (M2)
    wire [31:0] m2_haddr;
    wire [2:0]  m2_hsize;
    wire [1:0]  m2_hburst;
    wire [1:0]  m2_htrans;
    wire        m2_hwrite;
    wire [31:0] m2_hwdata;
    wire [31:0] m2_hrdata;
    wire        m2_hready;
    wire        m2_hresp;

    // HART3 (M3)
    wire [31:0] m3_haddr;
    wire [2:0]  m3_hsize;
    wire [1:0]  m3_hburst;
    wire [1:0]  m3_htrans;
    wire        m3_hwrite;
    wire [31:0] m3_hwdata;
    wire [31:0] m3_hrdata;
    wire        m3_hready;
    wire        m3_hresp;

    //==========================================================================
    // AHB slaves: s0 = Boot ROM, s1 = AHB→WB bridge (SDRAM + peripherals)
    //==========================================================================

    wire [31:0] s0_haddr, s1_haddr;
    wire [2:0]  s0_hsize, s1_hsize;
    wire [1:0]  s0_hburst, s1_hburst;
    wire [1:0]  s0_htrans, s1_htrans;
    wire        s0_hwrite, s1_hwrite;
    wire [31:0] s0_hwdata, s1_hwdata;
    wire [31:0] s0_hrdata, s1_hrdata;
    wire        s0_hready, s1_hready;
    wire        s0_hresp,  s1_hresp;

    //==========================================================================
    // HAZARD3 TILE INSTANCES (4 HARTS)
    //==========================================================================

    // HART0
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m0_haddr),
        .HSIZE  (m0_hsize),
        .HBURST (m0_hburst),
        .HTRANS (m0_htrans),
        .HWRITE (m0_hwrite),
        .HWDATA (m0_hwdata),
        .HRDATA (m0_hrdata),
        .HREADY (m0_hready),
        .HRESP  (m0_hresp)
    );

    // HART1
    hazard3_tile #(
        .HART_ID(1)
    ) u_hart1 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m1_haddr),
        .HSIZE  (m1_hsize),
        .HBURST (m1_hburst),
        .HTRANS (m1_htrans),
        .HWRITE (m1_hwrite),
        .HWDATA (m1_hwdata),
        .HRDATA (m1_hrdata),
        .HREADY (m1_hready),
        .HRESP  (m1_hresp)
    );

    // HART2
    hazard3_tile #(
        .HART_ID(2)
    ) u_hart2 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m2_haddr),
        .HSIZE  (m2_hsize),
        .HBURST (m2_hburst),
        .HTRANS (m2_htrans),
        .HWRITE (m2_hwrite),
        .HWDATA (m2_hwdata),
        .HRDATA (m2_hrdata),
        .HREADY (m2_hready),
        .HRESP  (m2_hresp)
    );

    // HART3
    hazard3_tile #(
        .HART_ID(3)
    ) u_hart3 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m3_haddr),
        .HSIZE  (m3_hsize),
        .HBURST (m3_hburst),
        .HTRANS (m3_htrans),
        .HWRITE (m3_hwrite),
        .HWDATA (m3_hwdata),
        .HRDATA (m3_hrdata),
        .HREADY (m3_hready),
        .HRESP  (m3_hresp)
    );

    //==========================================================================
    // AHB INTERCONNECT (4 MASTERS → 2 SLAVES)
    //==========================================================================

    ahb_interconnect_4m u_ahb_ic (
        .clk        (clk),
        .rst        (rst),

        // Masters
        .m0_haddr   (m0_haddr), .m0_hsize(m0_hsize), .m0_hburst(m0_hburst),
        .m0_htrans  (m0_htrans), .m0_hwrite(m0_hwrite), .m0_hwdata(m0_hwdata),
        .m0_hrdata  (m0_hrdata), .m0_hready(m0_hready), .m0_hresp(m0_hresp),

        .m1_haddr   (m1_haddr), .m1_hsize(m1_hsize), .m1_hburst(m1_hburst),
        .m1_htrans  (m1_htrans), .m1_hwrite(m1_hwrite), .m1_hwdata(m1_hwdata),
        .m1_hrdata  (m1_hrdata), .m1_hready(m1_hready), .m1_hresp(m1_hresp),

        .m2_haddr   (m2_haddr), .m2_hsize(m2_hsize), .m2_hburst(m2_hburst),
        .m2_htrans  (m2_htrans), .m2_hwrite(m2_hwrite), .m2_hwdata(m2_hwdata),
        .m2_hrdata  (m2_hrdata), .m2_hready(m2_hready), .m2_hresp(m2_hresp),

        .m3_haddr   (m3_haddr), .m3_hsize(m3_hsize), .m3_hburst(m3_hburst),
        .m3_htrans  (m3_htrans), .m3_hwrite(m3_hwrite), .m3_hwdata(m3_hwdata),
        .m3_hrdata  (m3_hrdata), .m3_hready(m3_hready), .m3_hresp(m3_hresp),

        // Slaves
        .s0_haddr   (s0_haddr), .s0_hsize(s0_hsize), .s0_hburst(s0_hburst),
        .s0_htrans  (s0_htrans), .s0_hwrite(s0_hwrite), .s0_hwdata(s0_hwdata),
        .s0_hrdata  (s0_hrdata), .s0_hready(s0_hready), .s0_hresp(s0_hresp),

        .s1_haddr   (s1_haddr), .s1_hsize(s1_hsize), .s1_hburst(s1_hburst),
        .s1_htrans  (s1_htrans), .s1_hwrite(s1_hwrite), .s1_hwdata(s1_hwdata),
        .s1_hrdata  (s1_hrdata), .s1_hready(s1_hready), .s1_hresp(s1_hresp)
    );

    //==========================================================================
    // Boot ROM, AHB→WB bridge, WB interconnect, SDRAM, UART0, I2C, SPI, GPIO,
    // JTAG-UART are exactly as in Phase 1H/1K.
    //==========================================================================
    //
    //  boot_rom u_boot_rom (attached to s0_*)
    //  ahb_to_wb_bridge u_ahb2wb (attached to s1_*)
    //  wb_interconnect u_wb_ic
    //  sdram_wb_wrapper u_sdram_wb (s0 of WB)
    //  uart16550_wb_wrapper u_uart0 (s1)
    //  i2c_wb_wrapper u_i2c0 (s2)
    //  spi_wb_wrapper u_spi0 (s3)
    //  gpio_wb u_gpio (s4)
    //  jtag_uart_0 + jtag_uart_wb_wrapper u_jtag (s5)
    //
    // Keep all that code identical to the end of Phase 1H/1K.

endmodule

Notes:

- The only structural change is: M1, M2, M3 are now driven by real harts
  instead of being tied off.
- The rest of the SoC (ROM, SDRAM, peripherals, bootloader, HAL) remains intact.

================================================================================
STEP 3 — QUARTUS: RECOMPILE AND PROGRAM (SRAM-ONLY)
================================================================================

1. Ensure RTL tree updated:
   - Only `top_soc.sv` changed.
   - All other files from Phase 1K remain.

2. Rebuild:
   - Open Quartus project `h3_phase1_sc`.
   - Processing → Start Compilation.

3. Program (SRAM only):
   - Quartus Programmer:
     - Hardware: USB-Blaster.
     - Mode: JTAG.
     - File: `h3_phase1_sc.sof`.
     - Check ONLY “Program/Configure”.
     - START.
   - No `.pof`, no flash writes.
   - Power-cycle → factory demo (unchanged).

================================================================================
STEP 4 — RUNTIME BEHAVIOR AFTER PHASE 2A
================================================================================

At reset:

- All 4 harts start at `_start` in Boot ROM.
- Each hart reads `mhartid`.
- HART0:
  - Runs the H3BT bootloader (Phase 1I).
  - Loads SDRAM firmware via UART0 / JTAG-UART.
  - Jumps to 0x80000000.
- HART1–3:
  - Immediately park in a WFI loop inside bootrom.

When firmware at 0x80000000 runs (Phase 1K):

- It currently assumes single-hart; only HART0 will execute it.
- HART1–3 remain parked in ROM WFI.
- In later phases (2B/2C), the firmware will:
  - Write to a CLINT-like block or shared memory to wake HART1–3.
  - Provide distinct roles to each hart.

For now, Phase 2A is about **clean multi-hart instantiation with safe behavior**.

================================================================================
WHAT PHASE 2A GIVES YOU
================================================================================

- A **quad-core Hazard3 SoC** at the hardware level:
  - 4 independent harts sharing:
    - ROM
    - SDRAM
    - UART/I2C/SPI/GPIO/JTAG-UART
- A consistent boot story:
  - HART0 is the designated boot/control hart.
  - HART1–3 are passive until explicitly activated later.
- No change to your ephemeral rule:
  - `.sof` → SRAM.
  - No flash touch.
  - Power-cycle → factory demo.

########END P2A########
================================================================================
PHASE 2B: INTER‑HART MAILBOX FOR STARTING HART1–HART3
(ALL CONTENT IN ONE COPY‑PASTABLE TEXTBOX)
================================================================================

OBJECTIVE
---------
Enable HART0 to explicitly start HART1–HART3 after SDRAM firmware is loaded.

We add:
- A tiny **mailbox** peripheral on Wishbone.
- Each hart gets:
  - START_ADDR register
  - CMD register (GO bit)
  - STATUS register (ACTIVE/DONE)
- HART1–3 park in ROM until GO is asserted.
- HART0 (or SDRAM firmware) writes GO + START_ADDR to launch them.

No interrupts yet. No timers. Pure polling + WFI.

================================================================================
MEMORY MAP
================================================================================

Mailbox base: **0x1000_0400**

Per‑hart region (16 bytes each):

Hart h region = base + 0x10 * h

Offset | Register     | Description
-------|--------------|-----------------------------------------
0x00   | START_ADDR   | 32‑bit address to jump to
0x04   | CMD          | bit0=GO, bit1=CLEAR_DONE
0x08   | STATUS       | bit0=ACTIVE, bit1=DONE
0x0C   | reserved

================================================================================
MAILBOX WISHBONE SLAVE (RTL)
================================================================================

File: rtl/soc/hart_mailbox_wb.sv

module hart_mailbox_wb
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output reg         wb_ack_o,
    output wire        wb_err_o,

    // To harts
    output reg  [31:0] hart_start_addr [0:3],
    output reg         hart_go         [0:3],
    input  wire        hart_active     [0:3],
    input  wire        hart_done       [0:3]
);

    assign wb_err_o = 1'b0;

    reg [31:0] start_addr_reg [0:3];
    reg [31:0] cmd_reg        [0:3];
    reg [31:0] status_reg     [0:3];

    integer i;

    wire [1:0] hart_idx = wb_adr_i[5:4];   // 0..3
    wire [3:0] reg_sel  = wb_adr_i[3:0];   // 0x0,0x4,0x8,...

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            for (i=0;i<4;i=i+1) begin
                start_addr_reg[i] <= 32'h8000_0000;
                cmd_reg[i]        <= 32'h0;
                status_reg[i]     <= 32'h0;
                hart_start_addr[i]<= 32'h8000_0000;
                hart_go[i]        <= 1'b0;
            end
            wb_ack_o <= 1'b0;
            wb_dat_o <= 32'h0;
        end else begin
            wb_ack_o <= 1'b0;

            // Update ACTIVE/DONE from harts
            for (i=0;i<4;i=i+1) begin
                status_reg[i][0] <= hart_active[i];
                status_reg[i][1] <= hart_done[i];
            end

            if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin
                wb_ack_o <= 1'b1;

                if (wb_we_i) begin
                    case (reg_sel[3:2])
                        2'b00: begin
                            start_addr_reg[hart_idx] <= wb_dat_i;
                            hart_start_addr[hart_idx]<= wb_dat_i;
                        end
                        2'b01: begin
                            cmd_reg[hart_idx] <= wb_dat_i;
                            hart_go[hart_idx] <= wb_dat_i[0];
                            if (wb_dat_i[1]) status_reg[hart_idx][1] <= 1'b0;
                        end
                        default: ;
                    endcase
                end else begin
                    case (reg_sel[3:2])
                        2'b00: wb_dat_o <= start_addr_reg[hart_idx];
                        2'b01: wb_dat_o <= cmd_reg[hart_idx];
                        2'b10: wb_dat_o <= status_reg[hart_idx];
                        default: wb_dat_o <= 32'h0;
                    endcase
                end
            end
        end
    end
endmodule

================================================================================
TOP_SOC.SV CHANGES
================================================================================

1. Add WB slave s6 for mailbox (decode 0x1000_0400).
2. Instantiate hart_mailbox_wb.
3. Add hart_start_addr[], hart_go[], hart_active[], hart_done[] wires.
4. For now, tie hart_active/done low (Phase 2C will implement real signals).

Example additions:

// WB signals for s6
wire [31:0] s6_adr_o, s6_dat_o, s6_dat_i;
wire        s6_we_o, s6_cyc_o, s6_stb_o;
wire [3:0]  s6_sel_o;
wire        s6_ack_i, s6_err_i;

// Hart mailbox signals
wire [31:0] hart_start_addr [0:3];
wire        hart_go         [0:3];
wire        hart_active     [0:3];
wire        hart_done       [0:3];

assign hart_active[0]=1'b0;
assign hart_active[1]=1'b0;
assign hart_active[2]=1'b0;
assign hart_active[3]=1'b0;

assign hart_done[0]=1'b0;
assign hart_done[1]=1'b0;
assign hart_done[2]=1'b0;
assign hart_done[3]=1'b0;

hart_mailbox_wb u_hart_mb (
    .clk(clk), .rst(rst),
    .wb_adr_i(s6_adr_o), .wb_dat_i(s6_dat_o), .wb_dat_o(s6_dat_i),
    .wb_we_i(s6_we_o), .wb_sel_i(s6_sel_o),
    .wb_cyc_i(s6_cyc_o), .wb_stb_i(s6_stb_o),
    .wb_ack_o(s6_ack_i), .wb_err_o(s6_err_i),
    .hart_start_addr(hart_start_addr),
    .hart_go(hart_go),
    .hart_active(hart_active),
    .hart_done(hart_done)
);

================================================================================
BOOT ROM CHANGES (SECONDARY HART ENTRY)
================================================================================

Add:

static inline uint32_t h3_read_mhartid(void)
{
    uint32_t v;
    __asm__ volatile ("csrr %0, mhartid" : "=r"(v));
    return v;
}

#define MBOX_BASE   0x10000400u
#define MBOX_STRIDE 0x10u
#define MBOX_CMD_GO (1u<<0)

static volatile uint32_t *mbox_start(uint32_t h)
{ return (uint32_t*)(MBOX_BASE + MBOX_STRIDE*h + 0x00); }

static volatile uint32_t *mbox_cmd(uint32_t h)
{ return (uint32_t*)(MBOX_BASE + MBOX_STRIDE*h + 0x04); }

static void secondary_hart_entry(uint32_t hartid)
{
    while (1) {
        if (*mbox_cmd(hartid) & MBOX_CMD_GO) {
            uint32_t addr = *mbox_start(hartid);
            *mbox_cmd(hartid) = 0; // clear GO
            void (*entry)(void) = (void(*)(void))addr;
            entry();
        }
        __asm__ volatile("wfi");
    }
}

In _start():

uint32_t hartid = h3_read_mhartid();
if (hartid != 0)
    secondary_hart_entry(hartid);

HART0 continues into the bootloader as before.

================================================================================
SDRAM FIRMWARE (PHASE 1K) — STARTING OTHER HARTS
================================================================================

In main.c:

#define H3_MBOX_BASE   0x10000400u
#define H3_MBOX_STRIDE 0x10u
#define H3_MBOX_CMD_GO (1u<<0)

static inline volatile uint32_t *H3_MBOX_START(uint32_t h)
{ return (uint32_t*)(H3_MBOX_BASE + H3_MBOX_STRIDE*h + 0x00); }

static inline volatile uint32_t *H3_MBOX_CMD(uint32_t h)
{ return (uint32_t*)(H3_MBOX_BASE + H3_MBOX_STRIDE*h + 0x04); }

To start HART1:

*H3_MBOX_START(1) = 0x80000000;
*H3_MBOX_CMD(1)   = H3_MBOX_CMD_GO;

HART1 will jump into SDRAM firmware.

================================================================================
RESULT OF PHASE 2B
================================================================================

You now have:

- A **4‑hart SoC** where:
  - HART0 boots normally.
  - HART1–3 park safely.
  - HART0 or SDRAM firmware can start any secondary hart at any address.

This is the minimal, clean, reproducible multi‑hart bring‑up mechanism.
########END P2B########
