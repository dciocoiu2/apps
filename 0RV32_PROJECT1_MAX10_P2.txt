⚠️⚠️START WITH FIRST FILE THIS IS PART2⚠️⚠️
================================================================================
PHASE 2A: ADD HART1–HART3 (MULTI-CORE HAZARD3 TILES ON AHB M1–M3)
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 2A
----------------
Turn your single-core Hazard3 SoC into a **4-hart SoC** by:

- Instantiating **HART1, HART2, HART3** as additional Hazard3 tiles.
- Connecting them as AHB masters M1, M2, M3 in the existing AHB fabric.
- Defining a simple **boot discipline**:
  - HART0 (M0) is the primary boot hart.
  - HART1–3 enter a “parked” wait loop until firmware explicitly releases them.
- Keeping all existing peripherals, bootloader, HAL, and SDRAM unchanged.

Still:

- FPGA is configured via `.sof` into **SRAM only**.
- No flash programming; power-cycle → factory demo.
- All changes are in RTL and firmware only.

HIGH-LEVEL DESIGN
-----------------
- Each hart:
  - Has its own Hazard3 tile instance with unique HART_ID (0,1,2,3).
  - Shares the same Boot ROM and SDRAM/peripheral address map.
- Boot behavior:
  - Hardware: all harts reset together.
  - Software: HART0 follows full bootloader flow, HART1–3 park in a loop.
  - Later phases (2B/2C) will add CLINT-like start/wakeup, but 2A just gets
    all four cores instantiated and behaving safely.

================================================================================
STEP 1 — MULTI-HART ENTRY CONVENTION IN BOOT ROM
================================================================================

We’ll define how each hart behaves at reset. Hazard3 provides a hart ID (via CSR
or parameter). For now, we assume:

- Bootloader code can read mhartid via CSR and branch.
- HART0 runs the full bootloader logic.
- HART1–3 just park in WFI until future phases use them.

You can adapt your bootrom.c (Phase 1I) with a tiny shim:

----- PATCH CONCEPT FOR ~/hazard3_fw/bootrom/bootrom.c ------------------------

/* Add CSR read helper (inline asm) */
static inline uint32_t h3_read_mhartid(void)
{
    uint32_t v;
    __asm__ volatile ("csrr %0, mhartid" : "=r"(v));
    return v;
}

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;
    uint32_t hartid = h3_read_mhartid();

    /* Only HART0 runs the bootloader for now. */
    if (hartid != 0) {
        while (1) {
            __asm__ volatile ("wfi");
        }
    }

    uart_init(SYS_CLK_HZ, 115200u);
    select_console();
    con_puts("\nHazard3 Phase 1I Bootloader (H3BT) - HART0\n");
    ...
    bootloader_loop();
}

Rebuild `bootrom.hex` after this change, same as Phase 1I.

Note:
- HART1–3 are electrically alive but permanently parked in WFI until we add
  an inter-hart wake mechanism in Phase 2B/2C.
- This avoids spurious bus traffic from secondary harts.

================================================================================
STEP 2 — TOP-LEVEL RTL: ADD HART1–HART3 AND CONNECT TO AHB FABRIC
================================================================================

We now modify `top_soc.sv` to:

- Instantiate 3 more Hazard3 tiles.
- Connect them as AHB masters M1, M2, M3 on `ahb_interconnect_4m`.
- Provide them with the same clock/reset as HART0.
- Keep all downstream fabric/peripherals unchanged.

Assuming your `hazard3_tile` module has the same AHB-Lite master interface as in
Phase 1A and a parameter `HART_ID`, we do:

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv --------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n,

    // SDRAM pins
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq,

    // UART0 pins
    input  wire        uart0_rx,
    output wire        uart0_tx,

    // I2C0 pins
    inout  wire        i2c_sda,
    inout  wire        i2c_scl,

    // SPI0 pins
    output wire        spi_mosi,
    input  wire        spi_miso,
    output wire        spi_sck,
    output wire        spi_ss0,

    // GPIO pins
    inout  wire [19:0] gpio_pins
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    //==========================================================================
    // AHB master interfaces for 4 harts (M0..M3)
    //==========================================================================

    // HART0 (M0)
    wire [31:0] m0_haddr;
    wire [2:0]  m0_hsize;
    wire [1:0]  m0_hburst;
    wire [1:0]  m0_htrans;
    wire        m0_hwrite;
    wire [31:0] m0_hwdata;
    wire [31:0] m0_hrdata;
    wire        m0_hready;
    wire        m0_hresp;

    // HART1 (M1)
    wire [31:0] m1_haddr;
    wire [2:0]  m1_hsize;
    wire [1:0]  m1_hburst;
    wire [1:0]  m1_htrans;
    wire        m1_hwrite;
    wire [31:0] m1_hwdata;
    wire [31:0] m1_hrdata;
    wire        m1_hready;
    wire        m1_hresp;

    // HART2 (M2)
    wire [31:0] m2_haddr;
    wire [2:0]  m2_hsize;
    wire [1:0]  m2_hburst;
    wire [1:0]  m2_htrans;
    wire        m2_hwrite;
    wire [31:0] m2_hwdata;
    wire [31:0] m2_hrdata;
    wire        m2_hready;
    wire        m2_hresp;

    // HART3 (M3)
    wire [31:0] m3_haddr;
    wire [2:0]  m3_hsize;
    wire [1:0]  m3_hburst;
    wire [1:0]  m3_htrans;
    wire        m3_hwrite;
    wire [31:0] m3_hwdata;
    wire [31:0] m3_hrdata;
    wire        m3_hready;
    wire        m3_hresp;

    //==========================================================================
    // AHB slaves: s0 = Boot ROM, s1 = AHB→WB bridge (SDRAM + peripherals)
    //==========================================================================

    wire [31:0] s0_haddr, s1_haddr;
    wire [2:0]  s0_hsize, s1_hsize;
    wire [1:0]  s0_hburst, s1_hburst;
    wire [1:0]  s0_htrans, s1_htrans;
    wire        s0_hwrite, s1_hwrite;
    wire [31:0] s0_hwdata, s1_hwdata;
    wire [31:0] s0_hrdata, s1_hrdata;
    wire        s0_hready, s1_hready;
    wire        s0_hresp,  s1_hresp;

    //==========================================================================
    // HAZARD3 TILE INSTANCES (4 HARTS)
    //==========================================================================

    // HART0
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m0_haddr),
        .HSIZE  (m0_hsize),
        .HBURST (m0_hburst),
        .HTRANS (m0_htrans),
        .HWRITE (m0_hwrite),
        .HWDATA (m0_hwdata),
        .HRDATA (m0_hrdata),
        .HREADY (m0_hready),
        .HRESP  (m0_hresp)
    );

    // HART1
    hazard3_tile #(
        .HART_ID(1)
    ) u_hart1 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m1_haddr),
        .HSIZE  (m1_hsize),
        .HBURST (m1_hburst),
        .HTRANS (m1_htrans),
        .HWRITE (m1_hwrite),
        .HWDATA (m1_hwdata),
        .HRDATA (m1_hrdata),
        .HREADY (m1_hready),
        .HRESP  (m1_hresp)
    );

    // HART2
    hazard3_tile #(
        .HART_ID(2)
    ) u_hart2 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m2_haddr),
        .HSIZE  (m2_hsize),
        .HBURST (m2_hburst),
        .HTRANS (m2_htrans),
        .HWRITE (m2_hwrite),
        .HWDATA (m2_hwdata),
        .HRDATA (m2_hrdata),
        .HREADY (m2_hready),
        .HRESP  (m2_hresp)
    );

    // HART3
    hazard3_tile #(
        .HART_ID(3)
    ) u_hart3 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m3_haddr),
        .HSIZE  (m3_hsize),
        .HBURST (m3_hburst),
        .HTRANS (m3_htrans),
        .HWRITE (m3_hwrite),
        .HWDATA (m3_hwdata),
        .HRDATA (m3_hrdata),
        .HREADY (m3_hready),
        .HRESP  (m3_hresp)
    );

    //==========================================================================
    // AHB INTERCONNECT (4 MASTERS → 2 SLAVES)
    //==========================================================================

    ahb_interconnect_4m u_ahb_ic (
        .clk        (clk),
        .rst        (rst),

        // Masters
        .m0_haddr   (m0_haddr), .m0_hsize(m0_hsize), .m0_hburst(m0_hburst),
        .m0_htrans  (m0_htrans), .m0_hwrite(m0_hwrite), .m0_hwdata(m0_hwdata),
        .m0_hrdata  (m0_hrdata), .m0_hready(m0_hready), .m0_hresp(m0_hresp),

        .m1_haddr   (m1_haddr), .m1_hsize(m1_hsize), .m1_hburst(m1_hburst),
        .m1_htrans  (m1_htrans), .m1_hwrite(m1_hwrite), .m1_hwdata(m1_hwdata),
        .m1_hrdata  (m1_hrdata), .m1_hready(m1_hready), .m1_hresp(m1_hresp),

        .m2_haddr   (m2_haddr), .m2_hsize(m2_hsize), .m2_hburst(m2_hburst),
        .m2_htrans  (m2_htrans), .m2_hwrite(m2_hwrite), .m2_hwdata(m2_hwdata),
        .m2_hrdata  (m2_hrdata), .m2_hready(m2_hready), .m2_hresp(m2_hresp),

        .m3_haddr   (m3_haddr), .m3_hsize(m3_hsize), .m3_hburst(m3_hburst),
        .m3_htrans  (m3_htrans), .m3_hwrite(m3_hwrite), .m3_hwdata(m3_hwdata),
        .m3_hrdata  (m3_hrdata), .m3_hready(m3_hready), .m3_hresp(m3_hresp),

        // Slaves
        .s0_haddr   (s0_haddr), .s0_hsize(s0_hsize), .s0_hburst(s0_hburst),
        .s0_htrans  (s0_htrans), .s0_hwrite(s0_hwrite), .s0_hwdata(s0_hwdata),
        .s0_hrdata  (s0_hrdata), .s0_hready(s0_hready), .s0_hresp(s0_hresp),

        .s1_haddr   (s1_haddr), .s1_hsize(s1_hsize), .s1_hburst(s1_hburst),
        .s1_htrans  (s1_htrans), .s1_hwrite(s1_hwrite), .s1_hwdata(s1_hwdata),
        .s1_hrdata  (s1_hrdata), .s1_hready(s1_hready), .s1_hresp(s1_hresp)
    );

    //==========================================================================
    // Boot ROM, AHB→WB bridge, WB interconnect, SDRAM, UART0, I2C, SPI, GPIO,
    // JTAG-UART are exactly as in Phase 1H/1K.
    //==========================================================================
    //
    //  boot_rom u_boot_rom (attached to s0_*)
    //  ahb_to_wb_bridge u_ahb2wb (attached to s1_*)
    //  wb_interconnect u_wb_ic
    //  sdram_wb_wrapper u_sdram_wb (s0 of WB)
    //  uart16550_wb_wrapper u_uart0 (s1)
    //  i2c_wb_wrapper u_i2c0 (s2)
    //  spi_wb_wrapper u_spi0 (s3)
    //  gpio_wb u_gpio (s4)
    //  jtag_uart_0 + jtag_uart_wb_wrapper u_jtag (s5)
    //
    // Keep all that code identical to the end of Phase 1H/1K.

endmodule

Notes:

- The only structural change is: M1, M2, M3 are now driven by real harts
  instead of being tied off.
- The rest of the SoC (ROM, SDRAM, peripherals, bootloader, HAL) remains intact.

================================================================================
STEP 3 — QUARTUS: RECOMPILE AND PROGRAM (SRAM-ONLY)
================================================================================

1. Ensure RTL tree updated:
   - Only `top_soc.sv` changed.
   - All other files from Phase 1K remain.

2. Rebuild:
   - Open Quartus project `h3_phase1_sc`.
   - Processing → Start Compilation.

3. Program (SRAM only):
   - Quartus Programmer:
     - Hardware: USB-Blaster.
     - Mode: JTAG.
     - File: `h3_phase1_sc.sof`.
     - Check ONLY “Program/Configure”.
     - START.
   - No `.pof`, no flash writes.
   - Power-cycle → factory demo (unchanged).

================================================================================
STEP 4 — RUNTIME BEHAVIOR AFTER PHASE 2A
================================================================================

At reset:

- All 4 harts start at `_start` in Boot ROM.
- Each hart reads `mhartid`.
- HART0:
  - Runs the H3BT bootloader (Phase 1I).
  - Loads SDRAM firmware via UART0 / JTAG-UART.
  - Jumps to 0x80000000.
- HART1–3:
  - Immediately park in a WFI loop inside bootrom.

When firmware at 0x80000000 runs (Phase 1K):

- It currently assumes single-hart; only HART0 will execute it.
- HART1–3 remain parked in ROM WFI.
- In later phases (2B/2C), the firmware will:
  - Write to a CLINT-like block or shared memory to wake HART1–3.
  - Provide distinct roles to each hart.

For now, Phase 2A is about **clean multi-hart instantiation with safe behavior**.

================================================================================
WHAT PHASE 2A GIVES YOU
================================================================================

- A **quad-core Hazard3 SoC** at the hardware level:
  - 4 independent harts sharing:
    - ROM
    - SDRAM
    - UART/I2C/SPI/GPIO/JTAG-UART
- A consistent boot story:
  - HART0 is the designated boot/control hart.
  - HART1–3 are passive until explicitly activated later.
- No change to your ephemeral rule:
  - `.sof` → SRAM.
  - No flash touch.
  - Power-cycle → factory demo.

########END P2A########
================================================================================
PHASE 2B: INTER‑HART MAILBOX FOR STARTING HART1–HART3
(ALL CONTENT IN ONE COPY‑PASTABLE TEXTBOX)
================================================================================

OBJECTIVE
---------
Enable HART0 to explicitly start HART1–HART3 after SDRAM firmware is loaded.

We add:
- A tiny **mailbox** peripheral on Wishbone.
- Each hart gets:
  - START_ADDR register
  - CMD register (GO bit)
  - STATUS register (ACTIVE/DONE)
- HART1–3 park in ROM until GO is asserted.
- HART0 (or SDRAM firmware) writes GO + START_ADDR to launch them.

No interrupts yet. No timers. Pure polling + WFI.

================================================================================
MEMORY MAP
================================================================================

Mailbox base: **0x1000_0400**

Per‑hart region (16 bytes each):

Hart h region = base + 0x10 * h

Offset | Register     | Description
-------|--------------|-----------------------------------------
0x00   | START_ADDR   | 32‑bit address to jump to
0x04   | CMD          | bit0=GO, bit1=CLEAR_DONE
0x08   | STATUS       | bit0=ACTIVE, bit1=DONE
0x0C   | reserved

================================================================================
MAILBOX WISHBONE SLAVE (RTL)
================================================================================

File: rtl/soc/hart_mailbox_wb.sv

module hart_mailbox_wb
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output reg         wb_ack_o,
    output wire        wb_err_o,

    // To harts
    output reg  [31:0] hart_start_addr [0:3],
    output reg         hart_go         [0:3],
    input  wire        hart_active     [0:3],
    input  wire        hart_done       [0:3]
);

    assign wb_err_o = 1'b0;

    reg [31:0] start_addr_reg [0:3];
    reg [31:0] cmd_reg        [0:3];
    reg [31:0] status_reg     [0:3];

    integer i;

    wire [1:0] hart_idx = wb_adr_i[5:4];   // 0..3
    wire [3:0] reg_sel  = wb_adr_i[3:0];   // 0x0,0x4,0x8,...

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            for (i=0;i<4;i=i+1) begin
                start_addr_reg[i] <= 32'h8000_0000;
                cmd_reg[i]        <= 32'h0;
                status_reg[i]     <= 32'h0;
                hart_start_addr[i]<= 32'h8000_0000;
                hart_go[i]        <= 1'b0;
            end
            wb_ack_o <= 1'b0;
            wb_dat_o <= 32'h0;
        end else begin
            wb_ack_o <= 1'b0;

            // Update ACTIVE/DONE from harts
            for (i=0;i<4;i=i+1) begin
                status_reg[i][0] <= hart_active[i];
                status_reg[i][1] <= hart_done[i];
            end

            if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin
                wb_ack_o <= 1'b1;

                if (wb_we_i) begin
                    case (reg_sel[3:2])
                        2'b00: begin
                            start_addr_reg[hart_idx] <= wb_dat_i;
                            hart_start_addr[hart_idx]<= wb_dat_i;
                        end
                        2'b01: begin
                            cmd_reg[hart_idx] <= wb_dat_i;
                            hart_go[hart_idx] <= wb_dat_i[0];
                            if (wb_dat_i[1]) status_reg[hart_idx][1] <= 1'b0;
                        end
                        default: ;
                    endcase
                end else begin
                    case (reg_sel[3:2])
                        2'b00: wb_dat_o <= start_addr_reg[hart_idx];
                        2'b01: wb_dat_o <= cmd_reg[hart_idx];
                        2'b10: wb_dat_o <= status_reg[hart_idx];
                        default: wb_dat_o <= 32'h0;
                    endcase
                end
            end
        end
    end
endmodule

================================================================================
TOP_SOC.SV CHANGES
================================================================================

1. Add WB slave s6 for mailbox (decode 0x1000_0400).
2. Instantiate hart_mailbox_wb.
3. Add hart_start_addr[], hart_go[], hart_active[], hart_done[] wires.
4. For now, tie hart_active/done low (Phase 2C will implement real signals).

Example additions:

// WB signals for s6
wire [31:0] s6_adr_o, s6_dat_o, s6_dat_i;
wire        s6_we_o, s6_cyc_o, s6_stb_o;
wire [3:0]  s6_sel_o;
wire        s6_ack_i, s6_err_i;

// Hart mailbox signals
wire [31:0] hart_start_addr [0:3];
wire        hart_go         [0:3];
wire        hart_active     [0:3];
wire        hart_done       [0:3];

assign hart_active[0]=1'b0;
assign hart_active[1]=1'b0;
assign hart_active[2]=1'b0;
assign hart_active[3]=1'b0;

assign hart_done[0]=1'b0;
assign hart_done[1]=1'b0;
assign hart_done[2]=1'b0;
assign hart_done[3]=1'b0;

hart_mailbox_wb u_hart_mb (
    .clk(clk), .rst(rst),
    .wb_adr_i(s6_adr_o), .wb_dat_i(s6_dat_o), .wb_dat_o(s6_dat_i),
    .wb_we_i(s6_we_o), .wb_sel_i(s6_sel_o),
    .wb_cyc_i(s6_cyc_o), .wb_stb_i(s6_stb_o),
    .wb_ack_o(s6_ack_i), .wb_err_o(s6_err_i),
    .hart_start_addr(hart_start_addr),
    .hart_go(hart_go),
    .hart_active(hart_active),
    .hart_done(hart_done)
);

================================================================================
BOOT ROM CHANGES (SECONDARY HART ENTRY)
================================================================================

Add:

static inline uint32_t h3_read_mhartid(void)
{
    uint32_t v;
    __asm__ volatile ("csrr %0, mhartid" : "=r"(v));
    return v;
}

#define MBOX_BASE   0x10000400u
#define MBOX_STRIDE 0x10u
#define MBOX_CMD_GO (1u<<0)

static volatile uint32_t *mbox_start(uint32_t h)
{ return (uint32_t*)(MBOX_BASE + MBOX_STRIDE*h + 0x00); }

static volatile uint32_t *mbox_cmd(uint32_t h)
{ return (uint32_t*)(MBOX_BASE + MBOX_STRIDE*h + 0x04); }

static void secondary_hart_entry(uint32_t hartid)
{
    while (1) {
        if (*mbox_cmd(hartid) & MBOX_CMD_GO) {
            uint32_t addr = *mbox_start(hartid);
            *mbox_cmd(hartid) = 0; // clear GO
            void (*entry)(void) = (void(*)(void))addr;
            entry();
        }
        __asm__ volatile("wfi");
    }
}

In _start():

uint32_t hartid = h3_read_mhartid();
if (hartid != 0)
    secondary_hart_entry(hartid);

HART0 continues into the bootloader as before.

================================================================================
SDRAM FIRMWARE (PHASE 1K) — STARTING OTHER HARTS
================================================================================

In main.c:

#define H3_MBOX_BASE   0x10000400u
#define H3_MBOX_STRIDE 0x10u
#define H3_MBOX_CMD_GO (1u<<0)

static inline volatile uint32_t *H3_MBOX_START(uint32_t h)
{ return (uint32_t*)(H3_MBOX_BASE + H3_MBOX_STRIDE*h + 0x00); }

static inline volatile uint32_t *H3_MBOX_CMD(uint32_t h)
{ return (uint32_t*)(H3_MBOX_BASE + H3_MBOX_STRIDE*h + 0x04); }

To start HART1:

*H3_MBOX_START(1) = 0x80000000;
*H3_MBOX_CMD(1)   = H3_MBOX_CMD_GO;

HART1 will jump into SDRAM firmware.

================================================================================
RESULT OF PHASE 2B
================================================================================

You now have:

- A **4‑hart SoC** where:
  - HART0 boots normally.
  - HART1–3 park safely.
  - HART0 or SDRAM firmware can start any secondary hart at any address.

This is the minimal, clean, reproducible multi‑hart bring‑up mechanism.
########END P2B########
================================================================================
PHASE 2C: CLINT-LITE (MSIP + MTIME) FOR MULTI-HART HAZARD3
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX)
================================================================================

OBJECTIVE
---------
Add a minimal **CLINT-like** block that provides:

- **MSIP** (software interrupt) bits per hart:
  - Used to wake harts from WFI and signal events.
- **MTIME** (global cycle/tick counter).
- **MTIMECMP[h]** (per-hart compare registers):
  - When MTIME >= MTIMECMP[h], hart h gets a timer interrupt.

We will:

- Implement a simple CLINT-lite on Wishbone.
- Map it at **0x1000_0600**.
- Wire its interrupt outputs into each Hazard3 tile’s machine external/timer interrupt inputs (or reuse a generic IRQ input if that’s how your tile is configured).
- Provide a minimal HAL-facing register map so firmware can:
  - Trigger software interrupts.
  - Program timers per hart.
  - Use MSIP to wake harts instead of pure polling.

Still:

- No flash programming.
- `.sof` only into FPGA SRAM.
- Power-cycle → factory demo.

================================================================================
CLINT-LITE REGISTER MAP
================================================================================

Base address: **0x1000_0600**

We’ll follow a simplified RISC-V CLINT style (but on Wishbone):

- Global:

  - 0x00: MTIME_LO   (RW, 32-bit)
  - 0x04: MTIME_HI   (RW, 32-bit)

- Per-hart (h = 0..3):

  - MSIP[h]:
    - 0x10 + 0x04 * h: MSIP[h] (RW, 32-bit; bit0 is msip)
  - MTIMECMP[h]:
    - 0x30 + 0x08 * h: MTIMECMP_LO[h] (RW, 32-bit)
    - 0x34 + 0x08 * h: MTIMECMP_HI[h] (RW, 32-bit)

Behavior:

- MTIME: increments every clock tick (or every N clocks if you want prescale).
- MSIP[h]:
  - When bit0 = 1 → software interrupt pending for hart h.
- MTIMECMP[h]:
  - When MTIME >= MTIMECMP[h] → timer interrupt pending for hart h.

We’ll provide two output vectors:

- `msip_irq[0..3]`
- `mtime_irq[0..3]`

You can map these to Hazard3’s interrupt inputs (e.g., machine software interrupt, machine timer interrupt).

================================================================================
CLINT-LITE WISHBONE SLAVE RTL
================================================================================

File: rtl/soc/clint_wb.sv

module clint_wb
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output reg         wb_ack_o,
    output wire        wb_err_o,

    // Outputs to harts
    output wire [3:0]  msip_irq,
    output wire [3:0]  mtime_irq
);

    assign wb_err_o = 1'b0;

    // MTIME
    reg [31:0] mtime_lo;
    reg [31:0] mtime_hi;

    // MSIP
    reg [31:0] msip   [0:3];

    // MTIMECMP
    reg [31:0] mtimecmp_lo [0:3];
    reg [31:0] mtimecmp_hi [0:3];

    integer i;

    // MTIME increment (simple, every clock)
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            mtime_lo <= 32'h0;
            mtime_hi <= 32'h0;
        end else begin
            {mtime_hi, mtime_lo} <= {mtime_hi, mtime_lo} + 64'd1;
        end
    end

    // Interrupt generation
    genvar h;
    generate
        for (h = 0; h < 4; h = h + 1) begin : gen_irq
            wire [63:0] now   = {mtime_hi, mtime_lo};
            wire [63:0] cmp_h = {mtimecmp_hi[h], mtimecmp_lo[h]};

            assign msip_irq[h]  = msip[h][0];
            assign mtime_irq[h] = (now >= cmp_h);
        end
    endgenerate

    // Wishbone access
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            wb_ack_o <= 1'b0;
            wb_dat_o <= 32'h0;
            for (i = 0; i < 4; i = i + 1) begin
                msip[i]        <= 32'h0;
                mtimecmp_lo[i] <= 32'hFFFF_FFFF;
                mtimecmp_hi[i] <= 32'hFFFF_FFFF;
            end
        end else begin
            wb_ack_o <= 1'b0;

            if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin
                wb_ack_o <= 1'b1;

                if (wb_we_i) begin
                    case (wb_adr_i[7:2])
                        // MTIME
                        6'h00: mtime_lo <= wb_dat_i;
                        6'h01: mtime_hi <= wb_dat_i;

                        // MSIP[h]: 0x10 + 4*h
                        6'h04: msip[0]  <= wb_dat_i;
                        6'h05: msip[1]  <= wb_dat_i;
                        6'h06: msip[2]  <= wb_dat_i;
                        6'h07: msip[3]  <= wb_dat_i;

                        // MTIMECMP[h]: 0x30 + 8*h
                        6'h0C: mtimecmp_lo[0] <= wb_dat_i;
                        6'h0D: mtimecmp_hi[0] <= wb_dat_i;
                        6'h0E: mtimecmp_lo[1] <= wb_dat_i;
                        6'h0F: mtimecmp_hi[1] <= wb_dat_i;
                        6'h10: mtimecmp_lo[2] <= wb_dat_i;
                        6'h11: mtimecmp_hi[2] <= wb_dat_i;
                        6'h12: mtimecmp_lo[3] <= wb_dat_i;
                        6'h13: mtimecmp_hi[3] <= wb_dat_i;

                        default: ;
                    endcase
                end else begin
                    case (wb_adr_i[7:2])
                        // MTIME
                        6'h00: wb_dat_o <= mtime_lo;
                        6'h01: wb_dat_o <= mtime_hi;

                        // MSIP[h]
                        6'h04: wb_dat_o <= msip[0];
                        6'h05: wb_dat_o <= msip[1];
                        6'h06: wb_dat_o <= msip[2];
                        6'h07: wb_dat_o <= msip[3];

                        // MTIMECMP[h]
                        6'h0C: wb_dat_o <= mtimecmp_lo[0];
                        6'h0D: wb_dat_o <= mtimecmp_hi[0];
                        6'h0E: wb_dat_o <= mtimecmp_lo[1];
                        6'h0F: wb_dat_o <= mtimecmp_hi[1];
                        6'h10: wb_dat_o <= mtimecmp_lo[2];
                        6'h11: wb_dat_o <= mtimecmp_hi[2];
                        6'h12: wb_dat_o <= mtimecmp_lo[3];
                        6'h13: wb_dat_o <= mtimecmp_hi[3];

                        default: wb_dat_o <= 32'h0;
                    endcase
                end
            end
        end
    end

endmodule

Notes:
- `wb_adr_i[7:2]` gives a 4‑byte word index inside 0x1000_0600 region.
- MTIMECMP defaults to max so no timer IRQ until firmware programs it.

================================================================================
WB INTERCONNECT + TOP_SOC INTEGRATION
================================================================================

We add CLINT as another Wishbone slave (say s7) decoded at:

- 0x1000_0600 – 0x1000_06FF

### 1. In wb_interconnect.sv

- Add s7 ports.
- Add decode:

  sel_s7 = (m_adr_i[31:8] == 24'h100006);

- Route s7_* in the muxes, same pattern as s0..s6.

### 2. In top_soc.sv

Add WB signals:

wire [31:0] s7_adr_o, s7_dat_o, s7_dat_i;
wire        s7_we_o, s7_cyc_o, s7_stb_o;
wire [3:0]  s7_sel_o;
wire        s7_ack_i, s7_err_i;

Add CLINT outputs:

wire [3:0] clint_msip_irq;
wire [3:0] clint_mtime_irq;

Instantiate CLINT:

clint_wb u_clint (
    .clk       (clk),
    .rst       (rst),
    .wb_adr_i  (s7_adr_o),
    .wb_dat_i  (s7_dat_o),
    .wb_dat_o  (s7_dat_i),
    .wb_we_i   (s7_we_o),
    .wb_sel_i  (s7_sel_o),
    .wb_cyc_i  (s7_cyc_o),
    .wb_stb_i  (s7_stb_o),
    .wb_ack_o  (s7_ack_i),
    .wb_err_o  (s7_err_i),
    .msip_irq  (clint_msip_irq),
    .mtime_irq (clint_mtime_irq)
);

================================================================================
CONNECTING CLINT INTERRUPTS TO HAZARD3 TILES
================================================================================

This depends on your Hazard3 tile interface. Conceptually:

- Each hart has inputs:
  - `msip_i` (machine software interrupt)
  - `mtip_i` (machine timer interrupt)

If your `hazard3_tile` has such inputs, wire:

- For HART0:

  .msip_i(clint_msip_irq[0]),
  .mtip_i(clint_mtime_irq[0]),

- For HART1:

  .msip_i(clint_msip_irq[1]),
  .mtip_i(clint_mtime_irq[1]),

- etc.

If instead you have a generic IRQ input, you can OR msip + mtime:

wire [3:0] hart_irq;
assign hart_irq[0] = clint_msip_irq[0] | clint_mtime_irq[0];
...

and connect `.irq_i(hart_irq[0])` or similar.

The key is: CLINT output -> Hart interrupt input.

================================================================================
FIRMWARE/HAL VIEW (IN SDRAM FIRMWARE)
================================================================================

We expose CLINT registers to software.

In h3_soc.h:

#define H3_CLINT_BASE      0x10000600u
#define H3_CLINT_MTIME_LO  (*(volatile uint32_t *)(H3_CLINT_BASE + 0x00))
#define H3_CLINT_MTIME_HI  (*(volatile uint32_t *)(H3_CLINT_BASE + 0x04))

#define H3_CLINT_MSIP(h)   (*(volatile uint32_t *)(H3_CLINT_BASE + 0x10 + 4u*(h)))

#define H3_CLINT_MTIMECMP_LO(h) (*(volatile uint32_t *)(H3_CLINT_BASE + 0x30 + 8u*(h)))
#define H3_CLINT_MTIMECMP_HI(h) (*(volatile uint32_t *)(H3_CLINT_BASE + 0x34 + 8u*(h)))

Simple helper functions:

static inline void h3_clint_software_irq(uint32_t hartid, int enable)
{
    if (enable)
        H3_CLINT_MSIP(hartid) = 1u;
    else
        H3_CLINT_MSIP(hartid) = 0u;
}

static inline void h3_clint_set_timer(uint32_t hartid, uint64_t tick)
{
    H3_CLINT_MTIMECMP_LO(hartid) = (uint32_t)(tick & 0xFFFFFFFFu);
    H3_CLINT_MTIMECMP_HI(hartid) = (uint32_t)(tick >> 32);
}

================================================================================
USAGE PATTERNS
================================================================================

1) Wake a hart from WFI via software interrupt:

- From HART0:

  h3_clint_software_irq(1, 1);  // set MSIP for hart1

- In HART1 firmware:
  - Enable machine software interrupt (mstatus, mie).
  - WFI will wake when MSIP is set.
  - ISR clears MSIP and continues.

2) Periodic timer on a hart:

- Get current MTIME:

  uint64_t now = ((uint64_t)H3_CLINT_MTIME_HI << 32) | H3_CLINT_MTIME_LO;

- Set MTIMECMP for hart h:

  h3_clint_set_timer(h, now + delta);

- When MTIME >= MTIMECMP[h], timer interrupt asserts.

================================================================================
QUARTUS + FLOW
================================================================================

1. Add clint_wb.sv to the project.
2. Update wb_interconnect.sv with s7 decode at 0x1000_0600.
3. Update top_soc.sv:
   - Add s7_* wires.
   - Instantiate u_clint.
   - Connect interrupts to each hart.
4. Optionally update HAL (`h3_soc.h`) with CLINT register macros and helpers.
5. Rebuild bootrom only if you plan to use CLINT from ROM (not required yet).
6. Recompile project, program .sof to SRAM over JTAG.
7. Power-cycle → still factory demo by default.

================================================================================
RESULT OF PHASE 2C
================================================================================

You now have:

- A multi-hart Hazard3 SoC with:
  - Mailbox (Phase 2B) for explicit start addresses.
  - CLINT-lite (Phase 2C) for:
    - software interrupts (MSIP)
    - per-hart timers (MTIMECMP + MTIME)
- A real path to:
  - Wake harts from WFI.
  - Implement preemption, time slicing, or simple scheduling.
  - Stay fully ephemeral and reproducible.

########END P2C########