⚠️⚠️START WITH FIRST FILE THIS IS PART2⚠️⚠️
================================================================================
PHASE 2A: ADD HART1–HART3 (MULTI-CORE HAZARD3 TILES ON AHB M1–M3)
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 2A
----------------
Turn your single-core Hazard3 SoC into a **4-hart SoC** by:

- Instantiating **HART1, HART2, HART3** as additional Hazard3 tiles.
- Connecting them as AHB masters M1, M2, M3 in the existing AHB fabric.
- Defining a simple **boot discipline**:
  - HART0 (M0) is the primary boot hart.
  - HART1–3 enter a “parked” wait loop until firmware explicitly releases them.
- Keeping all existing peripherals, bootloader, HAL, and SDRAM unchanged.

Still:

- FPGA is configured via `.sof` into **SRAM only**.
- No flash programming; power-cycle → factory demo.
- All changes are in RTL and firmware only.

HIGH-LEVEL DESIGN
-----------------
- Each hart:
  - Has its own Hazard3 tile instance with unique HART_ID (0,1,2,3).
  - Shares the same Boot ROM and SDRAM/peripheral address map.
- Boot behavior:
  - Hardware: all harts reset together.
  - Software: HART0 follows full bootloader flow, HART1–3 park in a loop.
  - Later phases (2B/2C) will add CLINT-like start/wakeup, but 2A just gets
    all four cores instantiated and behaving safely.

================================================================================
STEP 1 — MULTI-HART ENTRY CONVENTION IN BOOT ROM
================================================================================

We’ll define how each hart behaves at reset. Hazard3 provides a hart ID (via CSR
or parameter). For now, we assume:

- Bootloader code can read mhartid via CSR and branch.
- HART0 runs the full bootloader logic.
- HART1–3 just park in WFI until future phases use them.

You can adapt your bootrom.c (Phase 1I) with a tiny shim:

----- PATCH CONCEPT FOR ~/hazard3_fw/bootrom/bootrom.c ------------------------

/* Add CSR read helper (inline asm) */
static inline uint32_t h3_read_mhartid(void)
{
    uint32_t v;
    __asm__ volatile ("csrr %0, mhartid" : "=r"(v));
    return v;
}

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;
    uint32_t hartid = h3_read_mhartid();

    /* Only HART0 runs the bootloader for now. */
    if (hartid != 0) {
        while (1) {
            __asm__ volatile ("wfi");
        }
    }

    uart_init(SYS_CLK_HZ, 115200u);
    select_console();
    con_puts("\nHazard3 Phase 1I Bootloader (H3BT) - HART0\n");
    ...
    bootloader_loop();
}

Rebuild `bootrom.hex` after this change, same as Phase 1I.

Note:
- HART1–3 are electrically alive but permanently parked in WFI until we add
  an inter-hart wake mechanism in Phase 2B/2C.
- This avoids spurious bus traffic from secondary harts.

================================================================================
STEP 2 — TOP-LEVEL RTL: ADD HART1–HART3 AND CONNECT TO AHB FABRIC
================================================================================

We now modify `top_soc.sv` to:

- Instantiate 3 more Hazard3 tiles.
- Connect them as AHB masters M1, M2, M3 on `ahb_interconnect_4m`.
- Provide them with the same clock/reset as HART0.
- Keep all downstream fabric/peripherals unchanged.

Assuming your `hazard3_tile` module has the same AHB-Lite master interface as in
Phase 1A and a parameter `HART_ID`, we do:

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv --------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n,

    // SDRAM pins
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq,

    // UART0 pins
    input  wire        uart0_rx,
    output wire        uart0_tx,

    // I2C0 pins
    inout  wire        i2c_sda,
    inout  wire        i2c_scl,

    // SPI0 pins
    output wire        spi_mosi,
    input  wire        spi_miso,
    output wire        spi_sck,
    output wire        spi_ss0,

    // GPIO pins
    inout  wire [19:0] gpio_pins
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    //==========================================================================
    // AHB master interfaces for 4 harts (M0..M3)
    //==========================================================================

    // HART0 (M0)
    wire [31:0] m0_haddr;
    wire [2:0]  m0_hsize;
    wire [1:0]  m0_hburst;
    wire [1:0]  m0_htrans;
    wire        m0_hwrite;
    wire [31:0] m0_hwdata;
    wire [31:0] m0_hrdata;
    wire        m0_hready;
    wire        m0_hresp;

    // HART1 (M1)
    wire [31:0] m1_haddr;
    wire [2:0]  m1_hsize;
    wire [1:0]  m1_hburst;
    wire [1:0]  m1_htrans;
    wire        m1_hwrite;
    wire [31:0] m1_hwdata;
    wire [31:0] m1_hrdata;
    wire        m1_hready;
    wire        m1_hresp;

    // HART2 (M2)
    wire [31:0] m2_haddr;
    wire [2:0]  m2_hsize;
    wire [1:0]  m2_hburst;
    wire [1:0]  m2_htrans;
    wire        m2_hwrite;
    wire [31:0] m2_hwdata;
    wire [31:0] m2_hrdata;
    wire        m2_hready;
    wire        m2_hresp;

    // HART3 (M3)
    wire [31:0] m3_haddr;
    wire [2:0]  m3_hsize;
    wire [1:0]  m3_hburst;
    wire [1:0]  m3_htrans;
    wire        m3_hwrite;
    wire [31:0] m3_hwdata;
    wire [31:0] m3_hrdata;
    wire        m3_hready;
    wire        m3_hresp;

    //==========================================================================
    // AHB slaves: s0 = Boot ROM, s1 = AHB→WB bridge (SDRAM + peripherals)
    //==========================================================================

    wire [31:0] s0_haddr, s1_haddr;
    wire [2:0]  s0_hsize, s1_hsize;
    wire [1:0]  s0_hburst, s1_hburst;
    wire [1:0]  s0_htrans, s1_htrans;
    wire        s0_hwrite, s1_hwrite;
    wire [31:0] s0_hwdata, s1_hwdata;
    wire [31:0] s0_hrdata, s1_hrdata;
    wire        s0_hready, s1_hready;
    wire        s0_hresp,  s1_hresp;

    //==========================================================================
    // HAZARD3 TILE INSTANCES (4 HARTS)
    //==========================================================================

    // HART0
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m0_haddr),
        .HSIZE  (m0_hsize),
        .HBURST (m0_hburst),
        .HTRANS (m0_htrans),
        .HWRITE (m0_hwrite),
        .HWDATA (m0_hwdata),
        .HRDATA (m0_hrdata),
        .HREADY (m0_hready),
        .HRESP  (m0_hresp)
    );

    // HART1
    hazard3_tile #(
        .HART_ID(1)
    ) u_hart1 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m1_haddr),
        .HSIZE  (m1_hsize),
        .HBURST (m1_hburst),
        .HTRANS (m1_htrans),
        .HWRITE (m1_hwrite),
        .HWDATA (m1_hwdata),
        .HRDATA (m1_hrdata),
        .HREADY (m1_hready),
        .HRESP  (m1_hresp)
    );

    // HART2
    hazard3_tile #(
        .HART_ID(2)
    ) u_hart2 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m2_haddr),
        .HSIZE  (m2_hsize),
        .HBURST (m2_hburst),
        .HTRANS (m2_htrans),
        .HWRITE (m2_hwrite),
        .HWDATA (m2_hwdata),
        .HRDATA (m2_hrdata),
        .HREADY (m2_hready),
        .HRESP  (m2_hresp)
    );

    // HART3
    hazard3_tile #(
        .HART_ID(3)
    ) u_hart3 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m3_haddr),
        .HSIZE  (m3_hsize),
        .HBURST (m3_hburst),
        .HTRANS (m3_htrans),
        .HWRITE (m3_hwrite),
        .HWDATA (m3_hwdata),
        .HRDATA (m3_hrdata),
        .HREADY (m3_hready),
        .HRESP  (m3_hresp)
    );

    //==========================================================================
    // AHB INTERCONNECT (4 MASTERS → 2 SLAVES)
    //==========================================================================

    ahb_interconnect_4m u_ahb_ic (
        .clk        (clk),
        .rst        (rst),

        // Masters
        .m0_haddr   (m0_haddr), .m0_hsize(m0_hsize), .m0_hburst(m0_hburst),
        .m0_htrans  (m0_htrans), .m0_hwrite(m0_hwrite), .m0_hwdata(m0_hwdata),
        .m0_hrdata  (m0_hrdata), .m0_hready(m0_hready), .m0_hresp(m0_hresp),

        .m1_haddr   (m1_haddr), .m1_hsize(m1_hsize), .m1_hburst(m1_hburst),
        .m1_htrans  (m1_htrans), .m1_hwrite(m1_hwrite), .m1_hwdata(m1_hwdata),
        .m1_hrdata  (m1_hrdata), .m1_hready(m1_hready), .m1_hresp(m1_hresp),

        .m2_haddr   (m2_haddr), .m2_hsize(m2_hsize), .m2_hburst(m2_hburst),
        .m2_htrans  (m2_htrans), .m2_hwrite(m2_hwrite), .m2_hwdata(m2_hwdata),
        .m2_hrdata  (m2_hrdata), .m2_hready(m2_hready), .m2_hresp(m2_hresp),

        .m3_haddr   (m3_haddr), .m3_hsize(m3_hsize), .m3_hburst(m3_hburst),
        .m3_htrans  (m3_htrans), .m3_hwrite(m3_hwrite), .m3_hwdata(m3_hwdata),
        .m3_hrdata  (m3_hrdata), .m3_hready(m3_hready), .m3_hresp(m3_hresp),

        // Slaves
        .s0_haddr   (s0_haddr), .s0_hsize(s0_hsize), .s0_hburst(s0_hburst),
        .s0_htrans  (s0_htrans), .s0_hwrite(s0_hwrite), .s0_hwdata(s0_hwdata),
        .s0_hrdata  (s0_hrdata), .s0_hready(s0_hready), .s0_hresp(s0_hresp),

        .s1_haddr   (s1_haddr), .s1_hsize(s1_hsize), .s1_hburst(s1_hburst),
        .s1_htrans  (s1_htrans), .s1_hwrite(s1_hwrite), .s1_hwdata(s1_hwdata),
        .s1_hrdata  (s1_hrdata), .s1_hready(s1_hready), .s1_hresp(s1_hresp)
    );

    //==========================================================================
    // Boot ROM, AHB→WB bridge, WB interconnect, SDRAM, UART0, I2C, SPI, GPIO,
    // JTAG-UART are exactly as in Phase 1H/1K.
    //==========================================================================
    //
    //  boot_rom u_boot_rom (attached to s0_*)
    //  ahb_to_wb_bridge u_ahb2wb (attached to s1_*)
    //  wb_interconnect u_wb_ic
    //  sdram_wb_wrapper u_sdram_wb (s0 of WB)
    //  uart16550_wb_wrapper u_uart0 (s1)
    //  i2c_wb_wrapper u_i2c0 (s2)
    //  spi_wb_wrapper u_spi0 (s3)
    //  gpio_wb u_gpio (s4)
    //  jtag_uart_0 + jtag_uart_wb_wrapper u_jtag (s5)
    //
    // Keep all that code identical to the end of Phase 1H/1K.

endmodule

Notes:

- The only structural change is: M1, M2, M3 are now driven by real harts
  instead of being tied off.
- The rest of the SoC (ROM, SDRAM, peripherals, bootloader, HAL) remains intact.

================================================================================
STEP 3 — QUARTUS: RECOMPILE AND PROGRAM (SRAM-ONLY)
================================================================================

1. Ensure RTL tree updated:
   - Only `top_soc.sv` changed.
   - All other files from Phase 1K remain.

2. Rebuild:
   - Open Quartus project `h3_phase1_sc`.
   - Processing → Start Compilation.

3. Program (SRAM only):
   - Quartus Programmer:
     - Hardware: USB-Blaster.
     - Mode: JTAG.
     - File: `h3_phase1_sc.sof`.
     - Check ONLY “Program/Configure”.
     - START.
   - No `.pof`, no flash writes.
   - Power-cycle → factory demo (unchanged).

================================================================================
STEP 4 — RUNTIME BEHAVIOR AFTER PHASE 2A
================================================================================

At reset:

- All 4 harts start at `_start` in Boot ROM.
- Each hart reads `mhartid`.
- HART0:
  - Runs the H3BT bootloader (Phase 1I).
  - Loads SDRAM firmware via UART0 / JTAG-UART.
  - Jumps to 0x80000000.
- HART1–3:
  - Immediately park in a WFI loop inside bootrom.

When firmware at 0x80000000 runs (Phase 1K):

- It currently assumes single-hart; only HART0 will execute it.
- HART1–3 remain parked in ROM WFI.
- In later phases (2B/2C), the firmware will:
  - Write to a CLINT-like block or shared memory to wake HART1–3.
  - Provide distinct roles to each hart.

For now, Phase 2A is about **clean multi-hart instantiation with safe behavior**.

================================================================================
WHAT PHASE 2A GIVES YOU
================================================================================

- A **quad-core Hazard3 SoC** at the hardware level:
  - 4 independent harts sharing:
    - ROM
    - SDRAM
    - UART/I2C/SPI/GPIO/JTAG-UART
- A consistent boot story:
  - HART0 is the designated boot/control hart.
  - HART1–3 are passive until explicitly activated later.
- No change to your ephemeral rule:
  - `.sof` → SRAM.
  - No flash touch.
  - Power-cycle → factory demo.

########END P2A########
================================================================================
PHASE 2B: INTER‑HART MAILBOX FOR STARTING HART1–HART3
(ALL CONTENT IN ONE COPY‑PASTABLE TEXTBOX)
================================================================================

OBJECTIVE
---------
Enable HART0 to explicitly start HART1–HART3 after SDRAM firmware is loaded.

We add:
- A tiny **mailbox** peripheral on Wishbone.
- Each hart gets:
  - START_ADDR register
  - CMD register (GO bit)
  - STATUS register (ACTIVE/DONE)
- HART1–3 park in ROM until GO is asserted.
- HART0 (or SDRAM firmware) writes GO + START_ADDR to launch them.

No interrupts yet. No timers. Pure polling + WFI.

================================================================================
MEMORY MAP
================================================================================

Mailbox base: **0x1000_0400**

Per‑hart region (16 bytes each):

Hart h region = base + 0x10 * h

Offset | Register     | Description
-------|--------------|-----------------------------------------
0x00   | START_ADDR   | 32‑bit address to jump to
0x04   | CMD          | bit0=GO, bit1=CLEAR_DONE
0x08   | STATUS       | bit0=ACTIVE, bit1=DONE
0x0C   | reserved

================================================================================
MAILBOX WISHBONE SLAVE (RTL)
================================================================================

File: rtl/soc/hart_mailbox_wb.sv

module hart_mailbox_wb
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output reg         wb_ack_o,
    output wire        wb_err_o,

    // To harts
    output reg  [31:0] hart_start_addr [0:3],
    output reg         hart_go         [0:3],
    input  wire        hart_active     [0:3],
    input  wire        hart_done       [0:3]
);

    assign wb_err_o = 1'b0;

    reg [31:0] start_addr_reg [0:3];
    reg [31:0] cmd_reg        [0:3];
    reg [31:0] status_reg     [0:3];

    integer i;

    wire [1:0] hart_idx = wb_adr_i[5:4];   // 0..3
    wire [3:0] reg_sel  = wb_adr_i[3:0];   // 0x0,0x4,0x8,...

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            for (i=0;i<4;i=i+1) begin
                start_addr_reg[i] <= 32'h8000_0000;
                cmd_reg[i]        <= 32'h0;
                status_reg[i]     <= 32'h0;
                hart_start_addr[i]<= 32'h8000_0000;
                hart_go[i]        <= 1'b0;
            end
            wb_ack_o <= 1'b0;
            wb_dat_o <= 32'h0;
        end else begin
            wb_ack_o <= 1'b0;

            // Update ACTIVE/DONE from harts
            for (i=0;i<4;i=i+1) begin
                status_reg[i][0] <= hart_active[i];
                status_reg[i][1] <= hart_done[i];
            end

            if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin
                wb_ack_o <= 1'b1;

                if (wb_we_i) begin
                    case (reg_sel[3:2])
                        2'b00: begin
                            start_addr_reg[hart_idx] <= wb_dat_i;
                            hart_start_addr[hart_idx]<= wb_dat_i;
                        end
                        2'b01: begin
                            cmd_reg[hart_idx] <= wb_dat_i;
                            hart_go[hart_idx] <= wb_dat_i[0];
                            if (wb_dat_i[1]) status_reg[hart_idx][1] <= 1'b0;
                        end
                        default: ;
                    endcase
                end else begin
                    case (reg_sel[3:2])
                        2'b00: wb_dat_o <= start_addr_reg[hart_idx];
                        2'b01: wb_dat_o <= cmd_reg[hart_idx];
                        2'b10: wb_dat_o <= status_reg[hart_idx];
                        default: wb_dat_o <= 32'h0;
                    endcase
                end
            end
        end
    end
endmodule

================================================================================
TOP_SOC.SV CHANGES
================================================================================

1. Add WB slave s6 for mailbox (decode 0x1000_0400).
2. Instantiate hart_mailbox_wb.
3. Add hart_start_addr[], hart_go[], hart_active[], hart_done[] wires.
4. For now, tie hart_active/done low (Phase 2C will implement real signals).

Example additions:

// WB signals for s6
wire [31:0] s6_adr_o, s6_dat_o, s6_dat_i;
wire        s6_we_o, s6_cyc_o, s6_stb_o;
wire [3:0]  s6_sel_o;
wire        s6_ack_i, s6_err_i;

// Hart mailbox signals
wire [31:0] hart_start_addr [0:3];
wire        hart_go         [0:3];
wire        hart_active     [0:3];
wire        hart_done       [0:3];

assign hart_active[0]=1'b0;
assign hart_active[1]=1'b0;
assign hart_active[2]=1'b0;
assign hart_active[3]=1'b0;

assign hart_done[0]=1'b0;
assign hart_done[1]=1'b0;
assign hart_done[2]=1'b0;
assign hart_done[3]=1'b0;

hart_mailbox_wb u_hart_mb (
    .clk(clk), .rst(rst),
    .wb_adr_i(s6_adr_o), .wb_dat_i(s6_dat_o), .wb_dat_o(s6_dat_i),
    .wb_we_i(s6_we_o), .wb_sel_i(s6_sel_o),
    .wb_cyc_i(s6_cyc_o), .wb_stb_i(s6_stb_o),
    .wb_ack_o(s6_ack_i), .wb_err_o(s6_err_i),
    .hart_start_addr(hart_start_addr),
    .hart_go(hart_go),
    .hart_active(hart_active),
    .hart_done(hart_done)
);

================================================================================
BOOT ROM CHANGES (SECONDARY HART ENTRY)
================================================================================

Add:

static inline uint32_t h3_read_mhartid(void)
{
    uint32_t v;
    __asm__ volatile ("csrr %0, mhartid" : "=r"(v));
    return v;
}

#define MBOX_BASE   0x10000400u
#define MBOX_STRIDE 0x10u
#define MBOX_CMD_GO (1u<<0)

static volatile uint32_t *mbox_start(uint32_t h)
{ return (uint32_t*)(MBOX_BASE + MBOX_STRIDE*h + 0x00); }

static volatile uint32_t *mbox_cmd(uint32_t h)
{ return (uint32_t*)(MBOX_BASE + MBOX_STRIDE*h + 0x04); }

static void secondary_hart_entry(uint32_t hartid)
{
    while (1) {
        if (*mbox_cmd(hartid) & MBOX_CMD_GO) {
            uint32_t addr = *mbox_start(hartid);
            *mbox_cmd(hartid) = 0; // clear GO
            void (*entry)(void) = (void(*)(void))addr;
            entry();
        }
        __asm__ volatile("wfi");
    }
}

In _start():

uint32_t hartid = h3_read_mhartid();
if (hartid != 0)
    secondary_hart_entry(hartid);

HART0 continues into the bootloader as before.

================================================================================
SDRAM FIRMWARE (PHASE 1K) — STARTING OTHER HARTS
================================================================================

In main.c:

#define H3_MBOX_BASE   0x10000400u
#define H3_MBOX_STRIDE 0x10u
#define H3_MBOX_CMD_GO (1u<<0)

static inline volatile uint32_t *H3_MBOX_START(uint32_t h)
{ return (uint32_t*)(H3_MBOX_BASE + H3_MBOX_STRIDE*h + 0x00); }

static inline volatile uint32_t *H3_MBOX_CMD(uint32_t h)
{ return (uint32_t*)(H3_MBOX_BASE + H3_MBOX_STRIDE*h + 0x04); }

To start HART1:

*H3_MBOX_START(1) = 0x80000000;
*H3_MBOX_CMD(1)   = H3_MBOX_CMD_GO;

HART1 will jump into SDRAM firmware.

================================================================================
RESULT OF PHASE 2B
================================================================================

You now have:

- A **4‑hart SoC** where:
  - HART0 boots normally.
  - HART1–3 park safely.
  - HART0 or SDRAM firmware can start any secondary hart at any address.

This is the minimal, clean, reproducible multi‑hart bring‑up mechanism.
########END P2B########
================================================================================
PHASE 2C: CLINT-LITE (MSIP + MTIME) FOR MULTI-HART HAZARD3
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX)
================================================================================

OBJECTIVE
---------
Add a minimal **CLINT-like** block that provides:

- **MSIP** (software interrupt) bits per hart:
  - Used to wake harts from WFI and signal events.
- **MTIME** (global cycle/tick counter).
- **MTIMECMP[h]** (per-hart compare registers):
  - When MTIME >= MTIMECMP[h], hart h gets a timer interrupt.

We will:

- Implement a simple CLINT-lite on Wishbone.
- Map it at **0x1000_0600**.
- Wire its interrupt outputs into each Hazard3 tile’s machine external/timer interrupt inputs (or reuse a generic IRQ input if that’s how your tile is configured).
- Provide a minimal HAL-facing register map so firmware can:
  - Trigger software interrupts.
  - Program timers per hart.
  - Use MSIP to wake harts instead of pure polling.

Still:

- No flash programming.
- `.sof` only into FPGA SRAM.
- Power-cycle → factory demo.

================================================================================
CLINT-LITE REGISTER MAP
================================================================================

Base address: **0x1000_0600**

We’ll follow a simplified RISC-V CLINT style (but on Wishbone):

- Global:

  - 0x00: MTIME_LO   (RW, 32-bit)
  - 0x04: MTIME_HI   (RW, 32-bit)

- Per-hart (h = 0..3):

  - MSIP[h]:
    - 0x10 + 0x04 * h: MSIP[h] (RW, 32-bit; bit0 is msip)
  - MTIMECMP[h]:
    - 0x30 + 0x08 * h: MTIMECMP_LO[h] (RW, 32-bit)
    - 0x34 + 0x08 * h: MTIMECMP_HI[h] (RW, 32-bit)

Behavior:

- MTIME: increments every clock tick (or every N clocks if you want prescale).
- MSIP[h]:
  - When bit0 = 1 → software interrupt pending for hart h.
- MTIMECMP[h]:
  - When MTIME >= MTIMECMP[h] → timer interrupt pending for hart h.

We’ll provide two output vectors:

- `msip_irq[0..3]`
- `mtime_irq[0..3]`

You can map these to Hazard3’s interrupt inputs (e.g., machine software interrupt, machine timer interrupt).

================================================================================
CLINT-LITE WISHBONE SLAVE RTL
================================================================================

File: rtl/soc/clint_wb.sv

module clint_wb
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output reg         wb_ack_o,
    output wire        wb_err_o,

    // Outputs to harts
    output wire [3:0]  msip_irq,
    output wire [3:0]  mtime_irq
);

    assign wb_err_o = 1'b0;

    // MTIME
    reg [31:0] mtime_lo;
    reg [31:0] mtime_hi;

    // MSIP
    reg [31:0] msip   [0:3];

    // MTIMECMP
    reg [31:0] mtimecmp_lo [0:3];
    reg [31:0] mtimecmp_hi [0:3];

    integer i;

    // MTIME increment (simple, every clock)
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            mtime_lo <= 32'h0;
            mtime_hi <= 32'h0;
        end else begin
            {mtime_hi, mtime_lo} <= {mtime_hi, mtime_lo} + 64'd1;
        end
    end

    // Interrupt generation
    genvar h;
    generate
        for (h = 0; h < 4; h = h + 1) begin : gen_irq
            wire [63:0] now   = {mtime_hi, mtime_lo};
            wire [63:0] cmp_h = {mtimecmp_hi[h], mtimecmp_lo[h]};

            assign msip_irq[h]  = msip[h][0];
            assign mtime_irq[h] = (now >= cmp_h);
        end
    endgenerate

    // Wishbone access
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            wb_ack_o <= 1'b0;
            wb_dat_o <= 32'h0;
            for (i = 0; i < 4; i = i + 1) begin
                msip[i]        <= 32'h0;
                mtimecmp_lo[i] <= 32'hFFFF_FFFF;
                mtimecmp_hi[i] <= 32'hFFFF_FFFF;
            end
        end else begin
            wb_ack_o <= 1'b0;

            if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin
                wb_ack_o <= 1'b1;

                if (wb_we_i) begin
                    case (wb_adr_i[7:2])
                        // MTIME
                        6'h00: mtime_lo <= wb_dat_i;
                        6'h01: mtime_hi <= wb_dat_i;

                        // MSIP[h]: 0x10 + 4*h
                        6'h04: msip[0]  <= wb_dat_i;
                        6'h05: msip[1]  <= wb_dat_i;
                        6'h06: msip[2]  <= wb_dat_i;
                        6'h07: msip[3]  <= wb_dat_i;

                        // MTIMECMP[h]: 0x30 + 8*h
                        6'h0C: mtimecmp_lo[0] <= wb_dat_i;
                        6'h0D: mtimecmp_hi[0] <= wb_dat_i;
                        6'h0E: mtimecmp_lo[1] <= wb_dat_i;
                        6'h0F: mtimecmp_hi[1] <= wb_dat_i;
                        6'h10: mtimecmp_lo[2] <= wb_dat_i;
                        6'h11: mtimecmp_hi[2] <= wb_dat_i;
                        6'h12: mtimecmp_lo[3] <= wb_dat_i;
                        6'h13: mtimecmp_hi[3] <= wb_dat_i;

                        default: ;
                    endcase
                end else begin
                    case (wb_adr_i[7:2])
                        // MTIME
                        6'h00: wb_dat_o <= mtime_lo;
                        6'h01: wb_dat_o <= mtime_hi;

                        // MSIP[h]
                        6'h04: wb_dat_o <= msip[0];
                        6'h05: wb_dat_o <= msip[1];
                        6'h06: wb_dat_o <= msip[2];
                        6'h07: wb_dat_o <= msip[3];

                        // MTIMECMP[h]
                        6'h0C: wb_dat_o <= mtimecmp_lo[0];
                        6'h0D: wb_dat_o <= mtimecmp_hi[0];
                        6'h0E: wb_dat_o <= mtimecmp_lo[1];
                        6'h0F: wb_dat_o <= mtimecmp_hi[1];
                        6'h10: wb_dat_o <= mtimecmp_lo[2];
                        6'h11: wb_dat_o <= mtimecmp_hi[2];
                        6'h12: wb_dat_o <= mtimecmp_lo[3];
                        6'h13: wb_dat_o <= mtimecmp_hi[3];

                        default: wb_dat_o <= 32'h0;
                    endcase
                end
            end
        end
    end

endmodule

Notes:
- `wb_adr_i[7:2]` gives a 4‑byte word index inside 0x1000_0600 region.
- MTIMECMP defaults to max so no timer IRQ until firmware programs it.

================================================================================
WB INTERCONNECT + TOP_SOC INTEGRATION
================================================================================

We add CLINT as another Wishbone slave (say s7) decoded at:

- 0x1000_0600 – 0x1000_06FF

### 1. In wb_interconnect.sv

- Add s7 ports.
- Add decode:

  sel_s7 = (m_adr_i[31:8] == 24'h100006);

- Route s7_* in the muxes, same pattern as s0..s6.

### 2. In top_soc.sv

Add WB signals:

wire [31:0] s7_adr_o, s7_dat_o, s7_dat_i;
wire        s7_we_o, s7_cyc_o, s7_stb_o;
wire [3:0]  s7_sel_o;
wire        s7_ack_i, s7_err_i;

Add CLINT outputs:

wire [3:0] clint_msip_irq;
wire [3:0] clint_mtime_irq;

Instantiate CLINT:

clint_wb u_clint (
    .clk       (clk),
    .rst       (rst),
    .wb_adr_i  (s7_adr_o),
    .wb_dat_i  (s7_dat_o),
    .wb_dat_o  (s7_dat_i),
    .wb_we_i   (s7_we_o),
    .wb_sel_i  (s7_sel_o),
    .wb_cyc_i  (s7_cyc_o),
    .wb_stb_i  (s7_stb_o),
    .wb_ack_o  (s7_ack_i),
    .wb_err_o  (s7_err_i),
    .msip_irq  (clint_msip_irq),
    .mtime_irq (clint_mtime_irq)
);

================================================================================
CONNECTING CLINT INTERRUPTS TO HAZARD3 TILES
================================================================================

This depends on your Hazard3 tile interface. Conceptually:

- Each hart has inputs:
  - `msip_i` (machine software interrupt)
  - `mtip_i` (machine timer interrupt)

If your `hazard3_tile` has such inputs, wire:

- For HART0:

  .msip_i(clint_msip_irq[0]),
  .mtip_i(clint_mtime_irq[0]),

- For HART1:

  .msip_i(clint_msip_irq[1]),
  .mtip_i(clint_mtime_irq[1]),

- etc.

If instead you have a generic IRQ input, you can OR msip + mtime:

wire [3:0] hart_irq;
assign hart_irq[0] = clint_msip_irq[0] | clint_mtime_irq[0];
...

and connect `.irq_i(hart_irq[0])` or similar.

The key is: CLINT output -> Hart interrupt input.

================================================================================
FIRMWARE/HAL VIEW (IN SDRAM FIRMWARE)
================================================================================

We expose CLINT registers to software.

In h3_soc.h:

#define H3_CLINT_BASE      0x10000600u
#define H3_CLINT_MTIME_LO  (*(volatile uint32_t *)(H3_CLINT_BASE + 0x00))
#define H3_CLINT_MTIME_HI  (*(volatile uint32_t *)(H3_CLINT_BASE + 0x04))

#define H3_CLINT_MSIP(h)   (*(volatile uint32_t *)(H3_CLINT_BASE + 0x10 + 4u*(h)))

#define H3_CLINT_MTIMECMP_LO(h) (*(volatile uint32_t *)(H3_CLINT_BASE + 0x30 + 8u*(h)))
#define H3_CLINT_MTIMECMP_HI(h) (*(volatile uint32_t *)(H3_CLINT_BASE + 0x34 + 8u*(h)))

Simple helper functions:

static inline void h3_clint_software_irq(uint32_t hartid, int enable)
{
    if (enable)
        H3_CLINT_MSIP(hartid) = 1u;
    else
        H3_CLINT_MSIP(hartid) = 0u;
}

static inline void h3_clint_set_timer(uint32_t hartid, uint64_t tick)
{
    H3_CLINT_MTIMECMP_LO(hartid) = (uint32_t)(tick & 0xFFFFFFFFu);
    H3_CLINT_MTIMECMP_HI(hartid) = (uint32_t)(tick >> 32);
}

================================================================================
USAGE PATTERNS
================================================================================

1) Wake a hart from WFI via software interrupt:

- From HART0:

  h3_clint_software_irq(1, 1);  // set MSIP for hart1

- In HART1 firmware:
  - Enable machine software interrupt (mstatus, mie).
  - WFI will wake when MSIP is set.
  - ISR clears MSIP and continues.

2) Periodic timer on a hart:

- Get current MTIME:

  uint64_t now = ((uint64_t)H3_CLINT_MTIME_HI << 32) | H3_CLINT_MTIME_LO;

- Set MTIMECMP for hart h:

  h3_clint_set_timer(h, now + delta);

- When MTIME >= MTIMECMP[h], timer interrupt asserts.

================================================================================
QUARTUS + FLOW
================================================================================

1. Add clint_wb.sv to the project.
2. Update wb_interconnect.sv with s7 decode at 0x1000_0600.
3. Update top_soc.sv:
   - Add s7_* wires.
   - Instantiate u_clint.
   - Connect interrupts to each hart.
4. Optionally update HAL (`h3_soc.h`) with CLINT register macros and helpers.
5. Rebuild bootrom only if you plan to use CLINT from ROM (not required yet).
6. Recompile project, program .sof to SRAM over JTAG.
7. Power-cycle → still factory demo by default.

================================================================================
RESULT OF PHASE 2C
================================================================================

You now have:

- A multi-hart Hazard3 SoC with:
  - Mailbox (Phase 2B) for explicit start addresses.
  - CLINT-lite (Phase 2C) for:
    - software interrupts (MSIP)
    - per-hart timers (MTIMECMP + MTIME)
- A real path to:
  - Wake harts from WFI.
  - Implement preemption, time slicing, or simple scheduling.
  - Stay fully ephemeral and reproducible.

########END P2C########
================================================================================
PHASE 2D: MULTI-HART HAL + EXAMPLE FIRMWARE (HART0–HART3 WITH ROLES)
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX)
================================================================================

OBJECTIVE
---------
Turn your now multi-hart, mailbox+CLINT-equipped Hazard3 SoC into a **usable
multi-core platform** by:

- Extending the HAL to be **hart-aware** (mhartid, CLINT, mailbox).
- Defining a simple **role model** per hart:
  - HART0: system/init + console + coordinator
  - HART1: periodic timer job
  - HART2: GPIO blinker
  - HART3: SPI/I2C worker (placeholder)
- Providing a single SDRAM firmware `main.c` that:
  - Boots on HART0 (after H3BT+ROM).
  - Starts HART1–HART3 via mailbox.
  - Uses CLINT timers + MSIP for basic coordination.

Everything remains:

- Ephemeral: `.sof` in SRAM only.
- ROM bootloader unchanged (except earlier phases).
- SDRAM firmware replaceable via H3BT.

================================================================================
ASSUMED STATE (FROM PREVIOUS PHASES)
================================================================================

You already have:

- 4 Hazard3 harts (0..3) on AHB M0..M3.
- Boot ROM:
  - HART0 runs bootloader (H3BT → SDRAM @ 0x8000_0000).
  - HART1–3 park in ROM WFI, watching mailbox GO+START_ADDR.
- Wishbone peripherals:
  - SDRAM (s0), UART0, I2C, SPI, GPIO, JTAG-UART.
  - Mailbox @ 0x1000_0400.
  - CLINT-lite @ 0x1000_0600 (MSIP + MTIME + MTIMECMP).
- SDRAM firmware template (Phase 1K) + HAL (Phase 1J).

Phase 2D is **purely firmware/HAL**; RTL is assumed ready from 2A–2C.

================================================================================
STEP 1 — EXTEND HAL FOR MULTI-HART + CLINT + MAILBOX
================================================================================

File: ~/hazard3_fw/app/h3_soc.h

We add:

- mhartid read helper.
- CLINT register macros.
- Mailbox macros.
- Small helper functions.

Only the **new / updated parts** are shown here; keep all old HAL content too.

----- PATCH / REPLACEMENT: h3_soc.h (add near top) ----------------------------

#ifndef H3_SOC_H
#define H3_SOC_H

#include <stdint.h>

/* ============================================================================
 * Core CSRs / helpers
 * ============================================================================
 */
static inline uint32_t h3_read_mhartid(void)
{
    uint32_t v;
    __asm__ volatile ("csrr %0, mhartid" : "=r"(v));
    return v;
}

static inline uint32_t h3_read_mcycle(void)
{
    uint32_t v;
    __asm__ volatile ("csrr %0, mcycle" : "=r"(v));
    return v;
}

/* existing memory map... */
#define H3_SDRAM_BASE       0x80000000u
#define H3_UART0_BASE       0x10000000u
#define H3_I2C0_BASE        0x10000100u
#define H3_SPI0_BASE        0x10000200u
#define H3_GPIO_BASE        0x10000300u
#define H3_MBOX_BASE        0x10000400u
#define H3_JTAG_UART_BASE   0x10000500u
#define H3_CLINT_BASE       0x10000600u

/* ============================================================================
 * CLINT-lite (MSIP + MTIME + MTIMECMP)
 * ============================================================================
 */

#define H3_CLINT_MTIME_LO     (*(volatile uint32_t *)(H3_CLINT_BASE + 0x00))
#define H3_CLINT_MTIME_HI     (*(volatile uint32_t *)(H3_CLINT_BASE + 0x04))

#define H3_CLINT_MSIP(h)      (*(volatile uint32_t *)(H3_CLINT_BASE + 0x10 + 4u*(h)))

#define H3_CLINT_MTIMECMP_LO(h) (*(volatile uint32_t *)(H3_CLINT_BASE + 0x30 + 8u*(h)))
#define H3_CLINT_MTIMECMP_HI(h) (*(volatile uint32_t *)(H3_CLINT_BASE + 0x34 + 8u*(h)))

static inline uint64_t h3_clint_mtime_read(void)
{
    uint32_t hi1, lo, hi2;
    do {
        hi1 = H3_CLINT_MTIME_HI;
        lo  = H3_CLINT_MTIME_LO;
        hi2 = H3_CLINT_MTIME_HI;
    } while (hi1 != hi2);
    return ((uint64_t)hi2 << 32) | lo;
}

static inline void h3_clint_set_msip(uint32_t hartid, int on)
{
    H3_CLINT_MSIP(hartid) = on ? 1u : 0u;
}

static inline void h3_clint_set_mtimecmp(uint32_t hartid, uint64_t t)
{
    H3_CLINT_MTIMECMP_LO(hartid) = (uint32_t)(t & 0xFFFFFFFFu);
    H3_CLINT_MTIMECMP_HI(hartid) = (uint32_t)(t >> 32);
}

/* ============================================================================
 * Mailbox (from Phase 2B)
 * ============================================================================
 */

#define H3_MBOX_STRIDE    0x10u
#define H3_MBOX_CMD_GO    (1u << 0)
#define H3_MBOX_CMD_CLEAR (1u << 1)

static inline volatile uint32_t *H3_MBOX_START(uint32_t h)
{
    return (volatile uint32_t *)(H3_MBOX_BASE + H3_MBOX_STRIDE*h + 0x00u);
}

static inline volatile uint32_t *H3_MBOX_CMD(uint32_t h)
{
    return (volatile uint32_t *)(H3_MBOX_BASE + H3_MBOX_STRIDE*h + 0x04u);
}

/* ============================================================================
 * existing UART/I2C/SPI/GPIO/JTAG UART typedefs and APIs from Phase 1J...
 * ============================================================================
 */

/* existing h3_console_t, h3_status_t, and prototypes remain */

#endif /* H3_SOC_H */

================================================================================
STEP 2 — MULTI-HART EXAMPLE FIRMWARE (ROLES PER HART)
================================================================================

We’ll implement:

- A **single binary** that runs on all harts.
- Behavior depends on `hartid`:

  - HART0:
    - Initializes console, I2C, SPI, GPIO.
    - Prints banner.
    - Starts HART1–3 via mailbox at same entry (0x80000000).
    - Sets up a periodic timer on itself via CLINT.
    - Loops, occasionally poking others with MSIP.

  - HART1:
    - Uses CLINT timer for a periodic message.

  - HART2:
    - Blinks GPIO LED using delays.

  - HART3:
    - Placeholder; prints a heartbeat.

File: ~/hazard3_fw/app/main.c

(Replace your previous main.c with this.)

----- FILE: main.c ------------------------------------------------------------

#include "h3_soc.h"

/* Simple console selection as before: prefer JTAG if activity, else UART. */
static void select_console_startup(void)
{
    h3_console_select(H3_CONSOLE_UART);
    for (volatile uint32_t i = 0; i < 2000000u; i++) {
        char c;
        if (h3_ju_getc_nonblock(&c)) {
            (void)c;
            h3_console_select(H3_CONSOLE_JTAG);
            break;
        }
    }
}

static void hart0_main(void);
static void hart1_main(void);
static void hart2_main(void);
static void hart3_main(void);

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;

    /* All harts: init UART so console is usable if needed. */
    h3_uart_init(SYS_CLK_HZ, 115200u);

    uint32_t hartid = h3_read_mhartid();

    /* Only HART0 chooses console; others just use same selection. */
    if (hartid == 0) {
        select_console_startup();
        h3_con_puts("\nHazard3 Multi-Hart Firmware (Phase 2D)\n");
        h3_con_puts("HART0: system / coordinator\n");
        h3_con_puts("HART1: timer worker\n");
        h3_con_puts("HART2: GPIO blinker\n");
        h3_con_puts("HART3: SPI/I2C placeholder worker\n");
    }

    switch (hartid) {
        case 0: hart0_main(); break;
        case 1: hart1_main(); break;
        case 2: hart2_main(); break;
        case 3: hart3_main(); break;
        default:
            while (1) { __asm__ volatile("wfi"); }
    }
}

/* ------------------------------------------------------------------------- */
/* HART0: coordinator                                                        */
/* ------------------------------------------------------------------------- */

static void start_other_harts(void)
{
    /* Start all other harts at the same entry (0x80000000). */
    for (uint32_t h = 1; h < 4; h++) {
        *H3_MBOX_START(h) = H3_SDRAM_BASE;  /* 0x80000000 */
        *H3_MBOX_CMD(h)   = H3_MBOX_CMD_GO | H3_MBOX_CMD_CLEAR;
    }
}

static void hart0_main(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;

    /* Use console selected in _start (only on hart0). */
    h3_con_puts("HART0: initializing peripherals...\n");

    if (h3_i2c_init(SYS_CLK_HZ, 100u) == H3_OK)
        h3_con_puts("HART0: I2C init OK\n");
    else
        h3_con_puts("HART0: I2C init FAILED\n");

    h3_spi_init(SYS_CLK_HZ, 4u);
    h3_con_puts("HART0: SPI init OK\n");

    /* GPIO LED on bit18 as before. */
    uint32_t led_mask = (1u << 18);
    h3_gpio_set_dir(led_mask, led_mask);

    h3_con_puts("HART0: starting HART1–HART3 via mailbox...\n");
    start_other_harts();

    /* Set up periodic timer for HART0 using CLINT: every ~50M ticks (~1s). */
    uint64_t now = h3_clint_mtime_read();
    uint64_t period = 50000000ull;
    h3_clint_set_mtimecmp(0, now + period);

    while (1) {
        /* Poll timer interrupt in software: check MTIME vs MTIMECMP. */
        uint64_t t_now = h3_clint_mtime_read();
        uint64_t cmp   = ((uint64_t)H3_CLINT_MTIMECMP_HI(0) << 32) |
                         H3_CLINT_MTIMECMP_LO(0);
        if (t_now >= cmp) {
            /* "Timer event": log and toggle LED. */
            h3_con_puts("HART0: timer tick, toggling LED\n");
            static int led_on = 0;
            led_on = !led_on;
            h3_gpio_write(led_mask, led_on ? led_mask : 0u);

            /* Also poke HART1 with software interrupt as a demo. */
            h3_con_puts("HART0: raising MSIP for HART1\n");
            h3_clint_set_msip(1, 1);

            /* Schedule next event. */
            h3_clint_set_mtimecmp(0, t_now + period);
        }

        __asm__ volatile("wfi");
    }
}

/* ------------------------------------------------------------------------- */
/* HART1: timer worker                                                       */
/* ------------------------------------------------------------------------- */

static void hart1_main(void)
{
    /* HART1 will mostly react to MSIP/timer; here we just log periodically. */
    /* For now, we don't configure interrupts; we just spin & check MSIP bit. */

    h3_con_puts("HART1: started\n");

    while (1) {
        /* Simple MSIP polling. */
        if (H3_CLINT_MSIP(1) & 1u) {
            h3_con_puts("HART1: observed MSIP from HART0\n");
            /* Clear MSIP. */
            h3_clint_set_msip(1, 0);
        }

        /* Soft periodic log using mcycle. */
        static uint32_t last = 0;
        uint32_t now = h3_read_mcycle();
        if ((now - last) > 50000000u) {
            h3_con_puts("HART1: periodic heartbeat\n");
            last = now;
        }

        __asm__ volatile("wfi");
    }
}

/* ------------------------------------------------------------------------- */
/* HART2: GPIO blinker                                                       */
/* ------------------------------------------------------------------------- */

static void hart2_main(void)
{
    /* GPIO LED on bit18; HART0 already set direction, but we can ensure it. */
    uint32_t led_mask = (1u << 18);
    h3_gpio_set_dir(led_mask, led_mask);

    h3_con_puts("HART2: GPIO blinker started\n");

    int state = 0;
    while (1) {
        state = !state;
        h3_gpio_write(led_mask, state ? led_mask : 0u);
        h3_con_puts(state ? "HART2: LED ON\n" : "HART2: LED OFF\n");
        h3_delay_cycles(5000000u);
    }
}

/* ------------------------------------------------------------------------- */
/* HART3: SPI/I2C placeholder worker                                         */
/* ------------------------------------------------------------------------- */

static void hart3_main(void)
{
    h3_con_puts("HART3: started (SPI/I2C worker placeholder)\n");

    while (1) {
        /* Example: just report that we're alive occasionally. */
        static uint32_t last = 0;
        uint32_t now = h3_read_mcycle();
        if ((now - last) > 100000000u) {
            h3_con_puts("HART3: alive\n");
            last = now;
        }
        __asm__ volatile("wfi");
    }
}

================================================================================
STEP 3 — BUILD & LOAD (NO RTL CHANGES REQUIRED IN THIS PHASE)
================================================================================

1. Ensure h3_soc.h contains:
   - mhartid helpers
   - CLINT + mailbox macros (from Step 1)
   - Existing HAL content from Phase 1J.

2. Ensure h3_soc.c is unchanged from Phase 1J (UART/I2C/SPI/GPIO/JTAG-UART).

3. Ensure linker_app.ld and Makefile from Phase 1K are still present.

4. Build firmware:

   cd ~/hazard3_fw/app
   make

   - Produces firmware.elf, firmware.bin, checksum.

5. Load via H3BT:
   - HART0 bootloader in ROM (Phase 1I) is unchanged.
   - Send:
     - "H3BT"
     - addr = 0x80000000
     - length = firmware.bin size
     - checksum = sum of bytes
     - payload = firmware.bin

6. Boot sequence:
   - HART0 in ROM:
     - Receives firmware, writes to SDRAM.
     - Jumps to 0x80000000 (this firmware).
   - HART0 in SDRAM:
     - Initializes peripherals.
     - Starts HART1–3 via mailbox.
     - Sets its own timer via CLINT.
   - HART1–3 in ROM:
     - See GO in mailbox.
     - Jump into SDRAM `_start`.
     - Each runs its own hartX_main().

7. Observations:
   - Console (UART0 or JTAG-UART) shows:
     - Multi-hart banner.
     - HARTx logs (start, heartbeat, LED toggles).
   - LED bit18 blinks, influenced by both HART0 (timer tick) and HART2 (blinker).

================================================================================
WHAT PHASE 2D GIVES YOU
================================================================================

- A fully functioning **multi-hart Hazard3 environment**:
  - Hardware: 4 harts, mailbox, CLINT, SDRAM, peripherals.
  - Boot: ROM bootloader + H3BT into SDRAM.
  - Software: HAL with multi-hart awareness, example firmware with per-hart roles.
- All under your constraints:
  - Ephemeral configuration.
  - Open, reproducible, non-destructive.

########END P2D#######
================================================================================
PHASE 2E: PWM PERIPHERAL (WISHBONE) + HAL + EXAMPLE USE
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX)
================================================================================

OBJECTIVE
---------
Complete the MCU feature set by adding **PWM** to your 4‑hart Hazard3 SoC:

- Wishbone PWM peripheral with multiple channels.
- Memory-mapped at a clean address.
- Simple semantics: per-channel period + duty.
- HAL support + example SDRAM firmware usage.

Still:

- Only `.sof` to FPGA SRAM, no flash.
- Boot ROM + H3BT + SDRAM firmware unchanged in structure.
- Fully open-source, reproducible.

We’ll implement:

1. `pwm_wb.sv` — Wishbone PWM with 4 channels.
2. Address map + integration in `wb_interconnect` and `top_soc.sv`.
3. HAL extensions in `h3_soc.h` / `h3_soc.c`.
4. Example usage in `main.c`.

================================================================================
STEP 1 — PWM REGISTER MAP
================================================================================

Base address (new region): **0x1000_0700**

We’ll define 4 PWM channels (0..3). Each channel has:

- CTRL   (enable, invert, etc.)
- PERIOD (ticks per cycle)
- DUTY   (ticks high)

Register layout (word-aligned, 32-bit):

Base + 0x00: GLOBAL_CTRL (RW)
- bit0: ENABLE (global run)
- bit1: RESET (self-clearing reset of counters)

Channel n (n = 0..3, stride = 0x10):

Base + 0x10 + 0x10*n: CHn_CTRL (RW)
- bit0: ENABLE (channel active)
- bit1: INVERT (output inverted)

Base + 0x14 + 0x10*n: CHn_PERIOD (RW)
- 32-bit period in clock ticks (must be > 0)

Base + 0x18 + 0x10*n: CHn_DUTY (RW)
- 32-bit duty in clock ticks (<= PERIOD)

Base + 0x1C + 0x10*n: reserved / unused

Outputs:

- `pwm_out[3:0]` → 4 PWM channels exposed to pins (e.g. Arduino pins).

================================================================================
STEP 2 — PWM WISHBONE SLAVE RTL
================================================================================

File: ~/fpga/h3_phase1_sc/rtl/soc/pwm_wb.sv

module pwm_wb
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone slave
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output reg         wb_ack_o,
    output wire        wb_err_o,

    // PWM outputs
    output wire [3:0]  pwm_out
);

    assign wb_err_o = 1'b0;

    // Global control
    reg [31:0] global_ctrl;

    // Per-channel registers
    reg [31:0] ch_ctrl   [0:3];
    reg [31:0] ch_period [0:3];
    reg [31:0] ch_duty   [0:3];
    reg [31:0] ch_count  [0:3];

    integer i;

    // Decode
    wire [7:0] byte_off = wb_adr_i[7:0];   // within 0x1000_0700 region
    wire [3:0] word_off = byte_off[5:2];   // 4-byte words

    // Global control bits
    wire global_enable = global_ctrl[0];
    wire global_reset  = global_ctrl[1];

    // PWM logic
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            global_ctrl <= 32'h0;
            for (i = 0; i < 4; i = i + 1) begin
                ch_ctrl[i]   <= 32'h0;
                ch_period[i] <= 32'd1000;  // default period
                ch_duty[i]   <= 32'd0;
                ch_count[i]  <= 32'd0;
            end
        end else begin
            // Global reset of counters if requested
            if (global_reset) begin
                for (i = 0; i < 4; i = i + 1)
                    ch_count[i] <= 32'd0;
                // self-clear RESET bit
                global_ctrl[1] <= 1'b0;
            end

            // PWM counters
            if (global_enable) begin
                for (i = 0; i < 4; i = i + 1) begin
                    if (ch_ctrl[i][0]) begin // channel enable
                        if (ch_count[i] >= ch_period[i]) begin
                            ch_count[i] <= 32'd0;
                        end else begin
                            ch_count[i] <= ch_count[i] + 32'd1;
                        end
                    end else begin
                        ch_count[i] <= 32'd0;
                    end
                end
            end else begin
                for (i = 0; i < 4; i = i + 1)
                    ch_count[i] <= 32'd0;
            end
        end
    end

    // PWM output generation
    genvar ch;
    generate
        for (ch = 0; ch < 4; ch = ch + 1) begin : gen_pwm
            wire active = (ch_ctrl[ch][0] && global_enable);
            wire invert = ch_ctrl[ch][1];
            wire high   = (ch_count[ch] < ch_duty[ch]);
            assign pwm_out[ch] = active ? (invert ? ~high : high) : 1'b0;
        end
    endgenerate

    // Wishbone access
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            wb_ack_o <= 1'b0;
            wb_dat_o <= 32'h0;
        end else begin
            wb_ack_o <= 1'b0;

            if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin
                wb_ack_o <= 1'b1;

                if (wb_we_i) begin
                    case (word_off)
                        4'h0: global_ctrl <= wb_dat_i;

                        // CH0
                        4'h4: ch_ctrl[0]   <= wb_dat_i;
                        4'h5: ch_period[0] <= wb_dat_i;
                        4'h6: ch_duty[0]   <= wb_dat_i;

                        // CH1
                        4'h8: ch_ctrl[1]   <= wb_dat_i;
                        4'h9: ch_period[1] <= wb_dat_i;
                        4'hA: ch_duty[1]   <= wb_dat_i;

                        // CH2
                        4'hC: ch_ctrl[2]   <= wb_dat_i;
                        4'hD: ch_period[2] <= wb_dat_i;
                        4'hE: ch_duty[2]   <= wb_dat_i;

                        // CH3
                        4'h10: ch_ctrl[3]   <= wb_dat_i;
                        4'h11: ch_period[3] <= wb_dat_i;
                        4'h12: ch_duty[3]   <= wb_dat_i;

                        default: ;
                    endcase
                end else begin
                    case (word_off)
                        4'h0: wb_dat_o <= global_ctrl;

                        // CH0
                        4'h4:  wb_dat_o <= ch_ctrl[0];
                        4'h5:  wb_dat_o <= ch_period[0];
                        4'h6:  wb_dat_o <= ch_duty[0];

                        // CH1
                        4'h8:  wb_dat_o <= ch_ctrl[1];
                        4'h9:  wb_dat_o <= ch_period[1];
                        4'hA:  wb_dat_o <= ch_duty[1];

                        // CH2
                        4'hC:  wb_dat_o <= ch_ctrl[2];
                        4'hD:  wb_dat_o <= ch_period[2];
                        4'hE:  wb_dat_o <= ch_duty[2];

                        // CH3
                        4'h10: wb_dat_o <= ch_ctrl[3];
                        4'h11: wb_dat_o <= ch_period[3];
                        4'h12: wb_dat_o <= ch_duty[3];

                        default: wb_dat_o <= 32'h0;
                    endcase
                end
            end
        end
    end

endmodule

================================================================================
STEP 3 — INTEGRATE PWM INTO WB + TOP_SOC
================================================================================

### 3.1 — WB interconnect decode

Add a new slave slot (e.g. s8) for PWM at **0x1000_0700**.

In wb_interconnect.sv:

- Add s8_* ports like others.
- Add decode:

  sel_s8 = (m_adr_i[31:8] == 24'h100007);

- Route s8_* in master-to-slave and slave-to-master muxes.

(You’ve done this pattern already for s6/s7 in earlier phases.)

### 3.2 — top_soc.sv wiring

Add WB signals:

wire [31:0] s8_adr_o, s8_dat_o, s8_dat_i;
wire        s8_we_o, s8_cyc_o, s8_stb_o;
wire [3:0]  s8_sel_o;
wire        s8_ack_i, s8_err_i;

Add PWM outputs:

wire [3:0] pwm_ch;

// Instantiate PWM
pwm_wb u_pwm (
    .clk       (clk),
    .rst       (rst),
    .wb_adr_i  (s8_adr_o),
    .wb_dat_i  (s8_dat_o),
    .wb_dat_o  (s8_dat_i),
    .wb_we_i   (s8_we_o),
    .wb_sel_i  (s8_sel_o),
    .wb_cyc_i  (s8_cyc_o),
    .wb_stb_i  (s8_stb_o),
    .wb_ack_o  (s8_ack_i),
    .wb_err_o  (s8_err_i),
    .pwm_out   (pwm_ch)
);

Now map `pwm_ch[3:0]` to pins:

- For example:

  - pwm_ch[0] → Arduino D9
  - pwm_ch[1] → Arduino D10
  - pwm_ch[2] → Arduino D5
  - pwm_ch[3] → Arduino D6

You choose the mapping in the .qsf pin assignments.

================================================================================
STEP 4 — HAL EXTENSIONS FOR PWM
================================================================================

Update: ~/hazard3_fw/app/h3_soc.h

Add after other peripheral sections:

/* ============================================================================
 * PWM (4-channel)
 * Base: 0x1000_0700
 * ============================================================================
 */

#define H3_PWM_BASE          0x10000700u

#define H3_PWM_GLOBAL_CTRL   (*(volatile uint32_t *)(H3_PWM_BASE + 0x00))

#define H3_PWM_CH_CTRL(n)    (*(volatile uint32_t *)(H3_PWM_BASE + 0x10 + 0x10u*(n)))
#define H3_PWM_CH_PERIOD(n)  (*(volatile uint32_t *)(H3_PWM_BASE + 0x14 + 0x10u*(n)))
#define H3_PWM_CH_DUTY(n)    (*(volatile uint32_t *)(H3_PWM_BASE + 0x18 + 0x10u*(n)))

/* Global CTRL bits */
#define H3_PWM_GLOBAL_ENABLE (1u << 0)
#define H3_PWM_GLOBAL_RESET  (1u << 1)

/* Channel CTRL bits */
#define H3_PWM_CH_ENABLE     (1u << 0)
#define H3_PWM_CH_INVERT     (1u << 1)

/* HAL API for PWM */
void     h3_pwm_global_enable(int enable);
void     h3_pwm_global_reset(void);
void     h3_pwm_config(uint32_t ch, uint32_t period, uint32_t duty, int invert);
void     h3_pwm_enable(uint32_t ch, int enable);

Now implement in ~/hazard3_fw/app/h3_soc.c:

Add near the bottom:

void h3_pwm_global_enable(int enable)
{
    if (enable)
        H3_PWM_GLOBAL_CTRL |= H3_PWM_GLOBAL_ENABLE;
    else
        H3_PWM_GLOBAL_CTRL &= ~H3_PWM_GLOBAL_ENABLE;
}

void h3_pwm_global_reset(void)
{
    H3_PWM_GLOBAL_CTRL |= H3_PWM_GLOBAL_RESET;
}

void h3_pwm_config(uint32_t ch, uint32_t period, uint32_t duty, int invert)
{
    if (ch >= 4) return;
    if (period == 0) period = 1;

    H3_PWM_CH_PERIOD(ch) = period;
    if (duty > period) duty = period;
    H3_PWM_CH_DUTY(ch) = duty;

    uint32_t ctrl = 0;
    if (invert) ctrl |= H3_PWM_CH_INVERT;
    H3_PWM_CH_CTRL(ch) = ctrl;
}

void h3_pwm_enable(uint32_t ch, int enable)
{
    if (ch >= 4) return;
    uint32_t ctrl = H3_PWM_CH_CTRL(ch);
    if (enable)
        ctrl |= H3_PWM_CH_ENABLE;
    else
        ctrl &= ~H3_PWM_CH_ENABLE;
    H3_PWM_CH_CTRL(ch) = ctrl;
}

================================================================================
STEP 5 — EXAMPLE USAGE IN SDRAM FIRMWARE
================================================================================

In your multi-hart firmware (main.c from Phase 2D), you can now add PWM usage.

For a quick test, let’s let **HART2** drive PWM instead of doing manual GPIO blink.

Replace hart2_main() in main.c with:

static void hart2_main(void)
{
    h3_con_puts("HART2: PWM blinker started\n");

    /* Configure PWM channel 0:
     *  - period = 50000 ticks (~1ms at 50 MHz → 1 kHz)
     *  - start with 10% duty
     */
    uint32_t period = 50000u;
    h3_pwm_config(0, period, period / 10u, 0);

    /* Enable global + channel. */
    h3_pwm_global_enable(1);
    h3_pwm_enable(0, 1);

    /* Slowly sweep duty cycle between 10% and 90%. */
    uint32_t duty = period / 10u;
    int step = (int)(period / 50u); // 2% steps

    while (1) {
        h3_pwm_config(0, period, duty, 0);

        h3_con_puts("HART2: PWM duty = ");
        // crude decimal print just for visibility
        uint32_t pct = (duty * 100u) / period;
        char buf[4];
        buf[0] = '0' + (pct / 10) % 10;
        buf[1] = '0' + (pct % 10);
        buf[2] = '%';
        buf[3] = '\0';
        h3_con_puts(buf);
        h3_con_puts("\n");

        h3_delay_cycles(5000000u);

        duty += step;
        if (duty >= (period * 9u) / 10u || duty <= (period * 1u) / 10u)
            step = -step;
    }
}

Then rebuild:

cd ~/hazard3_fw/app
make

Load via H3BT as usual.

PWM channel 0 (pwm_ch[0]) should now show a varying duty cycle at ~1 kHz on the mapped pin (e.g. Arduino D9).

================================================================================
STEP 6 — QUARTUS: FILES, BUILD, PROGRAM
================================================================================

1. Add `pwm_wb.sv` to the Quartus project.
2. Update `wb_interconnect.sv` with s8 decode @ 0x1000_0700.
3. Update `top_soc.sv`:
   - Add s8_* signals.
   - Instantiate u_pwm.
   - Expose `pwm_ch[3:0]` to top-level ports or connect them to existing GPIO pins.
4. Assign PWM outputs to physical pins in .qsf (e.g. Arduino header).
5. Recompile.
6. Program `.sof` over JTAG (SRAM-only).
7. Load firmware via H3BT and observe PWM behavior.

================================================================================
WHAT PHASE 2E GIVES YOU
================================================================================

You now have:

- A **4-core Hazard3 MCU-class SoC** with:
  - UART0 + JTAG-UART
  - I2C
  - SPI
  - GPIO
  - **PWM (4 channels)**
  - Mailbox (hart start)
  - CLINT-lite (software interrupts + timers)
- A HAL that cleanly abstracts everything.
- Multicore firmware that can assign real tasks to different harts, including PWM control.

########END P2E########
