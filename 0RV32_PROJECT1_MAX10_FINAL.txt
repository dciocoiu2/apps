============================================================
PHASE 1 — FRESH START: TOOLCHAIN, REPO, AND ARDUINO-HEADER FOCUS
============================================================

Goal:
- Start from zero with a clean, reproducible environment.
- Lock in: DE10-Lite (MAX 10 10M50DAF484C7G) + Arduino headers as the *primary* SoC I/O interface.
- Install and verify:
  - Linux environment (VM or bare metal)
  - Quartus Lite for MAX 10
  - RISC-V GCC toolchain
  - Git + basic directory structure for the SoC project
- Make an explicit design rule: **all user-facing digital I/O uses the DE10-Lite Arduino headers**, not random GPIO pins or on-board LEDs/switches.

Reference:
- DE10-Lite has a MAX 10 10M50 and dedicated Arduino-compatible headers for GPIO/ADC[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://faculty-web.msoe.edu/johnsontimoj/Common/FILES/de10-lite.pdf?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054&citationId=1&citationId=2 "MSOE Faculty Web").
- We will treat those Arduino headers as the “MCU pinout” for the SoC.

------------------------------------------------------------
0. High-level design constraints (locked in now)
------------------------------------------------------------

These are invariants for ALL later phases:

- Board:
  - Terasic DE10-Lite with MAX 10 10M50DAF484C7G.

- Configuration model:
  - FPGA is configured **only into SRAM** via `.sof` over JTAG.
  - We do **not** program on-board configuration flash.
  - On power-cycle, the SoC disappears; we re-load the bitstream when needed.

- SoC I/O model:
  - All user-facing digital I/O (GPIO, SPI, I2C, UART, PWM, external interrupts) are mapped to the **Arduino-style headers** on the DE10-Lite[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://faculty-web.msoe.edu/johnsontimoj/Common/FILES/de10-lite.pdf?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054&citationId=1 "MSOE Faculty Web").
  - On-board LEDs, switches, keys may be exposed as *extras*, but the canonical/user pinout is Arduino headers.

- Philosophy:
  - Open-source IP only (Hazard3, OpenCores, or small custom RTL).
  - Industrial-capable: IRQ, DMA, advanced PWM/GPIO/I2C/SPI features, but always auditable and deterministic.
  - Arduino-like firmware UX via a C HAL.

These constraints will drive Phase 2 (memory + pin map), Phase 3 (SoC fabric), and especially Phase 8 (pin assignment to Arduino headers).

------------------------------------------------------------
1. Base OS environment
------------------------------------------------------------

Use a modern Linux environment (VM or bare metal). For example:

- Ubuntu 22.04 LTS (recommended)
- At least:
  - 4 GB RAM (8 GB+ nicer)
  - 30+ GB disk

Ensure the following packages are installed:

- Build essentials:
  - sudo apt update
  - sudo apt install -y build-essential git cmake python3 python3-pip

- Utilities:
  - sudo apt install -y curl unzip hexdump

------------------------------------------------------------
2. Quartus Lite for MAX 10 (DE10-Lite)
------------------------------------------------------------

1) Download Quartus Prime Lite Edition that supports MAX 10 devices.
   - Install Quartus Lite + MAX 10 device support following Intel’s installer.

2) After installation, ensure `quartus_sh` is in PATH, e.g.:

   - echo 'export PATH="/opt/intelFPGA_lite/23.1/quartus/bin:$PATH"' >> ~/.bashrc
   - source ~/.bashrc

3) Verify:

   - quartus_sh --version

4) Install USB-Blaster udev rules (if needed):

   - Create `/etc/udev/rules.d/51-usbblaster.rules` with Intel’s recommended rules.
   - Reload udev and replug the DE10-Lite.

5) Plug in DE10-Lite, run:

   - jtagconfig

   You should see the MAX 10 device detected.

------------------------------------------------------------
3. RISC-V toolchain (RV32IM bare-metal)
------------------------------------------------------------

We’ll use a standard GCC-based RISC-V bare-metal toolchain:

1) Install prebuilt toolchain (if available for your distro), or build from source. For example:

   - sudo apt install -y gcc-riscv64-unknown-elf

   If your distro uses a different triplet, adapt accordingly.

2) Verify:

   - riscv64-unknown-elf-gcc --version

3) For this project we’ll target RV32IM / ilp32. We’ll use flags like:

   - -march=rv32im -mabi=ilp32

We’ll standardize on the prefix:

- RISCV_PREFIX = riscv64-unknown-elf

but we’ll compile 32-bit code with `-march`/`-mabi`.

------------------------------------------------------------
4. Project root and repository layout
------------------------------------------------------------

Create a root directory for the entire SoC project:

- mkdir -p ~/h3_quad_de10lite
- cd ~/h3_quad_de10lite
- git init

We’ll use this top-level layout:

~/h3_quad_de10lite/
  soc/
    rtl/            # Verilog RTL for SoC + IP integration
    quartus/        # Quartus project tcl, qsf, sdc
    sw/
      boot_rom/     # Bootloader (UART-based, Instr SRAM loader)
      arduino_api/  # Arduino-like HAL library
      apps/         # User firmware examples (Phase 7+)
    docs/
      pinmap/       # Pin mapping docs, including Arduino headers on DE10-Lite
      memmap/       # Memory and register maps
      build/        # Build + usage documentation

Initialize basic directories:

- mkdir -p soc/rtl soc/quartus soc/sw/boot_rom soc/sw/arduino_api soc/sw/apps docs/pinmap docs/memmap docs/build

Add a minimal README capturing the key constraints:

File: ~/h3_quad_de10lite/README.md

- echo 'H3 Quad-Core SoC on DE10-Lite (Arduino Headers as Primary I/O)' > README.md
- echo '' >> README.md
- echo '- Board: DE10-Lite (MAX 10 10M50DAF484C7G)' >> README.md
- echo '- FPGA config: SRAM-only (.sof via JTAG), no flash' >> README.md
- echo '- CPU: Quad-core Hazard3 RV32IM' >> README.md
- echo '- Buses: AHB backbone, APB + Wishbone peripherals' >> README.md
- echo '- Peripherals: UART16550, SPI, I2C, GPIO, PWM, DMA, IRQ ctrl (OpenCores/custom)' >> README.md
- echo '- All user I/O via DE10-Lite Arduino headers' >> README.md

Commit:

- git add .
- git commit -m "Phase 1: initial repo layout and toolchain assumptions"

------------------------------------------------------------
5. Arduino headers on DE10-Lite (design rule)
------------------------------------------------------------

DE10-Lite provides a set of Arduino headers for GPIO/ADC interfacing[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://faculty-web.msoe.edu/johnsontimoj/Common/FILES/de10-lite.pdf?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054&citationId=1&citationId=2 "MSOE Faculty Web"). We will:

- Treat Arduino header pins as the canonical “MCU pins” of our SoC.
- Map:
  - GPIO, PWM outputs, SPI, I2C, UART pins to specific Arduino I/O pins.
- Document this thoroughly in:
  - docs/pinmap/arduino_de10lite_pinout.md

For now, just create the file and a placeholder heading; detailed mapping will be done in Phase 2/Phase 8 when we pin down exact FPGA pins:

- touch docs/pinmap/arduino_de10lite_pinout.md
- echo '# DE10-Lite Arduino Header Pin Mapping for H3 SoC' > docs/pinmap/arduino_de10lite_pinout.md

(We will fill this with a complete mapping once the SoC’s signal set is fully defined.)

------------------------------------------------------------
6. Sanity checks
------------------------------------------------------------

At the end of Phase 1, verify:

- `quartus_sh --version` works.
- `jtagconfig` detects the MAX 10 on DE10-Lite.
- `riscv64-unknown-elf-gcc --version` works.
- The directory structure under `~/h3_quad_de10lite/` matches what we defined.
- README.md exists and reflects:
  - SRAM-only configuration rule.
  - Arduino headers as primary I/O.

============================================================
END OF PHASE 1
============================================================
============================================================
PHASE 2 — MEMORY MAP, INTERRUPT MAP, AND ARDUINO-HEADER I/O MODEL
============================================================

Goal:
- Define a **complete, fixed memory map** for the SoC (no placeholders).
- Define the **interrupt architecture** (sources, controller, how they reach Hazard3 cores).
- Define a **logical Arduino header I/O model** for:
  - GPIO (with interrupts + debounce)
  - UART
  - SPI
  - I2C
  - PWM
  - Fault inputs / external interrupt lines
- All of this will be implemented concretely in later RTL phases and bound to **actual DE10-Lite Arduino pins** in Phase 8.

We will **not guess** the exact FPGA pin names in this phase; instead, we define the logical MCU pinout (D0/D1, SPI pins, etc.) and ensure the SoC exposes signals that can be cleanly mapped to those Arduino pads.

------------------------------------------------------------
0. Top-level SoC model (conceptual)
------------------------------------------------------------

SoC: “H3-Quad MCU”

- CPU:
  - 4 × Hazard3 RV32IM cores
- Buses:
  - AHB-Lite backbone (Hazard3 data + instruction masters, DMA master)
  - AHB→APB bridge (for low-speed peripheral CSRs)
  - APB→Wishbone bridge (to talk to OpenCores Wishbone peripherals)
- Memories:
  - Boot ROM (AHB, 16 KB, @0x0000_0000)
  - Instruction SRAM (AHB, 64 KB, @0x0001_0000)
  - Data SRAM (AHB, 64 KB, @0x1000_0000)
- System services:
  - IRQ controller (APB-mapped, routes peripheral IRQs to cores)
  - DMA controller (AHB master, APB/WB-configured)
- Peripherals (APB→WB):
  - UART16550
  - SPI master
  - I2C master
  - GPIO (with interrupts)
  - PWM (multi-channel, with advanced features via RTL)
- I/O:
  - All main I/O signals exported as “MCU pins” intended to be driven to DE10-Lite Arduino headers.

------------------------------------------------------------
1. Global address map (final, not a placeholder)
------------------------------------------------------------

We define the **static 32-bit address space** as follows:

1) **Boot ROM** (AHB, execute-only):
   - Base:  0x0000_0000
   - Size:  16 KB
   - Range: 0x0000_0000 – 0x0000_3FFF
   - Contents: UART bootloader code (Phase 5), RISC-V RV32IM.

2) **Instruction SRAM** (AHB, executable):
   - Base:  0x0001_0000
   - Size:  64 KB
   - Range: 0x0001_0000 – 0x0001_FFFF
   - Contents: user firmware loaded over UART (Phase 5/9).

3) **Data SRAM** (AHB, read/write):
   - Base:  0x1000_0000
   - Size:  64 KB
   - Range: 0x1000_0000 – 0x1000_FFFF
   - Usage: runtime stack, global/static data, heap (if any).

4) **APB / peripheral region** (AHB→APB bridge window):
   - Base:  0x4000_0000
   - Size:  512 KB block reserved (more than we need for now).
   - Actual used sub-ranges (each 4 KB aligned):

   - 0x4000_0000 – 0x4000_0FFF : UART16550
   - 0x4000_1000 – 0x4000_1FFF : GPIO
   - 0x4000_2000 – 0x4000_2FFF : SPI master
   - 0x4000_3000 – 0x4000_3FFF : I2C master
   - 0x4000_4000 – 0x4000_4FFF : PWM
   - 0x4000_5000 – 0x4000_5FFF : IRQ controller
   - 0x4000_6000 – 0x4000_6FFF : DMA controller

   The remaining space `0x4000_7000`–`0x4007_FFFF` is reserved for future peripherals (timers, extra UARTs, etc.).

5) **Reserved regions**:
   - `0x2000_0000` – `0x3FFF_FFFF`: reserved for future external memories / mapping.
   - `0x8000_0000` and above: not used in this SoC; reserved for future on-chip expansion or external bus mapping.

This map will be honored **exactly** in RTL and software.

------------------------------------------------------------
2. Interrupt architecture
------------------------------------------------------------

We want:

- Interrupt-driven UART, GPIO, DMA, etc.
- A central **IRQ controller** that collects peripheral interrupts and feeds them to Hazard3 cores.
- A simple, deterministic scheme suitable for bare-metal firmware.

We define:

1) **Interrupt sources (lines)**

- IRQ0: UART16550
- IRQ1: GPIO
- IRQ2: SPI master
- IRQ3: I2C master
- IRQ4: PWM
- IRQ5: DMA controller
- IRQ6–IRQ15: reserved for future (timers, extra UARTs, etc.)

2) **IRQ controller (h3_irq_ctrl)**

- APB-mapped at `0x4000_5000`.
- Exposes:
  - Pending register
  - Enable/mask register
  - Per-core routing/masking (simplified)
- Implements up to 16 interrupt lines internally.
- Aggregates them into:

  - For simplicity, a single external interrupt line per core:
    - CORE0_IRQ_EXT
    - CORE1_IRQ_EXT
    - CORE2_IRQ_EXT
    - CORE3_IRQ_EXT

- Hazard3 cores will be configured so that this external interrupt maps to the standard machine/external interrupt cause (through CSRs).

3) **Interrupt priority / routing**

- Phase 3/4 will implement:
  - A simple fixed priority scheme (IRQ0 highest, IRQ15 lowest) inside h3_irq_ctrl.
  - A register that reports the active IRQ ID.
  - Per-core enable bits (so some cores can be “quiet”).

Software model (Phase 6):
- `irq_init()` configures the controller.
- `irq_enable_line(line)` enables a specific IRQ line globally.
- `irq_route_to_core(line, core_id)` decides which core receives that line.
- The HAL will set up an interrupt handler table in RAM and a single trap handler.

------------------------------------------------------------
3. DMA architecture
------------------------------------------------------------

We want:

- DMA that can move data between:
  - Memory ↔ peripherals (e.g., UART RX/TX FIFO, SPI FIFO)
  - Memory ↔ memory (Instr/Data SRAM)

We define:

1) **DMA controller (DMA0)**

- APB-mapped CSRs at `0x4000_6000`.
- AHB master port to access Boot ROM, Instruction SRAM, Data SRAM, and the APB/WB peripheral window (through bus hierarchy).
- Internally:
  - One or more DMA channels (we’ll start with 1 channel for clarity).
  - Control registers:
    - SRC_ADDR, DST_ADDR, LEN, CTRL, STATUS, IRQ_ENABLE
  - Supports:
    - Incrementing addresses for memory.
    - Optional fixed destination/source for peripheral FIFOs.

2) **DMA IRQ**

- DMA0 uses IRQ5 to signal:
  - Completion.
  - Error/abort.

3) **Usage expectations**

- Early boot (Boot ROM): we will **not** depend on DMA; the bootloader will stay simple and polling-based.
- Application firmware (Phase 7+): can use DMA for:
  - High throughput UART RX/TX.
  - SPI bursts.
  - Buffered logging or streaming.

------------------------------------------------------------
4. Peripherals: register map granularity (non-placeholder)
------------------------------------------------------------

We fix the **base addresses** here and commit to them. Exact internal register bits will follow from OpenCores specs + our own wrappers in Phase 4 and HAL in Phase 6.

1) UART16550 @ 0x4000_0000

- Typical 16550 register file in 8-bit lanes, but we will access via 32-bit words at:
  - 0x4000_0000: RBR/THR/DLL
  - 0x4000_0004: IER/DLM
  - 0x4000_0008: IIR/FCR
  - 0x4000_000C: LCR
  - 0x4000_0010: MCR
  - 0x4000_0014: LSR
  - 0x4000_0018: MSR
  - 0x4000_001C: SCR
- Interrupt output:
  - `uart_irq` → IRQ0 in h3_irq_ctrl.

2) GPIO @ 0x4000_1000

- Core registers (examples, exact names depend on OpenCores GPIO):
  - 0x4000_1000: DATA_OUT
  - 0x4000_1004: DATA_DIR
  - 0x4000_1008: DATA_IN
  - 0x4000_100C: IRQ_MASK
  - 0x4000_1010: IRQ_TYPE (edge/level, rising/falling)
  - 0x4000_1014: IRQ_STATUS
  - 0x4000_1018: (optional) DEBOUNCE_CFG
- Interrupt output:
  - `gpio_irq` → IRQ1.

3) SPI master @ 0x4000_2000

- Registers (typical OpenCores SPI):
  - 0x4000_2000: RX/TX data
  - 0x4000_2004: Control (CPOL, CPHA, bits per word, enable, interrupt, CS mode)
  - 0x4000_2008: Status (busy, RX ready, TX empty, IRQ flags)
  - 0x4000_200C: Divider (SCLK rate)
  - 0x4000_2010: Chip select / manual CS override
- Interrupt output:
  - `spi_irq` → IRQ2.

4) I2C master @ 0x4000_3000

- OpenCores I2C standard map:
  - 0x4000_3000: PRER_LO (prescaler low)
  - 0x4000_3004: PRER_HI
  - 0x4000_3008: CTR (enable, interrupt enable)
  - 0x4000_300C: TXR/RXR
  - 0x4000_3010: CR/SR (start/stop, read/write, ACK/NACK, arbitration lost, TIP, etc.)
- Interrupt output:
  - `i2c_irq` → IRQ3.

5) PWM @ 0x4000_4000

- We define a richer register set:
  - Per channel (0..3):
    - PERIOD
    - DUTY
    - PHASE
    - DEADTIME
    - CTRL (enable, polarity, fault behavior)
  - Global:
    - FAULT_STATUS
    - FAULT_MASK
- Interrupt output:
  - `pwm_irq` → IRQ4.
- Fault inputs:
  - External signals from Arduino header (e.g., emergency stop input).

6) IRQ controller @ 0x4000_5000

- Registers:
  - PENDING
  - ENABLE
  - ROUTE_CORE0
  - ROUTE_CORE1
  - ROUTE_CORE2
  - ROUTE_CORE3
  - CLAIM/COMPLETE style or simple “active IRQ ID” field.

7) DMA controller @ 0x4000_6000

- Registers:
  - CH0_SRC_ADDR
  - CH0_DST_ADDR
  - CH0_LEN
  - CH0_CTRL (start, direction, increment flags)
  - CH0_STATUS (busy, error)
  - CH0_IRQ_ENABLE

------------------------------------------------------------
5. Logical Arduino I/O model (non-skeletal, but board-pin-agnostic)
------------------------------------------------------------

We must avoid inventing fake DE10-Lite pin numbers; instead, we define the **_irq` → IRQ0 in h3_irq_ctrl.

2) GPIO @ 0x4000_1000

- Core registers (examples, exact names depend on OpenCores GPIO):
  - 0x4000_1000: DATA_OUT
  - 0x4000_1004: DATA_DIR
  - 0x4000_1008: DATA_IN
  - 0x4000_100C: IRQ_MASK
  - 0x4000_1010: IRQ_TYPE (edge/level, rising/falling)
  - 0x4000_1014: IRQ_STATUS
  - 0x4000_1018: (optional) DEBOUNCE_CFG
- Interrupt output:
  - `gpio_irq` → IRQ1.

3) SPI master @ 0x4000_2000

- Registers (typical OpenCores SPI):
  - 0x4000_2000: RX/TX data
  - 0x4000_2004: Control (CPOL, CPHA, bits per word, enable, interrupt, CS mode)
  - 0x4000_2008: Status (busy, RX ready, TX empty, IRQ flags)
  - 0x4000_200C: Divider (SCLK rate)
  - 0x4000_2010: Chip select / manual CS override
- Interrupt output:
  - `spi_irq` → IRQ2.

4) I2C master @ 0x4000_3000

- OpenCores I2C standard map:
  - 0x4000_3000: PRER_LO (prescaler low)
  - 0x4000_3004: PRER_HI
  - 0x4000_3008: CTR (enable, interrupt enable)
  - 0x4000_300C: TXR/RXR
  - 0x4000_3010: CR/SR (start/stop, read/write, ACK/NACK, arbitration lost, TIP, etc.)
- Interrupt output:
  - `i2c_irq` → IRQ3.

5) PWM @ 0x4000_4000

- We define a richer register set:
  - Per channel (0..3):
    - PERIOD
    - DUTY
    - PHASE
    - DEADTIME
    - CTRL (enable, polarity, fault behavior)
  - Global:
    - FAULT_STATUS
    - FAULT_MASK
- Interrupt output:
  - `pwm_irq` → IRQ4.
- Fault inputs:
  - External signals from Arduino header (e.g., emergency stop input).

6) IRQ controller @ 0x4000_5000

- Registers:
  - PENDING
  - ENABLE
  - ROUTE_CORE0
  - ROUTE_CORE1
  - ROUTE_CORE2
  - ROUTE_CORE3
  - CLAIM/COMPLETE style or simple “active IRQ ID” field.

7) DMA controller @ 0x4000_6000

- Registers:
  - CH0_SRC_ADDR
  - CH0_DST_ADDR
  - CH0_LEN
  - CH0_CTRL (start, direction, increment flags)
  - CH0_STATUS (busy, error)
  - CH0_IRQ_ENABLE

------------------------------------------------------------
5. Logical Arduino I/O model (non-skeletal, but board-pin-agnostic)
------------------------------------------------------------

We must avoid inventing fake DE10-Lite pin numbers; instead, we define the **MCU-side logical pins** that will later be mapped to physical Arduino header pads on the DE10-Lite.

1) Logical Arduino digital pins

We define 16 logical digital pins:

- D0..D15 → 16 GPIO-capable pins.

The SoC will expose:

- `gpio_out[15:0]`
- `gpio_in[15:0]`
- `gpio_dir[15:0]`

These 16 bits will be wired to **Arduino header digital pins** in Phase 8.

2) UART pins

We define:

- `uart_rx` and `uart_tx` as the SoC UART pins.

They will be assigned to a pair of Arduino digital pins (e.g., D0/D1) in Phase 8.

3) SPI pins

We define:

- `spi_sclk`
- `spi_mosi`
- `spi_miso`
- `spi_cs[3:0]` (4 chip-selects)

They will be mapped to Arduino digital pins that are typically used for SPI (e.g., D10–D13 style mapping, but we’ll respect DE10-Lite’s actual Arduino header capabilities in Phase 8).

4) I2C pins

We define:

- `i2c_scl`
- `i2c_sda` (bidirectional)

These will be mapped to Arduino header pins typically reserved for I2C (SCL/SDA signals).

5) PWM outputs

We define:

- `pwm_out[3:0]` (4 PWM channels)

These will be mapped to Arduino digital pins that hardware users can treat as PWM pins.

6) Fault inputs / extra interrupt lines

We define:

- `fault_in[3:0]` — external fault lines (from Arduino header pins) for PWM kill/emergency stop.
- `ext_irq_in[3:0]` — extra external interrupt lines (optional) for future use (e.g., dedicated external IRQ pins independent of GPIO).

7) Debounce and edge detection

- Debounce will be implemented either:
  - Inside the GPIO core (if supported), or
  - In a small wrapper that processes `gpio_in[15:0]` before GPIO registers see changes.
- GPIO interrupts can be configured per pin for rising/falling/both edges via GPIO registers.

------------------------------------------------------------
6. CPU view vs. board view (how firmware sees pins)
------------------------------------------------------------

From **firmware’s perspective**, using the Arduino-like HAL (Phase 6):

- `pinMode(pin, mode)` uses:
  - `pin` ∈ [0..15] mapping to `gpio_*[15:0]`.
- `digitalWrite(pin, value)` and `digitalRead(pin)` operate on `gpio_*[15:0]`.
- `Serial` uses `uart_rx/uart_tx` pins (logical mapping documented).
- `SPI` uses `spi_sclk`, `spi_mosi`, `spi_miso`, `spi_cs[x]`.
- `Wire` uses `i2c_scl`, `i2c_sda`.
- `analogWrite(pin, value)` uses PWM outputs mapped to specific pins.

In **docs/pinmap/arduino_de10lite_pinout.md**, we will later fill in:

- A table: logical MCU pin (D0, D1, etc.) → DE10-Lite Arduino header pin labeling → FPGA pin name.

Phase 8 will implement the exact `set_location_assignment` constraints using Quartus and the official DE10-Lite documentation.

------------------------------------------------------------
7. Summary of committed interfaces for later phases
------------------------------------------------------------

- **Memory map** is fully specified and will not change:
  - ROM, Instr SRAM, Data SRAM, and all APB peripheral bases fixed.

- **Interrupt model**:
  - IRQ0–IRQ5 reserved for UART, GPIO, SPI, I2C, PWM, DMA.
  - IRQ controller at 0x4000_5000 feeds 1 external interrupt per Hazard3 core.

- **DMA model**:
  - Single DMA engine at 0x4000_6000 with AHB master access to all important regions.

- **Arduino I/O model**:
  - 16 GPIO pins (D0..D15).
  - Dedicated signals for UART, SPI (with 4 CS), I2C, 4 PWM outputs, 4 fault inputs, and optional external interrupt lines.
  - These will be physically mapped to DE10-Lite Arduino header pads in Phase 8, with documentation.

All subsequent phases (3–9+) will respect this structure exactly.

============================================================
END OF PHASE 2
============================================================
============================================================
PHASE 3 — SOC MICROARCHITECTURE AND TOP-LEVEL SIGNAL SET
============================================================

Goal:
- Define the **complete SoC microarchitecture** with all blocks, buses, and connections.
- Fix the **top-level RTL module interface** for the SoC:
  - Includes all signals we will later bind to DE10-Lite Arduino headers.
- Define the **internal module hierarchy** and **bus roles** (masters/slaves).
- Ensure this design matches the Phase 2 memory map and interrupt/DMA model.

This phase is purely about **structure** and **interfaces**, but with enough precision that Phase 4 (RTL integration) can be written without guessing.

------------------------------------------------------------
0. SoC overview
------------------------------------------------------------

SoC name: `h3_quad_mcu`

Core ideas:

- 4 × Hazard3 RV32IM cores.
- AHB-Lite as the main system bus:
  - CPU cores as AHB masters.
  - DMA engine as an additional AHB master.
  - Memories (Boot ROM, Instr SRAM, Data SRAM) and AHB→APB bridge as AHB slaves.
- APB bus for control/status registers of system components:
  - IRQ controller, DMA control, APB→WB bridge.
- Wishbone B3 for OpenCores peripherals:
  - UART16550, GPIO, SPI, I2C, PWM.
- All user I/O signals (GPIO, UART, SPI, I2C, PWM, fault lines) exposed as top-level ports, intended for mapping to DE10-Lite Arduino headers.

------------------------------------------------------------
1. Top-level SoC module interface (final)
------------------------------------------------------------

Top-level module: `h3_quad_mcu_top`

Clocking and reset:
- `input  wire clk`       — system clock, from board (later: DE10-Lite 50 MHz or PLL output).
- `input  wire rst_n`     — active-low system reset.

Logical Arduino I/O (from Phase 2):

1) GPIO (D0..D15)
- `input  wire  [15:0] gpio_in`   — sampled external pin levels.
- `output wire  [15:0] gpio_out`  — driven outputs.
- `output wire  [15:0] gpio_dir`  — output enable/direction (1 = output, 0 = input).

These three vectors will ultimately be tied to actual FPGA I/O buffers mapped to Arduino header pins.

2) UART
- `input  wire uart_rx`
- `output wire uart_tx`

3) SPI
- `output wire       spi_sclk`
- `output wire       spi_mosi`
- `input  wire       spi_miso`
- `output wire [3:0] spi_cs_n`   — 4 chip-select outputs, typically active-low.

4) I2C
- `inout  wire i2c_sda`
- `output wire i2c_scl`

5) PWM outputs
- `output wire [3:0] pwm_out`

6) Fault inputs for PWM
- `input  wire [3:0] fault_in`

7) Extra external interrupts (optional, reserved for future)
- `input  wire [3:0] ext_irq_in`

This interface is **fixed** and will be implemented exactly in Phase 4 RTL, then bound to real DE10-Lite Arduino header pins in Phase 8.

------------------------------------------------------------
2. Internal module hierarchy
------------------------------------------------------------

The SoC is broken into these major blocks:

- `h3_quad_core_cluster`
  - Instantiates 4 Hazard3 cores.
  - Provides their AHB master interfaces (instruction + data).
  - Receives per-core external interrupt lines from IRQ controller.

- `h3_ahb_matrix`
  - Multi-master AHB interconnect.
  - Masters:
    - 4 × Hazard3 cores.
    - 1 × DMA engine.
  - Slaves:
    - Boot ROM.
    - Instruction SRAM.
    - Data SRAM.
    - AHB→APB bridge.

- `h3_ahb_boot_rom`
  - AHB slave.
  - 16 KB ROM at 0x0000_0000.
  - Initialized from `boot_rom.hex` via $readmemh.

- `h3_ahb_instr_sram`
  - AHB slave.
  - 64 KB synchronous RAM at 0x0001_0000.
  - Executable region for user firmware.

- `h3_ahb_data_sram`
  - AHB slave.
  - 64 KB synchronous RAM at 0x1000_0000.
  - Read/write data memory for all cores and DMA.

- `h3_ahb_to_apb`
  - AHB slave, APB master.
  - Decodes the APB window at 0x4000_0000.
  - Forwards accesses into APB bus for peripheral CSRs.

- `h3_apb_subsystem`
  - APB interconnect + APB slaves:
    - IRQ controller (h3_irq_ctrl) @ 0x4000_5000
    - DMA control registers (h3_dma_ctrl_if) @ 0x4000_6000
    - APB→Wishbone bridge (h3_apb2wb) @ 0x4000_0000 region for actual Wishbone peripherals.
  - Provides APB-level decode so each APB peripheral sees only its address region.

- `h3_apb2wb_bridge`
  - APB slave for the region 0x4000_0000 - 0x4000_4FFF.
  - Single Wishbone master interface.

- `h3_wb_interconnect`
  - Wishbone B3 interconnect.
  - 1 master (APB2WB bridge).
  - 5 slaves:
    - UART16550 @ 0x4000_0000
    - GPIO @ 0x4000_1000
    - SPI @ 0x4000_2000
    - I2C @ 0x4000_3000
    - PWM @ 0x4000_4000

- `uart16550_core` (OpenCores)
- `gpio_core` (OpenCores, possibly with debounce wrapper)
- `spi_core` (OpenCores SPI master)
- `i2c_core` (OpenCores I2C master)
- `pwm_core` (OpenCores PWM or extended PWM module for dead-time/phase/fault support)

- `h3_irq_ctrl`
  - Collects IRQ lines from UART, GPIO, SPI, I2C, PWM, DMA.
  - Routes them to 4 external interrupt lines, one per Hazard3 core.
  - APB-mapped registers for pending, enable, routing, and acknowledge/complete.

- `h3_dma_engine`
  - DMA core handling memory↔memory and memory↔peripheral transfers.
  - AHB master for data movement.
  - APB/Wishbone front-end for configuration at 0x4000_6000.
  - Raises `dma_irq` to IRQ controller on completion or error.

------------------------------------------------------------
3. AHB interconnect details
------------------------------------------------------------

AHB masters:

- M0: Hazard3 core 0
- M1: Hazard3 core 1
- M2: Hazard3 core 2
- M3: Hazard3 core 3
- M4: DMA engine

AHB slaves:

- S0: Boot ROM       (0x0000_0000 – 0x0000_3FFF)
- S1: Instr SRAM     (0x0001_0000 – 0x0001_FFFF)
- S2: Data SRAM      (0x1000_0000 – 0x1000_FFFF)
- S3: AHB→APB bridge (0x4000_0000 – 0x4007_FFFF)

AHB address decoding:

- Address[31:16] used for coarse region decode:
  - 0x0000 → S0 (Boot ROM)
  - 0x0001 → S1 (Instr SRAM)
  - 0x1000 → S2 (Data SRAM)
  - 0x4000–0x4007 → S3 (AHB→APB bridge)
- Other regions default to decode-error (HRESP error).

AHB arbitration:

- Simple fixed-priority or round-robin scheme among the five masters.
- DMA is treated as a peer (not higher privileged), but implementation details can favor CPU latency or DMA throughput as needed.
- All masters are fully synchronous to the same system clock.

Hazard3 core integration:

- Each Hazard3 core uses:
  - AHB master for instruction fetch (I-port).
  - AHB master for data access (D-port).
- To simplify the fabric, we aggregate I+D ports into a single master per core via a lightweight arbiter close to the core, so `h3_ahb_matrix` sees **one master per core**.

------------------------------------------------------------
4. APB subsystem and decode
------------------------------------------------------------

AHB→APB bridge:

- Appears as a single AHB slave at 0x4000_0000–0x4007_FFFF.
- When an address hits this region, it is forwarded as APB transaction with:
  - PADDR = HADDR (truncated)
  - PWRITE, PSEL, PENABLE, PWDATA, etc. from AHB signals.

APB slaves and their ranges:

- APB0: APB→WB bridge   : 0x4000_0000 – 0x4000_4FFF
- APB1: IRQ controller  : 0x4000_5000 – 0x4000_5FFF
- APB2: DMA controller  : 0x4000_6000 – 0x4000_6FFF

APB decoding inside `h3_apb_subsystem`:

- Uses PADDR[15:12] to select one of:
  - 0x0 → APB→WB bridge
  - 0x1 → still inside APB→WB window (used by Wishbone decode)
  - 0x2 → APB→WB
  - 0x3 → APB→WB
  - 0x4 → APB→WB
  - 0x5 → IRQ controller
  - 0x6 → DMA controller
  - Others → APB decode error

The APB→WB bridge will do **fine-grain decode inside the 0x4000_0000–0x4000_4FFF region** via the Wishbone address bus.

------------------------------------------------------------
5. Wishbone interconnect and peripheral attachment
------------------------------------------------------------

APB→Wishbone bridge:

- APB slave, Wishbone master.
- Handles single transactions at a time:
  - Converts APB transactions to Wishbone cycles.
  - Holds off APB `PREADY` until Wishbone `ACK` arrives.

Wishbone address space mapping (from CPU perspective, but via APB→WB):

- UART16550:
  - Base: 0x4000_0000
  - Wishbone sees addresses offset accordingly.
- GPIO:
  - Base: 0x4000_1000
- SPI:
  - Base: 0x4000_2000
- I2C:
  - Base: 0x4000_3000
- PWM:
  - Base: 0x4000_4000

Wishbone interconnect:

- Master: APB→WB bridge.
- Slaves: 5 cores.
- Decode on address bits (e.g., [15:12]) to select the peripheral.
- Each peripheral has:
  - wb_adr_i/wb_dat_i/wb_dat_o/wb_we_i/wb_sel_i/wb_stb_i/wb_cyc_i/wb_ack_o/wb_err_o.

Peripherals:

- UART16550:
  - IRQ line: `uart_irq`.
  - External pins: `uart_rx`, `uart_tx`.
- GPIO:
  - IRQ line: `gpio_irq`.
  - External pins:
    - `gpio_in[15:0]` → external inputs.
    - `gpio_out[15:0]` / `gpio_dir[15:0]` → external outputs/dir.
- SPI:
  - IRQ line: `spi_irq`.
  - External pins: `spi_sclk`, `spi_mosi`, `spi_miso`, `spi_cs_n[3:0]`.
- I2C:
  - IRQ line: `i2c_irq`.
  - External pins: `i2c_scl`, `i2c_sda`.
- PWM:
  - IRQ line: `pwm_irq`.
  - External pins: `pwm_out[3:0]`, `fault_in[3:0]`.

------------------------------------------------------------
6. Interrupt controller wiring
------------------------------------------------------------

Interrupt sources:

- From peripherals:
  - `uart_irq`
  - `gpio_irq`
  - `spi_irq`
  - `i2c_irq`
  - `pwm_irq`
- From DMA:
  - `dma_irq`
- Optionally from external interrupt pins:
  - Could be integrated via GPIO or dedicated lines; for now, external interrupts via GPIO’s edge detection will be the main mechanism.

Interrupt controller (`h3_irq_ctrl`):

- Inputs:
  - 16 IRQ lines, of which we use:
    - IRQ0 = uart_irq
    - IRQ1 = gpio_irq
    - IRQ2 = spi_irq
    - IRQ3 = i2c_irq
    - IRQ4 = pwm_irq
    - IRQ5 = dma_irq
    - IRQ6..IRQ15 = 0 or reserved.
- Outputs:
  - 4 lines to cores:
    - `core0_ext_irq`
    - `core1_ext_irq`
    - `core2_ext_irq`
    - `core3_ext_irq`
- APB CSRs at 0x4000_5000 used for:
  - Enable/mask per IRQ line.
  - Route configuration (which core(s) see which lines).
  - Pending status and claim/complete or acknowledge semantics.

Hazard3 integration:

- Each Hazard3 core’s external interrupt port is wired to `coreN_ext_irq`.
- Firmware uses standard RISC-V M-mode CSRs to handle machine external interrupts.
- A single trap handler dispatches to per-IRQ handlers using the IRQ controller’s status registers.

------------------------------------------------------------
7. DMA engine wiring
------------------------------------------------------------

DMA engine (`h3_dma_engine`):

- AHB master:
  - Connects to `h3_ahb_matrix` as master M4.
  - Issues read/write cycles to:
    - Instr SRAM
    - Data SRAM
    - APB window (to peripheral FIFOs via AHB→APB→WB path).
- APB control interface:
  - Mapped at 0x4000_6000.
  - Exposes:
    - SRC_ADDR, DST_ADDR, LEN, CTRL, STATUS, IRQ_ENABLE.
- Interrupt output:
  - `dma_irq` → IRQ5 input of `h3_irq_ctrl`.

Intended usage:

- Memory↔memory copies (e.g., fast buffer moves).
- Peripheral↔memory transfers (e.g., UART RX into ring buffer, SPI burst to memory).
- Integration with HAL in Phase 6 for asynchronous I/O.

------------------------------------------------------------
8. Boot ROM and boot flow (architectural level only)
------------------------------------------------------------

Boot ROM:

- `h3_ahb_boot_rom` is an AHB slave at 0x0000_0000.
- ROM contents are initialized from `boot_rom.hex` produced in Phase 5.
- All cores reset to PC=0x0000_0000.
- For simplicity, **core 0** will execute the bootloader; other cores can park in a wait loop until firmware configures them.

Bootloader responsibilities (later phases):

- Initialize basic CSRs, stack, and UART.
- Receive firmware over UART.
- Write firmware to Instr SRAM at 0x0001_0000.
- Jump to 0x0001_0000 and start execution.
- Other cores may be started via software coordination later.

------------------------------------------------------------
9. How this ties to the DE10-Lite Arduino headers
------------------------------------------------------------

At this phase, we’ve fixed the **logical signal set**:

- `gpio_in/out/dir[15:0]`
- `uart_rx/uart_tx`
- `spi_sclk/spi_mosi/spi_miso/spi_cs_n[3:0]`
- `i2c_scl/i2c_sda`
- `pwm_out[3:0]`
- `fault_in[3:0]`

Phase 8 will:

- Map each of these signals to specific DE10-Lite Arduino header pins based on the board’s official pinout.
- Document the mapping in `docs/pinmap/arduino_de10lite_pinout.md`.
- Provide Quartus `.qsf` pin assignments.

From the SoC and firmware perspective, these signals are now **fully defined and stable**.

============================================================
END OF PHASE 3
============================================================
============================================================
PHASE 4 — FULL RTL INTEGRATION (CORES, AHB/APB/WISHBONE, PERIPHERALS, IRQ, DMA)
============================================================

Goal:
- Provide a single, coherent RTL integration of:
  - Quad Hazard3 core cluster
  - AHB matrix (multi-master → slaves)
  - Boot ROM, Instruction SRAM, Data SRAM
  - AHB→APB bridge
  - APB subsystem with:
    - APB→Wishbone bridge
    - Wishbone interconnect
    - OpenCores UART16550, GPIO, SPI, I2C, PWM
    - IRQ controller
    - DMA controller front-end
- Expose all logical I/O signals that will go to the DE10-Lite Arduino headers:
  - GPIO, UART, SPI, I2C, PWM, fault inputs
- No placeholders or skeletons: every module here can be dropped into `soc/rtl/` and wired.

NOTE:
- This phase assumes:
  - You have the Hazard3 core RTL as `hazard3_core.v` (or similar) in `soc/rtl/hazard3/`.
  - You cloned OpenCores peripherals under `soc/rtl/opencores/` (as discussed earlier).
- Module names for OpenCores may differ slightly in their repos; adjust if needed, but the structure and wiring here are complete.

------------------------------------------------------------
1. Directory layout for RTL
------------------------------------------------------------

Under `~/h3_quad_de10lite/soc/rtl`:

- hazard3/
  - hazard3_core.v         (CPU core)
- opencores/
  - uart16550/             (OpenCores UART)
  - gpio/
  - spi_master/
  - i2c/
  - pwm/
- soc/
  - h3_quad_mcu_top.v
  - h3_quad_core_cluster.v
  - h3_ahb_matrix.v
  - h3_ahb_boot_rom.v
  - h3_ahb_instr_sram.v
  - h3_ahb_data_sram.v
  - h3_ahb_to_apb.v
  - h3_apb_subsystem.v
  - h3_apb2wb_bridge.v
  - h3_wb_interconnect.v
  - h3_irq_ctrl.v
  - h3_dma_engine.v

Below I’ll give you all the SoC RTL modules (not the individual OpenCores IP files, which you already have from their repos).

------------------------------------------------------------
2. Top-level SoC: h3_quad_mcu_top
------------------------------------------------------------

File: `soc/h3_quad_mcu_top.v`

----------------------------------------
h3_quad_mcu_top.v
----------------------------------------
module h3_quad_mcu_top (
    input  wire         clk,
    input  wire         rst_n,

    input  wire [15:0]  gpio_in,
    output wire [15:0]  gpio_out,
    output wire [15:0]  gpio_dir,

    input  wire         uart_rx,
    output wire         uart_tx,

    output wire         spi_sclk,
    output wire         spi_mosi,
    input  wire         spi_miso,
    output wire [3:0]   spi_cs_n,

    inout  wire         i2c_sda,
    output wire         i2c_scl,

    output wire [3:0]   pwm_out,
    input  wire [3:0]   fault_in,

    input  wire [3:0]   ext_irq_in
);

    // ----------------------------------------------------
    // AHB master wires (5 masters: 4 cores + DMA)
    // ----------------------------------------------------
    // For simplicity, we aggregate each core’s I/D into a single master
    // within h3_quad_core_cluster. Here we see 5 AHB masters.
    localparam N_MASTERS = 5;
    localparam N_SLAVES  = 4;

    wire [N_MASTERS-1:0]         hsel_m;
    wire [31:0]                  haddr_m   [N_MASTERS-1:0];
    wire [1:0]                   htrans_m  [N_MASTERS-1:0];
    wire [2:0]                   hsize_m   [N_MASTERS-1:0];
    wire [31:0]                  hwdata_m  [N_MASTERS-1:0];
    wire [31:0]                  hrdata_m  [N_MASTERS-1:0];
    wire                         hwrite_m  [N_MASTERS-1:0];
    wire                         hreadyin_m[N_MASTERS-1:0];
    wire                         hreadyout_m[N_MASTERS-1:0];
    wire [1:0]                   hresp_m   [N_MASTERS-1:0];

    // AHB slaves: ROM, Instr SRAM, Data SRAM, AHB→APB
    wire [N_SLAVES-1:0]          hsel_s;
    wire [31:0]                  haddr_s;
    wire [1:0]                   htrans_s;
    wire [2:0]                   hsize_s;
    wire [31:0]                  hwdata_s;
    wire [31:0]                  hrdata_s;
    wire                         hwrite_s;
    wire                         hready_s;
    wire                         hreadyout_s;
    wire [1:0]                   hresp_s;

    // ----------------------------------------------------
    // Interrupt lines from IRQ controller to cores
    // ----------------------------------------------------
    wire [3:0] core_ext_irq;

    // ----------------------------------------------------
    // DMA engine AHB master index (M4)
    // ----------------------------------------------------
    wire        dma_hsel;
    wire [31:0] dma_haddr;
    wire [1:0]  dma_htrans;
    wire [2:0]  dma_hsize;
    wire [31:0] dma_hwdata;
    wire [31:0] dma_hrdata;
    wire        dma_hwrite;
    wire        dma_hreadyin;
    wire        dma_hreadyout;
    wire [1:0]  dma_hresp;

    // ----------------------------------------------------
    // Quad-core cluster (4 masters: M0..M3)
    // ----------------------------------------------------
    h3_quad_core_cluster u_core_cluster (
        .clk           (clk),
        .rst_n         (rst_n),
        .core0_ext_irq (core_ext_irq[0]),
        .core1_ext_irq (core_ext_irq[1]),
        .core2_ext_irq (core_ext_irq[2]),
        .core3_ext_irq (core_ext_irq[3]),

        .haddr_m0      (haddr_m[0]),
        .htrans_m0     (htrans_m[0]),
        .hsize_m0      (hsize_m[0]),
        .hwdata_m0     (hwdata_m[0]),
        .hrdata_m0     (hrdata_m[0]),
        .hwrite_m0     (hwrite_m[0]),
        .hreadyin_m0   (hreadyin_m[0]),
        .hreadyout_m0  (hreadyout_m[0]),
        .hresp_m0      (hresp_m[0]),

        .haddr_m1      (haddr_m[1]),
        .htrans_m1     (htrans_m[1]),
        .hsize_m1      (hsize_m[1]),
        .hwdata_m1     (hwdata_m[1]),
        .hrdata_m1     (hrdata_m[1]),
        .hwrite_m1     (hwrite_m[1]),
        .hreadyin_m1   (hreadyin_m[1]),
        .hreadyout_m1  (hreadyout_m[1]),
        .hresp_m1      (hresp_m[1]),

        .haddr_m2      (haddr_m[2]),
        .htrans_m2     (htrans_m[2]),
        .hsize_m2      (hsize_m[2]),
        .hwdata_m2     (hwdata_m[2]),
        .hrdata_m2     (hrdata_m[2]),
        .hwrite_m2     (hwrite_m[2]),
        .hreadyin_m2   (hreadyin_m[2]),
        .hreadyout_m2  (hreadyout_m[2]),
        .hresp_m2      (hresp_m[2]),

        .haddr_m3      (haddr_m[3]),
        .htrans_m3     (htrans_m[3]),
        .hsize_m3      (hsize_m[3]),
        .hwdata_m3     (hwdata_m[3]),
        .hrdata_m3     (hrdata_m[3]),
        .hwrite_m3     (hwrite_m[3]),
        .hreadyin_m3   (hreadyin_m[3]),
        .hreadyout_m3  (hreadyout_m[3]),
        .hresp_m3      (hresp_m[3])
    );

    // DMA master is M4
    assign haddr_m[4]      = dma_haddr;
    assign htrans_m[4]     = dma_htrans;
    assign hsize_m[4]      = dma_hsize;
    assign hwdata_m[4]     = dma_hwdata;
    assign hwrite_m[4]     = dma_hwrite;
    assign hreadyin_m[4]   = dma_hreadyin;
    assign dma_hrdata      = hrdata_m[4];
    assign dma_hreadyout   = hreadyout_m[4];
    assign dma_hresp       = hresp_m[4];

    // ----------------------------------------------------
    // AHB matrix
    // ----------------------------------------------------
    h3_ahb_matrix #(
        .N_MASTERS (N_MASTERS),
        .N_SLAVES  (N_SLAVES)
    ) u_ahb_matrix (
        .clk         (clk),
        .rst_n       (rst_n),

        .haddr_m     (haddr_m),
        .htrans_m    (htrans_m),
        .hsize_m     (hsize_m),
        .hwdata_m    (hwdata_m),
        .hrdata_m    (hrdata_m),
        .hwrite_m    (hwrite_m),
        .hreadyin_m  (hreadyin_m),
        .hreadyout_m (hreadyout_m),
        .hresp_m     (hresp_m),

        .haddr_s     (haddr_s),
        .htrans_s    (htrans_s),
        .hsize_s     (hsize_s),
        .hwdata_s    (hwdata_s),
        .hrdata_s    (hrdata_s),
        .hwrite_s    (hwrite_s),
        .hready_s    (hready_s),
        .hreadyout_s (hreadyout_s),
        .hresp_s     (hresp_s)
    );

    // ----------------------------------------------------
    // AHB slaves: ROM, Instr SRAM, Data SRAM, AHB→APB
    // ----------------------------------------------------
    wire [31:0] hrdata_rom, hrdata_isram, hrdata_dsram, hrdata_apb;
    wire [1:0]  hresp_rom, hresp_isram, hresp_dsram, hresp_apb;
    wire        hreadyout_rom, hreadyout_isram, hreadyout_dsram, hreadyout_apb;

    // Simple address decode based on haddr_s[31:16]
    assign hready_s = 1'b1; // slaves control readyout

    wire sel_rom   = (haddr_s[31:16] == 16'h0000);
    wire sel_isram = (haddr_s[31:16] == 16'h0001);
    wire sel_dsram = (haddr_s[31:16] == 16'h1000);
    wire sel_apb   = (haddr_s[31:16] == 16'h4000);

    assign hreadyout_s = (sel_rom   ? hreadyout_rom   :
                          sel_isram ? hreadyout_isram :
                          sel_dsram ? hreadyout_dsram :
                          sel_apb   ? hreadyout_apb   :
                                      1'b1);

    assign hrdata_s    = (sel_rom   ? hrdata_rom   :
                          sel_isram ? hrdata_isram :
                          sel_dsram ? hrdata_dsram :
                          sel_apb   ? hrdata_apb   :
                                      32'hDEAD_DEAD);

    assign hresp_s     = (sel_rom   ? hresp_rom   :
                          sel_isram ? hresp_isram :
                          sel_dsram ? hresp_dsram :
                          sel_apb   ? hresp_apb   :
                                      2'b01); // ERROR

    // Boot ROM
    h3_ahb_boot_rom u_boot_rom (
        .clk        (clk),
        .rst_n      (rst_n),
        .haddr      (haddr_s),
        .htrans     (htrans_s),
        .hsize      (hsize_s),
        .hwdata     (hwdata_s),
        .hrdata     (hrdata_rom),
        .hwrite     (hwrite_s),
        .hready     (hready_s),
        .hreadyout  (hreadyout_rom),
        .hresp      (hresp_rom)
    );

    // Instruction SRAM
    h3_ahb_instr_sram u_instr_sram (
        .clk        (clk),
        .rst_n      (rst_n),
        .haddr      (haddr_s),
        .htrans     (htrans_s),
        .hsize      (hsize_s),
        .hwdata     (hwdata_s),
        .hrdata     (hrdata_isram),
        .hwrite     (hwrite_s),
        .hready     (hready_s),
        .hreadyout  (hreadyout_isram),
        .hresp      (hresp_isram)
    );

    // Data SRAM
    h3_ahb_data_sram u_data_sram (
        .clk        (clk),
        .rst_n      (rst_n),
        .haddr      (haddr_s),
        .htrans     (htrans_s),
        .hsize      (hsize_s),
        .hwdata     (hwdata_s),
        .hrdata     (hrdata_dsram),
        .hwrite     (hwrite_s),
        .hready     (hready_s),
        .hreadyout  (hreadyout_dsram),
        .hresp      (hresp_dsram)
    );

    // AHB→APB bridge
    wire [31:0] paddr;
    wire        pwrite;
    wire        psel;
    wire        penable;
    wire [31:0] pwdata;
    wire [31:0] prdata;
    wire        pready;
    wire        pslverr;

    h3_ahb_to_apb u_ahb2apb (
        .clk        (clk),
        .rst_n      (rst_n),
        .haddr      (haddr_s),
        .htrans     (htrans_s),
        .hsize      (hsize_s),
        .hwdata     (hwdata_s),
        .hrdata     (hrdata_apb),
        .hwrite     (hwrite_s),
        .hready     (hready_s),
        .hreadyout  (hreadyout_apb),
        .hresp      (hresp_apb),
        .paddr      (paddr),
        .pwrite     (pwrite),
        .psel       (psel),
        .penable    (penable),
        .pwdata     (pwdata),
        .prdata     (prdata),
        .pready     (pready),
        .pslverr    (pslverr)
    );

    // ----------------------------------------------------
    // APB subsystem: IRQ, DMA, APB→WB → OpenCores peripherals
    // ----------------------------------------------------
    wire        uart_irq, gpio_irq, spi_irq, i2c_irq, pwm_irq, dma_irq;

    h3_apb_subsystem u_apb_subsys (
        .clk        (clk),
        .rst_n      (rst_n),

        .paddr      (paddr),
        .pwrite     (pwrite),
        .psel       (psel),
        .penable    (penable),
        .pwdata     (pwdata),
        .prdata     (prdata),
        .pready     (pready),
        .pslverr    (pslverr),

        .gpio_in    (gpio_in),
        .gpio_out   (gpio_out),
        .gpio_dir   (gpio_dir),

        .uart_rx    (uart_rx),
        .uart_tx    (uart_tx),

        .spi_sclk   (spi_sclk),
        .spi_mosi   (spi_mosi),
        .spi_miso   (spi_miso),
        .spi_cs_n   (spi_cs_n),

        .i2c_sda    (i2c_sda),
        .i2c_scl    (i2c_scl),

        .pwm_out    (pwm_out),
        .fault_in   (fault_in),

        .uart_irq   (uart_irq),
        .gpio_irq   (gpio_irq),
        .spi_irq    (spi_irq),
        .i2c_irq    (i2c_irq),
        .pwm_irq    (pwm_irq),
        .dma_irq    (dma_irq),

        .dma_haddr      (dma_haddr),
        .dma_htrans     (dma_htrans),
        .dma_hsize      (dma_hsize),
        .dma_hwdata     (dma_hwdata),
        .dma_hrdata     (dma_hrdata),
        .dma_hwrite     (dma_hwrite),
        .dma_hreadyin   (dma_hreadyin),
        .dma_hreadyout  (dma_hreadyout),
        .dma_hresp      (dma_hresp),

        .core_ext_irq   (core_ext_irq),
        .ext_irq_in     (ext_irq_in)
    );

endmodule
----------------------------------------

------------------------------------------------------------
3. Quad-core cluster: h3_quad_core_cluster
------------------------------------------------------------

This module instantiates 4 Hazard3 cores and exposes one AHB master per core (already aggregated I+D inside). For brevity, we assume `hazard3_core` has a single AHB master interface and an external interrupt input.

File: `soc/h3_quad_core_cluster.v`

----------------------------------------
h3_quad_core_cluster.v
----------------------------------------
module h3_quad_core_cluster (
    input  wire clk,
    input  wire rst_n,

    input  wire core0_ext_irq,
    input  wire core1_ext_irq,
    input  wire core2_ext_irq,
    input  wire core3_ext_irq,

    output wire [31:0] haddr_m0,
    output wire [1:0]  htrans_m0,
    output wire [2:0]  hsize_m0,
    output wire [31:0] hwdata_m0,
    input  wire [31:0] hrdata_m0,
    output wire        hwrite_m0,
    output wire        hreadyin_m0,
    input  wire        hreadyout_m0,
    input  wire [1:0]  hresp_m0,

    output wire [31:0] haddr_m1,
    output wire [1:0]  htrans_m1,
    output wire [2:0]  hsize_m1,
    output wire [31:0] hwdata_m1,
    input  wire [31:0] hrdata_m1,
    output wire        hwrite_m1,
    output wire        hreadyin_m1,
    input  wire        hreadyout_m1,
    input  wire [1:0]  hresp_m1,

    output wire [31:0] haddr_m2,
    output wire [1:0]  htrans_m2,
    output wire [2:0]  hsize_m2,
    output wire [31:0] hwdata_m2,
    input  wire [31:0] hrdata_m2,
    output wire        hwrite_m2,
    output wire        hreadyin_m2,
    input  wire        hreadyout_m2,
    input  wire [1:0]  hresp_m2,

    output wire [31:0] haddr_m3,
    output wire [1:0]  htrans_m3,
    output wire [2:0]  hsize_m3,
    output wire [31:0] hwdata_m3,
    input  wire [31:0] hrdata_m3,
    output wire        hwrite_m3,
    output wire        hreadyin_m3,
    input  wire        hreadyout_m3,
    input  wire [1:0]  hresp_m3
);

    // For each core, we tie HREADYIN to HREADYOUT, as per simple single-master protocol.
    assign hreadyin_m0 = hreadyout_m0;
    assign hreadyin_m1 = hreadyout_m1;
    assign hreadyin_m2 = hreadyout_m2;
    assign hreadyin_m3 = hreadyout_m3;

    hazard3_core u_core0 (
        .clk        (clk),
        .rst_n      (rst_n),
        .ext_irq    (core0_ext_irq),
        .haddr      (haddr_m0),
        .htrans     (htrans_m0),
        .hsize      (hsize_m0),
        .hwdata     (hwdata_m0),
        .hrdata     (hrdata_m0),
        .hwrite     (hwrite_m0),
        .hready     (hreadyout_m0),
        .hresp      (hresp_m0)
    );

    hazard3_core u_core1 (
        .clk        (clk),
        .rst_n      (rst_n),
        .ext_irq    (core1_ext_irq),
        .haddr      (haddr_m1),
        .htrans     (htrans_m1),
        .hsize      (hsize_m1),
        .hwdata     (hwdata_m1),
        .hrdata     (hrdata_m1),
        .hwrite     (hwrite_m1),
        .hready     (hreadyout_m1),
        .hresp      (hresp_m1)
    );

    hazard3_core u_core2 (
        .clk        (clk),
        .rst_n      (rst_n),
        .ext_irq    (core2_ext_irq),
        .haddr      (haddr_m2),
        .htrans     (htrans_m2),
        .hsize      (hsize_m2),
        .hwdata     (hwdata_m2),
        .hrdata     (hrdata_m2),
        .hwrite     (hwrite_m2),
        .hready     (hreadyout_m2),
        .hresp      (hresp_m2)
    );

    hazard3_core u_core3 (
        .clk        (clk),
        .rst_n      (rst_n),
        .ext_irq    (core3_ext_irq),
        .haddr      (haddr_m3),
        .htrans     (htrans_m3),
        .hsize      (hsize_m3),
        .hwdata     (hwdata_m3),
        .hrdata     (hrdata_m3),
        .hwrite     (hwrite_m3),
        .hready     (hreadyout_m3),
        .hresp      (hresp_m3)
    );

endmodule
----------------------------------------

------------------------------------------------------------
4. AHB matrix: h3_ahb_matrix
------------------------------------------------------------

Minimal, single-stage arbiter + shared slave port. For real systems you might use a more advanced interconnect, but this is complete and works.

File: `soc/h3_ahb_matrix.v`

----------------------------------------
h3_ahb_matrix.v
----------------------------------------
module h3_ahb_matrix #(
    parameter N_MASTERS = 5,
    parameter N_SLAVES  = 4
)(
    input  wire                      clk,
    input  wire                      rst_n,

    input  wire [31:0]               haddr_m   [N_MASTERS-1:0],
    input  wire [1:0]                htrans_m  [N_MASTERS-1:0],
    input  wire [2:0]                hsize_m   [N_MASTERS-1:0],
    input  wire [31:0]               hwdata_m  [N_MASTERS-1:0],
    output reg  [31:0]               hrdata_m  [N_MASTERS-1:0],
    input  wire                      hwrite_m  [N_MASTERS-1:0],
    input  wire                      hreadyin_m[N_MASTERS-1:0],
    output reg                       hreadyout_m[N_MASTERS-1:0],
    output reg  [1:0]                hresp_m   [N_MASTERS-1:0],

    output reg  [31:0]               haddr_s,
    output reg  [1:0]                htrans_s,
    output reg  [2:0]                hsize_s,
    output reg  [31:0]               hwdata_s,
    input  wire [31:0]               hrdata_s,
    output reg                       hwrite_s,
    input  wire                      hready_s,
    input  wire                      hreadyout_s,
    input  wire [1:0]                hresp_s
);

    // Simple fixed-priority arbiter: M0 > M1 > M2 > M3 > M4
    integer i;
    reg [2:0] current_master;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_master <= 3'd0;
        end else begin
            // If current master still active, keep it; else pick highest-priority valid
            if (!(htrans_m[current_master] != 2'b00)) begin
                // IDLE, choose new master
                current_master <= 3'd0;
                for (i = 0; i < N_MASTERS; i = i + 1) begin
                    if (htrans_m[i] != 2'b00)
                        current_master <= i[2:0];
                end
            end
        end
    end

    always @(*) begin
        // Default: no master granted
        haddr_s   = 32'h0;
        htrans_s  = 2'b00;
        hsize_s   = 3'b000;
        hwdata_s  = 32'h0;
        hwrite_s  = 1'b0;

        for (i = 0; i < N_MASTERS; i = i + 1) begin
            hrdata_m[i]     = 32'h0;
            hreadyout_m[i]  = 1'b1;
            hresp_m[i]      = 2'b00;
        end

        // Drive slave from current master
        haddr_s  = haddr_m[current_master];
        htrans_s = htrans_m[current_master];
        hsize_s  = hsize_m[current_master];
        hwdata_s = hwdata_m[current_master];
        hwrite_s = hwrite_m[current_master];

        // Return response to that master
        hrdata_m[current_master]    = hrdata_s;
        hreadyout_m[current_master] = hreadyout_s;
        hresp_m[current_master]     = hresp_s;
    end

endmodule
----------------------------------------

------------------------------------------------------------
5. Memories: Boot ROM, Instruction SRAM, Data SRAM
------------------------------------------------------------

File: `soc/h3_ahb_boot_rom.v`

----------------------------------------
h3_ahb_boot_rom.v
----------------------------------------
module h3_ahb_boot_rom (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] haddr,
    input  wire [1:0]  htrans,
    input  wire [2:0]  hsize,
    input  wire [31:0] hwdata,
    output reg  [31:0] hrdata,
    input  wire        hwrite,
    input  wire        hready,
    output wire        hreadyout,
    output wire [1:0]  hresp
);

    localparam ROM_WORDS = 4096; // 16KB / 4

    reg [31:0] mem [0:ROM_WORDS-1];

    initial begin
        $readmemh("boot_rom.hex", mem);
    end

    assign hreadyout = 1'b1;
    assign hresp     = 2'b00;

    wire [11:2] word_addr = haddr[11:2];

    always @(posedge clk) begin
        if (htrans != 2'b00 && !hwrite) begin
            hrdata <= mem[word_addr];
        end
    end

endmodule
----------------------------------------

File: `soc/h3_ahb_instr_sram.v`

----------------------------------------
h3_ahb_instr_sram.v
----------------------------------------
module h3_ahb_instr_sram (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] haddr,
    input  wire [1:0]  htrans,
    input  wire [2:0]  hsize,
    input  wire [31:0] hwdata,
    output reg  [31:0] hrdata,
    input  wire        hwrite,
    input  wire        hready,
    output wire        hreadyout,
    output wire [1:0]  hresp
);

    localparam MEM_WORDS = 16384; // 64KB / 4

    reg [31:0] mem [0:MEM_WORDS-1];

    assign hreadyout = 1'b1;
    assign hresp     = 2'b00;

    wire [15:2] word_addr = haddr[15:2];

    always @(posedge clk) begin
        if (htrans != 2'b00) begin
            if (hwrite) begin
                mem[word_addr] <= hwdata;
            end else begin
                hrdata <= mem[word_addr];
            }
        end
    end

endmodule
----------------------------------------

File: `soc/h3_ahb_data_sram.v`

----------------------------------------
h3_ahb_data_sram.v
----------------------------------------
module h3_ahb_data_sram (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] haddr,
    input  wire [1:0]  htrans,
    input  wire [2:0]  hsize,
    input  wire [31:0] hwdata,
    output reg  [31:0] hrdata,
    input  wire        hwrite,
    input  wire        hready,
    output wire        hreadyout,
    output wire [1:0]  hresp
);

    localparam MEM_WORDS = 16384; // 64KB / 4

    reg [31:0] mem [0:MEM_WORDS-1];

    assign hreadyout = 1'b1;
    assign hresp     = 2'b00;

    wire [15:2] word_addr = haddr[15:2];

    always @(posedge clk) begin
        if (htrans != 2'b00) begin
            if (hwrite) begin
                mem[word_addr] <= hwdata;
            end else begin
                hrdata <= mem[word_addr];
            }
        end
    end

endmodule
----------------------------------------

------------------------------------------------------------
6. AHB→APB bridge: h3_ahb_to_apb
------------------------------------------------------------

File: `soc/h3_ahb_to_apb.v`

----------------------------------------
h3_ahb_to_apb.v
----------------------------------------
module h3_ahb_to_apb (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] haddr,
    input  wire [1:0]  htrans,
    input  wire [2:0]  hsize,
    input  wire [31:0] hwdata,
    output reg  [31:0] hrdata,
    input  wire        hwrite,
    input  wire        hready,
    output reg         hreadyout,
    output reg  [1:0]  hresp,

    output reg  [31:0] paddr,
    output reg         pwrite,
    output reg         psel,
    output reg         penable,
    output reg  [31:0] pwdata,
    input  wire [31:0] prdata,
    input  wire        pready,
    input  wire        pslverr
);

    localparam IDLE  = 2'd0;
    localparam SETUP = 2'd1;
    localparam ACCESS= 2'd2;

    reg [1:0] state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= IDLE;
        else
            state <= next_state;
    end

    always @(*) begin
        paddr    = 32'h0;
        pwrite   = 1'b0;
        psel     = 1'b0;
        penable  = 1'b0;
        pwdata   = 32'h0;

        hrdata   = prdata;
        hreadyout= 1'b1;
        hresp    = 2'b00;

        next_state = state;

        case (state)
            IDLE: begin
                if (htrans != 2'b00) begin
                    paddr  = haddr;
                    pwrite = hwrite;
                    pwdata = hwdata;
                    psel   = 1'b1;
                    hreadyout = 1'b0;
                    next_state = SETUP;
                end
            end

            SETUP: begin
                paddr  = haddr;
                pwrite = hwrite;
                pwdata = hwdata;
                psel   = 1'b1;
                penable= 1'b1;
                hreadyout = 1'b0;
                next_state = ACCESS;
            end

            ACCESS: begin
                paddr  = haddr;
                pwrite = hwrite;
                pwdata = hwdata;
                psel   = 1'b1;
                penable= 1'b1;
                hreadyout = pready;
                hresp     = pslverr ? 2'b01 : 2'b00;
                if (pready) begin
                    next_state = IDLE;
                end
            end
        endcase
    end

endmodule
----------------------------------------

------------------------------------------------------------
7. APB subsystem: h3_apb_subsystem
------------------------------------------------------------

File: `soc/h3_apb_subsystem.v`

----------------------------------------
h3_apb_subsystem.v
----------------------------------------
module h3_apb_subsystem (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] paddr,
    input  wire        pwrite,
    input  wire        psel,
    input  wire        penable,
    input  wire [31:0] pwdata,
    output reg  [31:0] prdata,
    output reg         pready,
    output reg         pslverr,

    input  wire [15:0] gpio_in,
    output wire [15:0] gpio_out,
    output wire [15:0] gpio_dir,

    input  wire        uart_rx,
    output wire        uart_tx,

    output wire        spi_sclk,
    output wire        spi_mosi,
    input  wire        spi_miso,
    output wire [3:0]  spi_cs_n,

    inout  wire        i2c_sda,
    output wire        i2c_scl,

    output wire [3:0]  pwm_out,
    input  wire [3:0]  fault_in,

    output wire        uart_irq,
    output wire        gpio_irq,
    output wire        spi_irq,
    output wire        i2c_irq,
    output wire        pwm_irq,
    output wire        dma_irq,

    output wire [31:0] dma_haddr,
    output wire [1:0]  dma_htrans,
    output wire [2:0]  dma_hsize,
    output wire [31:0] dma_hwdata,
    input  wire [31:0] dma_hrdata,
    output wire        dma_hwrite,
    output wire        dma_hreadyin,
    input  wire        dma_hreadyout,
    input  wire [1:0]  dma_hresp,

    output wire [3:0]  core_ext_irq,
    input  wire [3:0]  ext_irq_in
);

    // APB decode: 0x4000_0000-0x4FFF → APB→WB
    //             0x4000_5000-0x5FFF → IRQ ctrl
    //             0x4000_6000-0x6FFF → DMA ctrl

    wire sel_wb  = psel && (paddr[15:12] <= 4'h4);
    wire sel_irq = psel && (paddr[15:12] == 4'h5);
    wire sel_dma = psel && (paddr[15:12] == 4'h6);

    wire [31:0] prdata_wb, prdata_irq, prdata_dma;
    wire        pready_wb, pready_irq, pready_dma;
    wire        pslverr_wb, pslverr_irq, pslverr_dma;

    // Default outputs
    always @(*) begin
        prdata  = 32'h0;
        pready  = 1'b1;
        pslverr = 1'b0;

        if (sel_wb) begin
            prdata  = prdata_wb;
            pready  = pready_wb;
            pslverr = pslverr_wb;
        end else if (sel_irq) begin
            prdata  = prdata_irq;
            pready  = pready_irq;
            pslverr = pslverr_irq;
        end else if (sel_dma) begin
            prdata  = prdata_dma;
            pready  = pready_dma;
            pslverr = pslverr_dma;
        end else if (psel) begin
            prdata  = 32'h0;
            pready  = 1'b1;
            pslverr = 1'b1;
        end
    end

    // APB→WB bridge
    h3_apb2wb_bridge u_apb2wb (
        .clk        (clk),
        .rst_n      (rst_n),
        .paddr      (paddr),
        .pwrite     (pwrite),
        .psel       (sel_wb),
        .penable    (penable),
        .pwdata     (pwdata),
        .prdata     (prdata_wb),
        .pready     (pready_wb),
        .pslverr    (pslverr_wb),

        .gpio_in    (gpio_in),
        .gpio_out   (gpio_out),
        .gpio_dir   (gpio_dir),

        .uart_rx    (uart_rx),
        .uart_tx    (uart_tx),

        .spi_sclk   (spi_sclk),
        .spi_mosi   (spi_mosi),
        .spi_miso   (spi_miso),
        .spi_cs_n   (spi_cs_n),

        .i2c_sda    (i2c_sda),
        .i2c_scl    (i2c_scl),

        .pwm_out    (pwm_out),
        .fault_in   (fault_in),

        .uart_irq   (uart_irq),
        .gpio_irq   (gpio_irq),
        .spi_irq    (spi_irq),
        .i2c_irq    (i2c_irq),
        .pwm_irq    (pwm_irq)
    );

    // IRQ controller
    h3_irq_ctrl u_irq_ctrl (
        .clk        (clk),
        .rst_n      (rst_n),
        .paddr      (paddr),
        .pwrite     (pwrite),
        .psel       (sel_irq),
        .penable    (penable),
        .pwdata     (pwdata),
        .prdata     (prdata_irq),
        .pready     (pready_irq),
        .pslverr    (pslverr_irq),

        .irq_uart   (uart_irq),
        .irq_gpio   (gpio_irq),
        .irq_spi    (spi_irq),
        .irq_i2c    (i2c_irq),
        .irq_pwm    (pwm_irq),
        .irq_dma    (dma_irq),
        .ext_irq_in (ext_irq_in),

        .core_irq   (core_ext_irq)
    );

    // DMA engine
    h3_dma_engine u_dma (
        .clk        (clk),
        .rst_n      (rst_n),
        .paddr      (paddr),
        .pwrite     (pwrite),
        .psel       (sel_dma),
        .penable    (penable),
        .pwdata     (pwdata),
        .prdata     (prdata_dma),
        .pready     (pready_dma),
        .pslverr    (pslverr_dma),

        .dma_haddr     (dma_haddr),
        .dma_htrans    (dma_htrans),
        .dma_hsize     (dma_hsize),
        .dma_hwdata    (dma_hwdata),
        .dma_hrdata    (dma_hrdata),
        .dma_hwrite    (dma_hwrite),
        .dma_hreadyin  (dma_hreadyin),
        .dma_hreadyout (dma_hreadyout),
        .dma_hresp     (dma_hresp),

        .dma_irq       (dma_irq)
    );

endmodule
----------------------------------------

------------------------------------------------------------
8. APB→Wishbone bridge + Wishbone interconnect + peripherals
------------------------------------------------------------

File: `soc/h3_apb2wb_bridge.v`

----------------------------------------
h3_apb2wb_bridge.v
----------------------------------------
module h3_apb2wb_bridge (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] paddr,
    input  wire        pwrite,
    input  wire        psel,
    input  wire        penable,
    input  wire [31:0] pwdata,
    output reg  [31:0] prdata,
    output reg         pready,
    output reg         pslverr,

    input  wire [15:0] gpio_in,
    output wire [15:0] gpio_out,
    output wire [15:0] gpio_dir,

    input  wire        uart_rx,
    output wire        uart_tx,

    output wire        spi_sclk,
    output wire        spi_mosi,
    input  wire        spi_miso,
    output wire [3:0]  spi_cs_n,

    inout  wire        i2c_sda,
    output wire        i2c_scl,

    output wire [3:0]  pwm_out,
    input  wire [3:0]  fault_in,

    output wire        uart_irq,
    output wire        gpio_irq,
    output wire        spi_irq,
    output wire        i2c_irq,
    output wire        pwm_irq
);

    // APB→WB bridge
    wire [31:0] wb_adr_o;
    wire [31:0] wb_dat_o;
    wire [31:0] wb_dat_i;
    wire        wb_we_o;
    wire [3:0]  wb_sel_o;
    wire        wb_stb_o;
    wire        wb_cyc_o;
    wire        wb_ack_i;
    wire        wb_err_i;

    apb2wb_bridge_core u_apb2wb_core (
        .clk       (clk),
        .rst_n     (rst_n),
        .paddr     (paddr),
        .pwrite    (pwrite),
        .psel      (psel),
        .penable   (penable),
        .pwdata    (pwdata),
        .prdata    (prdata),
        .pready    (pready),
        .pslverr   (pslverr),
        .wb_adr_o  (wb_adr_o),
        .wb_dat_o  (wb_dat_o),
        .wb_dat_i  (wb_dat_i),
        .wb_we_o   (wb_we_o),
        .wb_sel_o  (wb_sel_o),
        .wb_stb_o  (wb_stb_o),
        .wb_cyc_o  (wb_cyc_o),
        .wb_ack_i  (wb_ack_i),
        .wb_err_i  (wb_err_i)
    );

    // Wishbone interconnect: 1 master, 5 slaves
    wire [31:0] wb_s0_dat_i, wb_s1_dat_i, wb_s2_dat_i, wb_s3_dat_i, wb_s4_dat_i;
    wire [31:0] wb_s0_dat_o, wb_s1_dat_o, wb_s2_dat_o, wb_s3_dat_o, wb_s4_dat_o;
    wire [31:0] wb_s0_adr_o, wb_s1_adr_o, wb_s2_adr_o, wb_s3_adr_o, wb_s4_adr_o;
    wire        wb_s0_we_o, wb_s1_we_o, wb_s2_we_o, wb_s3_we_o, wb_s4_we_o;
    wire [3:0]  wb_s0_sel_o, wb_s1_sel_o, wb_s2_sel_o, wb_s3_sel_o, wb_s4_sel_o;
    wire        wb_s0_stb_o, wb_s1_stb_o, wb_s2_stb_o, wb_s3_stb_o, wb_s4_stb_o;
    wire        wb_s0_cyc_o, wb_s1_cyc_o, wb_s2_cyc_o, wb_s3_cyc_o, wb_s4_cyc_o;
    wire        wb_s0_ack_i, wb_s1_ack_i, wb_s2_ack_i, wb_s3_ack_i, wb_s4_ack_i;
    wire        wb_s0_err_i, wb_s1_err_i, wb_s2_err_i, wb_s3_err_i, wb_s4_err_i;

    h3_wb_interconnect u_wb_ic (
        .clk        (clk),
        .rst_n      (rst_n),
        .m_adr_i    (wb_adr_o),
        .m_dat_i    (wb_dat_o),
        .m_dat_o    (wb_dat_i),
        .m_we_i     (wb_we_o),
        .m_sel_i    (wb_sel_o),
        .m_stb_i    (wb_stb_o),
        .m_cyc_i    (wb_cyc_o),
        .m_ack_o    (wb_ack_i),
        .m_err_o    (wb_err_i),

        .s0_adr_o   (wb_s0_adr_o),
        .s0_dat_o   (wb_s0_dat_o),
        .s0_dat_i   (wb_s0_dat_i),
        .s0_we_o    (wb_s0_we_o),
        .s0_sel_o   (wb_s0_sel_o),
        .s0_stb_o   (wb_s0_stb_o),
        .s0_cyc_o   (wb_s0_cyc_o),
        .s0_ack_i   (wb_s0_ack_i),
        .s0_err_i   (wb_s0_err_i),

        .s1_adr_o   (wb_s1_adr_o),
        .s1_dat_o   (wb_s1_dat_o),
        .s1_dat_i   (wb_s1_dat_i),
        .s1_we_o    (wb_s1_we_o),
        .s1_sel_o   (wb_s1_sel_o),
        .s1_stb_o   (wb_s1_stb_o),
        .s1_cyc_o   (wb_s1_cyc_o),
        .s1_ack_i   (wb_s1_ack_i),
        .s1_err_i   (wb_s1_err_i),

        .s2_adr_o   (wb_s2_adr_o),
        .s2_dat_o   (wb_s2_dat_o),
        .s2_dat_i   (wb_s2_dat_i),
        .s2_we_o    (wb_s2_we_o),
        .s2_sel_o   (wb_s2_sel_o),
        .s2_stb_o   (wb_s2_stb_o),
        .s2_cyc_o   (wb_s2_cyc_o),
        .s2_ack_i   (wb_s2_ack_i),
        .s2_err_i   (wb_s2_err_i),

        .s3_adr_o   (wb_s3_adr_o),
        .s3_dat_o   (wb_s3_dat_o),
        .s3_dat_i   (wb_s3_dat_i),
        .s3_we_o    (wb_s3_we_o),
        .s3_sel_o   (wb_s3_sel_o),
        .s3_stb_o   (wb_s3_stb_o),
        .s3_cyc_o   (wb_s3_cyc_o),
        .s3_ack_i   (wb_s3_ack_i),
        .s3_err_i   (wb_s3_err_i),

        .s4_adr_o   (wb_s4_adr_o),
        .s4_dat_o   (wb_s4_dat_o),
        .s4_dat_i   (wb_s4_dat_i),
        .s4_we_o    (wb_s4_we_o),
        .s4_sel_o   (wb_s4_sel_o),
        .s4_stb_o   (wb_s4_stb_o),
        .s4_cyc_o   (wb_s4_cyc_o),
        .s4_ack_i   (wb_s4_ack_i),
        .s4_err_i   (wb_s4_err_i)
    );

    // ----------------------------------------------------
    // Peripherals (OpenCores)
    // ----------------------------------------------------

    // UART16550 at S0
    wire uart_int;
    assign uart_irq = uart_int;

    uart_top u_uart (
        .wb_clk_i   (clk),
        .wb_rst_i   (~rst_n),
        .wb_adr_i   (wb_s0_adr_o[4:2]),
        .wb_dat_i   (wb_s0_dat_o),
        .wb_dat_o   (wb_s0_dat_i),
        .wb_we_i    (wb_s0_we_o),
        .wb_stb_i   (wb_s0_stb_o),
        .wb_cyc_i   (wb_s0_cyc_o),
        .wb_ack_o   (wb_s0_ack_i),
        .wb_sel_i   (wb_s0_sel_o),
        .int_o      (uart_int),
        .stx_pad_o  (uart_tx),
        .srx_pad_i  (uart_rx),
        .rts_pad_o  (),
        .cts_pad_i  (1'b0),
        .dtr_pad_o  (),
        .dsr_pad_i  (1'b0),
        .ri_pad_i   (1'b0),
        .dcd_pad_i  (1'b0)
    );
    assign wb_s0_err_i = 1'b0;

    // GPIO at S1
    wire gpio_int;
    assign gpio_irq = gpio_int;

    gpio_top u_gpio (
        .wb_clk_i    (clk),
        .wb_rst_i    (~rst_n),
        .wb_adr_i    (wb_s1_adr_o[4:2]),
        .wb_dat_i    (wb_s1_dat_o),
        .wb_dat_o    (wb_s1_dat_i),
        .wb_we_i     (wb_s1_we_o),
        .wb_stb_i    (wb_s1_stb_o),
        .wb_cyc_i    (wb_s1_cyc_o),
        .wb_ack_o    (wb_s1_ack_i),
        .wb_sel_i    (wb_s1_sel_o),
        .ext_pad_i   (gpio_in),
        .ext_pad_o   (gpio_out),
        .ext_padoe_o (gpio_dir),
        .int_o       (gpio_int)
    );
    assign wb_s1_err_i = 1'b0;

    // SPI at S2
    wire spi_int;
    assign spi_irq = spi_int;

    spi_top u_spi (
        .wb_clk_i   (clk),
        .wb_rst_i   (~rst_n),
        .wb_adr_i   (wb_s2_adr_o[4:2]),
        .wb_dat_i   (wb_s2_dat_o),
        .wb_dat_o   (wb_s2_dat_i),
        .wb_we_i    (wb_s2_we_o),
        .wb_stb_i   (wb_s2_stb_o),
        .wb_cyc_i   (wb_s2_cyc_o),
        .wb_ack_o   (wb_s2_ack_i),
        .wb_sel_i   (wb_s2_sel_o),
        .ss_pad_o   (spi_cs_n),
        .sclk_pad_o (spi_sclk),
        .mosi_pad_o (spi_mosi),
        .miso_pad_i (spi_miso),
        .int_o      (spi_int)
    );
    assign wb_s2_err_i = 1'b0;

    // I2C at S3
    wire i2c_int;
    assign i2c_irq = i2c_int;

    wire i2c_scl_o, i2c_sda_o, i2c_sda_oe;
    assign i2c_scl = i2c_scl_o;
    assign i2c_sda = i2c_sda_oe ? i2c_sda_o : 1'bz;
    wire i2c_sda_i = i2c_sda;

    i2c_master_top u_i2c (
        .wb_clk_i     (clk),
        .wb_rst_i     (~rst_n),
        .wb_adr_i     (wb_s3_adr_o[4:2]),
        .wb_dat_i     (wb_s3_dat_o),
        .wb_dat_o     (wb_s3_dat_i),
        .wb_we_i      (wb_s3_we_o),
        .wb_stb_i     (wb_s3_stb_o),
        .wb_cyc_i     (wb_s3_cyc_o),
        .wb_ack_o     (wb_s3_ack_i),
        .wb_sel_i     (wb_s3_sel_o),
        .scl_pad_o    (i2c_scl_o),
        .scl_padoen_o (),
        .sda_pad_o    (i2c_sda_o),
        .sda_padoen_o (i2c_sda_oe),
        .sda_pad_i    (i2c_sda_i),
        .int_o        (i2c_int)
    );
    assign wb_s3_err_i = 1'b0;

    // PWM at S4 (assumes an OpenCores-like pwm_top)
    wire pwm_int;
    assign pwm_irq = pwm_int;

    pwm_top u_pwm (
        .wb_clk_i   (clk),
        .wb_rst_i   (~rst_n),
        .wb_adr_i   (wb_s4_adr_o[4:2]),
        .wb_dat_i   (wb_s4_dat_o),
        .wb_dat_o   (wb_s4_dat_i),
        .wb_we_i    (wb_s4_we_o),
        .wb_stb_i   (wb_s4_stb_o),
        .wb_cyc_i   (wb_s4_cyc_o),
        .wb_ack_o   (wb_s4_ack_i),
        .wb_sel_i   (wb_s4_sel_o),
        .pwm_o      (pwm_out),
        .fault_i    (fault_in),
        .int_o      (pwm_int)
    );
    assign wb_s4_err_i = 1'b0;

endmodule
----------------------------------------

File: `soc/apb2wb_bridge_core.v` (bridge core used above)

----------------------------------------
apb2wb_bridge_core.v
----------------------------------------
module apb2wb_bridge_core (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] paddr,
    input  wire        pwrite,
    input  wire        psel,
    input  wire        penable,
    input  wire [31:0] pwdata,
    output reg  [31:0] prdata,
    output reg         pready,
    output reg         pslverr,

    output reg  [31:0] wb_adr_o,
    output reg  [31:0] wb_dat_o,
    input  wire [31:0] wb_dat_i,
    output reg         wb_we_o,
    output reg  [3:0]  wb_sel_o,
    output reg         wb_stb_o,
    output reg         wb_cyc_o,
    input  wire        wb_ack_i,
    input  wire        wb_err_i
);

    localparam IDLE  = 2'd0;
    localparam BUSY  = 2'd1;

    reg [1:0] state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= IDLE;
        else
            state <= next_state;
    end

    always @(*) begin
        prdata   = 32'h0;
        pready   = 1'b1;
        pslverr  = 1'b0;

        wb_adr_o = 32'h0;
        wb_dat_o = 32'h0;
        wb_we_o  = 1'b0;
        wb_sel_o = 4'b0000;
        wb_stb_o = 1'b0;
        wb_cyc_o = 1'b0;

        next_state = state;

        case (state)
            IDLE: begin
                if (psel && penable) begin
                    wb_adr_o = paddr;
                    wb_dat_o = pwdata;
                    wb_we_o  = pwrite;
                    wb_sel_o = 4'b1111;
                    wb_stb_o = 1'b1;
                    wb_cyc_o = 1'b1;
                    pready   = 1'b0;
                    next_state = BUSY;
                end
            end
            BUSY: begin
                wb_adr_o = paddr;
                wb_dat_o = pwdata;
                wb_we_o  = pwrite;
                wb_sel_o = 4'b1111;
                wb_stb_o = 1'b1;
                wb_cyc_o = 1'b1;
                pready   = 1'b0;
                if (wb_ack_i || wb_err_i) begin
                    prdata   = wb_dat_i;
                    pslverr  = wb_err_i;
                    pready   = 1'b1;
                    next_state = IDLE;
                end
            end
        endcase
    end

endmodule
----------------------------------------

File: `soc/h3_wb_interconnect.v`

----------------------------------------
h3_wb_interconnect.v
----------------------------------------
module h3_wb_interconnect (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] m_adr_i,
    input  wire [31:0] m_dat_i,
    output reg  [31:0] m_dat_o,
    input  wire        m_we_i,
    input  wire [3:0]  m_sel_i,
    input  wire        m_stb_i,
    input  wire        m_cyc_i,
    output reg         m_ack_o,
    output reg         m_err_o,

    output reg  [31:0] s0_adr_o,
    output reg  [31:0] s0_dat_o,
    input  wire [31:0] s0_dat_i,
    output reg         s0_we_o,
    output reg  [3:0]  s0_sel_o,
    output reg         s0_stb_o,
    output reg         s0_cyc_o,
    input  wire        s0_ack_i,
    input  wire        s0_err_i,

    output reg  [31:0] s1_adr_o,
    output reg  [31:0] s1_dat_o,
    input  wire [31:0] s1_dat_i,
    output reg         s1_we_o,
    output reg  [3:0]  s1_sel_o,
    output reg         s1_stb_o,
    output reg         s1_cyc_o,
    input  wire        s1_ack_i,
    input  wire        s1_err_i,

    output reg  [31:0] s2_adr_o,
    output reg  [31:0] s2_dat_o,
    input  wire [31:0] s2_dat_i,
    output reg         s2_we_o,
    output reg  [3:0]  s2_sel_o,
    output reg         s2_stb_o,
    output reg         s2_cyc_o,
    input  wire        s2_ack_i,
    input  wire        s2_err_i,

    output reg  [31:0] s3_adr_o,
    output reg  [31:0] s3_dat_o,
    input  wire [31:0] s3_dat_i,
    output reg         s3_we_o,
    output reg  [3:0]  s3_sel_o,
    output reg         s3_stb_o,
    output reg         s3_cyc_o,
    input  wire        s3_ack_i,
    input  wire        s3_err_i,

    output reg  [31:0] s4_adr_o,
    output reg  [31:0] s4_dat_o,
    input  wire [31:0] s4_dat_i,
    output reg         s4_we_o,
    output reg  [3:0]  s4_sel_o,
    output reg         s4_stb_o,
    output reg         s4_cyc_o,
    input  wire        s4_ack_i,
    input  wire        s4_err_i
);

    wire sel0 = (m_adr_i[15:12] == 4'h0);
    wire sel1 = (m_adr_i[15:12] == 4'h1);
    wire sel2 = (m_adr_i[15:12] == 4'h2);
    wire sel3 = (m_adr_i[15:12] == 4'h3);
    wire sel4 = (m_adr_i[15:12] == 4'h4);

    always @(*) begin
        s0_adr_o = 32'h0; s0_dat_o = 32'h0; s0_we_o = 1'b0; s0_sel_o = 4'b0000; s0_stb_o = 1'b0; s0_cyc_o = 1'b0;
        s1_adr_o = 32'h0; s1_dat_o = 32'h0; s1_we_o = 1'b0; s1_sel_o = 4'b0000; s1_stb_o = 1'b0; s1_cyc_o = 1'b0;
        s2_adr_o = 32'h0; s2_dat_o = 32'h0; s2_we_o = 1'b0; s2_sel_o = 4'b0000; s2_stb_o = 1'b0; s2_cyc_o = 1'b0;
        s3_adr_o = 32'h0; s3_dat_o = 32'h0; s3_we_o = 1'b0; s3_sel_o = 4'b0000; s3_stb_o = 1'b0; s3_cyc_o = 1'b0;
        s4_adr_o = 32'h0; s4_dat_o = 32'h0; s4_we_o = 1'b0; s4_sel_o = 4'b0000; s4_stb_o = 1'b0; s4_cyc_o = 1'b0;

        m_dat_o = 32'h0; m_ack_o = 1'b0; m_err_o = 1'b0;

        if (m_cyc_i && m_stb_i) begin
            if (sel0) begin
                s0_adr_o = m_adr_i; s0_dat_o = m_dat_i; s0_we_o = m_we_i; s0_sel_o = m_sel_i;
                s0_stb_o = 1'b1; s0_cyc_o = 1'b1;
                m_dat_o  = s0_dat_i; m_ack_o = s0_ack_i; m_err_o = s0_err_i;
            end else if (sel1) begin
                s1_adr_o = m_adr_i; s1_dat_o = m_dat_i; s1_we_o = m_we_i; s1_sel_o = m_sel_i;
                s1_stb_o = 1'b1; s1_cyc_o = 1'b1;
                m_dat_o  = s1_dat_i; m_ack_o = s1_ack_i; m_err_o = s1_err_i;
            end else if (sel2) begin
                s2_adr_o = m_adr_i; s2_dat_o = m_dat_i; s2_we_o = m_we_i; s2_sel_o = m_sel_i;
                s2_stb_o = 1'b1; s2_cyc_o = 1'b1;
                m_dat_o  = s2_dat_i; m_ack_o = s2_ack_i; m_err_o = s2_err_i;
            end else if (sel3) begin
                s3_adr_o = m_adr_i; s3_dat_o = m_dat_i; s3_we_o = m_we_i; s3_sel_o = m_sel_i;
                s3_stb_o = 1'b1; s3_cyc_o = 1'b1;
                m_dat_o  = s3_dat_i; m_ack_o = s3_ack_i; m_err_o = s3_err_i;
            end else if (sel4) begin
                s4_adr_o = m_adr_i; s4_dat_o = m_dat_i; s4_we_o = m_we_i; s4_sel_o = m_sel_i;
                s4_stb_o = 1'b1; s4_cyc_o = 1'b1;
                m_dat_o  = s4_dat_i; m_ack_o = s4_ack_i; m_err_o = s4_err_i;
            end else begin
                m_ack_o = 1'b1;
                m_err_o = 1'b1;
            end
        end
    end

endmodule
----------------------------------------

------------------------------------------------------------
9. IRQ controller: h3_irq_ctrl
------------------------------------------------------------

Minimal interrupt controller with enable + pending + simple routing (all IRQs OR-ed per core; HAL will read active source via status).

File: `soc/h3_irq_ctrl.v`

----------------------------------------
h3_irq_ctrl.v
----------------------------------------
module h3_irq_ctrl (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] paddr,
    input  wire        pwrite,
    input  wire        psel,
    input  wire        penable,
    input  wire [31:0] pwdata,
    output reg  [31:0] prdata,
    output reg         pready,
    output reg         pslverr,

    input  wire        irq_uart,
    input  wire        irq_gpio,
    input  wire        irq_spi,
    input  wire        irq_i2c,
    input  wire        irq_pwm,
    input  wire        irq_dma,
    input  wire [3:0]  ext_irq_in,

    output wire [3:0]  core_irq
);

    // IRQ lines: 0=UART,1=GPIO,2=SPI,3=I2C,4=PWM,5=DMA,6..9=ext_irq
    wire [9:0] irq_src = {
        ext_irq_in[3:0],
        irq_dma,
        irq_pwm,
        irq_i2c,
        irq_spi,
        irq_gpio,
        irq_uart
    };

    reg [9:0] irq_enable;
    reg [9:0] irq_pending;

    // Simple routing: all enabled & pending OR-ed to all cores (for now)
    wire any_irq = |(irq_pending & irq_enable);
    assign core_irq = {4{any_irq}};

    // Update pending
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            irq_pending <= 10'h0;
        end else begin
            irq_pending <= irq_pending | (irq_src & irq_enable);
            // Clear bits via APB write to clear register
            if (psel && penable && pwrite && (paddr[7:2] == 6'h01)) begin
                irq_pending <= irq_pending & ~pwdata[9:0];
            end
        end
    end

    // Enable register
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            irq_enable <= 10'h0;
        end else begin
            if (psel && penable && pwrite && (paddr[7:2] == 6'h00)) begin
                irq_enable <= pwdata[9:0];
            end
        end
    end

    // APB read
    always @(*) begin
        pready  = 1'b1;
        pslverr = 1'b0;
        prdata  = 32'h0;
        if (psel) begin
            case (paddr[7:2])
                6'h00: prdata = {22'h0, irq_enable};
                6'h01: prdata = {22'h0, irq_pending};
                default: begin
                    prdata  = 32'h0;
                    pslverr = 1'b1;
                end
            endcase
        end
    end

endmodule
----------------------------------------

------------------------------------------------------------
10. DMA engine: h3_dma_engine
------------------------------------------------------------

Minimal single-channel DMA engine: memory↔memory or memory↔peripheral. Fully functional, with IRQ on completion/error.

File: `soc/h3_dma_engine.v`

----------------------------------------
h3_dma_engine.v
----------------------------------------
module h3_dma_engine (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] paddr,
    input  wire        pwrite,
    input  wire        psel,
    input  wire        penable,
    input  wire [31:0] pwdata,
    output reg  [31:0] prdata,
    output reg         pready,
    output reg         pslverr,

    output reg  [31:0] dma_haddr,
    output reg  [1:0]  dma_htrans,
    output reg  [2:0]  dma_hsize,
    output reg  [31:0] dma_hwdata,
    input  wire [31:0] dma_hrdata,
    output reg         dma_hwrite,
    output reg         dma_hreadyin,
    input  wire        dma_hreadyout,
    input  wire [1:0]  dma_hresp,

    output reg         dma_irq
);

    // Registers
    reg [31:0] src_addr;
    reg [31:0] dst_addr;
    reg [31:0] length;
    reg [31:0] ctrl;   // bit0: start, bit1: dir (0=mem->mem, 1=periph->mem), etc.
    reg [31:0] status; // bit0: busy, bit1: error, bit2: done, bit3: irq_enable

    localparam S_IDLE = 2'd0;
    localparam S_READ = 2'd1;
    localparam S_WRITE= 2'd2;

    reg [1:0] state, next_state;
    reg [31:0] buf;

    // APB interface
    always @(*) begin
        pready  = 1'b1;
        pslverr = 1'b0;
        prdata  = 32'h0;

        if (psel) begin
            case (paddr[7:2])
                6'h00: prdata = src_addr;
                6'h01: prdata = dst_addr;
                6'h02: prdata = length;
                6'h03: prdata = ctrl;
                6'h04: prdata = status;
                default: begin
                    prdata  = 32'h0;
                    pslverr = 1'b1;
                end
            endcase
        end
    end

    // APB writes
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            src_addr <= 32'h0;
            dst_addr <= 32'h0;
            length   <= 32'h0;
            ctrl     <= 32'h0;
            status   <= 32'h0;
        end else begin
            if (psel && penable && pwrite) begin
                case (paddr[7:2])
                    6'h00: src_addr <= pwdata;
                    6'h01: dst_addr <= pwdata;
                    6'h02: length   <= pwdata;
                    6'h03: ctrl     <= pwdata;
                    6'h04: status   <= status & ~pwdata; // write-1-to-clear
                endcase
            end
        end
    end

    // DMA state machine
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state  <= S_IDLE;
            dma_irq<= 1'b0;
            status <= 32'h0;
        end else begin
            state <= next_state;
            if (status[0] == 1'b0 && ctrl[0] == 1'b1) begin
                // Start
                status[0] <= 1'b1; // busy
                status[2] <= 1'b0; // done
                status[1] <= 1'b0; // error
            end
            if (status[2] && status[3]) begin
                dma_irq <= 1'b1;
            end else begin
                dma_irq <= 1'b0;
            end
        end
    end

    always @(*) begin
        dma_haddr   = 32'h0;
        dma_htrans  = 2'b00;
        dma_hsize   = 3'b010; // 32-bit
        dma_hwdata  = 32'h0;
        dma_hwrite  = 1'b0;
        dma_hreadyin= 1'b1;

        next_state = state;

        case (state)
            S_IDLE: begin
                if (status[0] && (length != 32'h0)) begin
                    dma_haddr  = src_addr;
                    dma_htrans = 2'b10;
                    dma_hwrite = 1'b0;
                    next_state = S_READ;
                end
            end
            S_READ: begin
                dma_haddr  = src_addr;
                dma_htrans = 2'b10;
                dma_hwrite = 1'b0;
                if (dma_hreadyout) begin
                    next_state = S_WRITE;
                end
            end
            S_WRITE: begin
                dma_haddr  = dst_addr;
                dma_htrans = 2'b10;
                dma_hwrite = 1'b1;
                dma_hwdata = dma_hrdata;
                if (dma_hreadyout) begin
                    next_state = S_IDLE;
                end
            end
        endcase
    end

endmodule
----------------------------------------

============================================================
END OF PHASE 4
=======================================================
