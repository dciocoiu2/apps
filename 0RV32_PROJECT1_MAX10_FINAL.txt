============================================================
PHASE 1 — FRESH START: TOOLCHAIN, REPO, AND ARDUINO-HEADER FOCUS
============================================================

Goal:
- Start from zero with a clean, reproducible environment.
- Lock in: DE10-Lite (MAX 10 10M50DAF484C7G) + Arduino headers as the *primary* SoC I/O interface.
- Install and verify:
  - Linux environment (VM or bare metal)
  - Quartus Lite for MAX 10
  - RISC-V GCC toolchain
  - Git + basic directory structure for the SoC project
- Make an explicit design rule: **all user-facing digital I/O uses the DE10-Lite Arduino headers**, not random GPIO pins or on-board LEDs/switches.

Reference:
- DE10-Lite has a MAX 10 10M50 and dedicated Arduino-compatible headers for GPIO/ADC[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://faculty-web.msoe.edu/johnsontimoj/Common/FILES/de10-lite.pdf?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054&citationId=1&citationId=2 "MSOE Faculty Web").
- We will treat those Arduino headers as the “MCU pinout” for the SoC.

------------------------------------------------------------
0. High-level design constraints (locked in now)
------------------------------------------------------------

These are invariants for ALL later phases:

- Board:
  - Terasic DE10-Lite with MAX 10 10M50DAF484C7G.

- Configuration model:
  - FPGA is configured **only into SRAM** via `.sof` over JTAG.
  - We do **not** program on-board configuration flash.
  - On power-cycle, the SoC disappears; we re-load the bitstream when needed.

- SoC I/O model:
  - All user-facing digital I/O (GPIO, SPI, I2C, UART, PWM, external interrupts) are mapped to the **Arduino-style headers** on the DE10-Lite[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://faculty-web.msoe.edu/johnsontimoj/Common/FILES/de10-lite.pdf?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054&citationId=1 "MSOE Faculty Web").
  - On-board LEDs, switches, keys may be exposed as *extras*, but the canonical/user pinout is Arduino headers.

- Philosophy:
  - Open-source IP only (Hazard3, OpenCores, or small custom RTL).
  - Industrial-capable: IRQ, DMA, advanced PWM/GPIO/I2C/SPI features, but always auditable and deterministic.
  - Arduino-like firmware UX via a C HAL.

These constraints will drive Phase 2 (memory + pin map), Phase 3 (SoC fabric), and especially Phase 8 (pin assignment to Arduino headers).

------------------------------------------------------------
1. Base OS environment
------------------------------------------------------------

Use a modern Linux environment (VM or bare metal). For example:

- Ubuntu 22.04 LTS (recommended)
- At least:
  - 4 GB RAM (8 GB+ nicer)
  - 30+ GB disk

Ensure the following packages are installed:

- Build essentials:
  - sudo apt update
  - sudo apt install -y build-essential git cmake python3 python3-pip

- Utilities:
  - sudo apt install -y curl unzip hexdump

------------------------------------------------------------
2. Quartus Lite for MAX 10 (DE10-Lite)
------------------------------------------------------------

1) Download Quartus Prime Lite Edition that supports MAX 10 devices.
   - Install Quartus Lite + MAX 10 device support following Intel’s installer.

2) After installation, ensure `quartus_sh` is in PATH, e.g.:

   - echo 'export PATH="/opt/intelFPGA_lite/23.1/quartus/bin:$PATH"' >> ~/.bashrc
   - source ~/.bashrc

3) Verify:

   - quartus_sh --version

4) Install USB-Blaster udev rules (if needed):

   - Create `/etc/udev/rules.d/51-usbblaster.rules` with Intel’s recommended rules.
   - Reload udev and replug the DE10-Lite.

5) Plug in DE10-Lite, run:

   - jtagconfig

   You should see the MAX 10 device detected.

------------------------------------------------------------
3. RISC-V toolchain (RV32IM bare-metal)
------------------------------------------------------------

We’ll use a standard GCC-based RISC-V bare-metal toolchain:

1) Install prebuilt toolchain (if available for your distro), or build from source. For example:

   - sudo apt install -y gcc-riscv64-unknown-elf

   If your distro uses a different triplet, adapt accordingly.

2) Verify:

   - riscv64-unknown-elf-gcc --version

3) For this project we’ll target RV32IM / ilp32. We’ll use flags like:

   - -march=rv32im -mabi=ilp32

We’ll standardize on the prefix:

- RISCV_PREFIX = riscv64-unknown-elf

but we’ll compile 32-bit code with `-march`/`-mabi`.

------------------------------------------------------------
4. Project root and repository layout
------------------------------------------------------------

Create a root directory for the entire SoC project:

- mkdir -p ~/h3_quad_de10lite
- cd ~/h3_quad_de10lite
- git init

We’ll use this top-level layout:

~/h3_quad_de10lite/
  soc/
    rtl/            # Verilog RTL for SoC + IP integration
    quartus/        # Quartus project tcl, qsf, sdc
    sw/
      boot_rom/     # Bootloader (UART-based, Instr SRAM loader)
      arduino_api/  # Arduino-like HAL library
      apps/         # User firmware examples (Phase 7+)
    docs/
      pinmap/       # Pin mapping docs, including Arduino headers on DE10-Lite
      memmap/       # Memory and register maps
      build/        # Build + usage documentation

Initialize basic directories:

- mkdir -p soc/rtl soc/quartus soc/sw/boot_rom soc/sw/arduino_api soc/sw/apps docs/pinmap docs/memmap docs/build

Add a minimal README capturing the key constraints:

File: ~/h3_quad_de10lite/README.md

- echo 'H3 Quad-Core SoC on DE10-Lite (Arduino Headers as Primary I/O)' > README.md
- echo '' >> README.md
- echo '- Board: DE10-Lite (MAX 10 10M50DAF484C7G)' >> README.md
- echo '- FPGA config: SRAM-only (.sof via JTAG), no flash' >> README.md
- echo '- CPU: Quad-core Hazard3 RV32IM' >> README.md
- echo '- Buses: AHB backbone, APB + Wishbone peripherals' >> README.md
- echo '- Peripherals: UART16550, SPI, I2C, GPIO, PWM, DMA, IRQ ctrl (OpenCores/custom)' >> README.md
- echo '- All user I/O via DE10-Lite Arduino headers' >> README.md

Commit:

- git add .
- git commit -m "Phase 1: initial repo layout and toolchain assumptions"

------------------------------------------------------------
5. Arduino headers on DE10-Lite (design rule)
------------------------------------------------------------

DE10-Lite provides a set of Arduino headers for GPIO/ADC interfacing[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://faculty-web.msoe.edu/johnsontimoj/Common/FILES/de10-lite.pdf?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054&citationId=1&citationId=2 "MSOE Faculty Web"). We will:

- Treat Arduino header pins as the canonical “MCU pins” of our SoC.
- Map:
  - GPIO, PWM outputs, SPI, I2C, UART pins to specific Arduino I/O pins.
- Document this thoroughly in:
  - docs/pinmap/arduino_de10lite_pinout.md

For now, just create the file and a placeholder heading; detailed mapping will be done in Phase 2/Phase 8 when we pin down exact FPGA pins:

- touch docs/pinmap/arduino_de10lite_pinout.md
- echo '# DE10-Lite Arduino Header Pin Mapping for H3 SoC' > docs/pinmap/arduino_de10lite_pinout.md

(We will fill this with a complete mapping once the SoC’s signal set is fully defined.)

------------------------------------------------------------
6. Sanity checks
------------------------------------------------------------

At the end of Phase 1, verify:

- `quartus_sh --version` works.
- `jtagconfig` detects the MAX 10 on DE10-Lite.
- `riscv64-unknown-elf-gcc --version` works.
- The directory structure under `~/h3_quad_de10lite/` matches what we defined.
- README.md exists and reflects:
  - SRAM-only configuration rule.
  - Arduino headers as primary I/O.

============================================================
END OF PHASE 1
============================================================
============================================================
PHASE 2 — MEMORY MAP, INTERRUPT MAP, AND ARDUINO-HEADER I/O MODEL
============================================================

Goal:
- Define a **complete, fixed memory map** for the SoC (no placeholders).
- Define the **interrupt architecture** (sources, controller, how they reach Hazard3 cores).
- Define a **logical Arduino header I/O model** for:
  - GPIO (with interrupts + debounce)
  - UART
  - SPI
  - I2C
  - PWM
  - Fault inputs / external interrupt lines
- All of this will be implemented concretely in later RTL phases and bound to **actual DE10-Lite Arduino pins** in Phase 8.

We will **not guess** the exact FPGA pin names in this phase; instead, we define the logical MCU pinout (D0/D1, SPI pins, etc.) and ensure the SoC exposes signals that can be cleanly mapped to those Arduino pads.

------------------------------------------------------------
0. Top-level SoC model (conceptual)
------------------------------------------------------------

SoC: “H3-Quad MCU”

- CPU:
  - 4 × Hazard3 RV32IM cores
- Buses:
  - AHB-Lite backbone (Hazard3 data + instruction masters, DMA master)
  - AHB→APB bridge (for low-speed peripheral CSRs)
  - APB→Wishbone bridge (to talk to OpenCores Wishbone peripherals)
- Memories:
  - Boot ROM (AHB, 16 KB, @0x0000_0000)
  - Instruction SRAM (AHB, 64 KB, @0x0001_0000)
  - Data SRAM (AHB, 64 KB, @0x1000_0000)
- System services:
  - IRQ controller (APB-mapped, routes peripheral IRQs to cores)
  - DMA controller (AHB master, APB/WB-configured)
- Peripherals (APB→WB):
  - UART16550
  - SPI master
  - I2C master
  - GPIO (with interrupts)
  - PWM (multi-channel, with advanced features via RTL)
- I/O:
  - All main I/O signals exported as “MCU pins” intended to be driven to DE10-Lite Arduino headers.

------------------------------------------------------------
1. Global address map (final, not a placeholder)
------------------------------------------------------------

We define the **static 32-bit address space** as follows:

1) **Boot ROM** (AHB, execute-only):
   - Base:  0x0000_0000
   - Size:  16 KB
   - Range: 0x0000_0000 – 0x0000_3FFF
   - Contents: UART bootloader code (Phase 5), RISC-V RV32IM.

2) **Instruction SRAM** (AHB, executable):
   - Base:  0x0001_0000
   - Size:  64 KB
   - Range: 0x0001_0000 – 0x0001_FFFF
   - Contents: user firmware loaded over UART (Phase 5/9).

3) **Data SRAM** (AHB, read/write):
   - Base:  0x1000_0000
   - Size:  64 KB
   - Range: 0x1000_0000 – 0x1000_FFFF
   - Usage: runtime stack, global/static data, heap (if any).

4) **APB / peripheral region** (AHB→APB bridge window):
   - Base:  0x4000_0000
   - Size:  512 KB block reserved (more than we need for now).
   - Actual used sub-ranges (each 4 KB aligned):

   - 0x4000_0000 – 0x4000_0FFF : UART16550
   - 0x4000_1000 – 0x4000_1FFF : GPIO
   - 0x4000_2000 – 0x4000_2FFF : SPI master
   - 0x4000_3000 – 0x4000_3FFF : I2C master
   - 0x4000_4000 – 0x4000_4FFF : PWM
   - 0x4000_5000 – 0x4000_5FFF : IRQ controller
   - 0x4000_6000 – 0x4000_6FFF : DMA controller

   The remaining space `0x4000_7000`–`0x4007_FFFF` is reserved for future peripherals (timers, extra UARTs, etc.).

5) **Reserved regions**:
   - `0x2000_0000` – `0x3FFF_FFFF`: reserved for future external memories / mapping.
   - `0x8000_0000` and above: not used in this SoC; reserved for future on-chip expansion or external bus mapping.

This map will be honored **exactly** in RTL and software.

------------------------------------------------------------
2. Interrupt architecture
------------------------------------------------------------

We want:

- Interrupt-driven UART, GPIO, DMA, etc.
- A central **IRQ controller** that collects peripheral interrupts and feeds them to Hazard3 cores.
- A simple, deterministic scheme suitable for bare-metal firmware.

We define:

1) **Interrupt sources (lines)**

- IRQ0: UART16550
- IRQ1: GPIO
- IRQ2: SPI master
- IRQ3: I2C master
- IRQ4: PWM
- IRQ5: DMA controller
- IRQ6–IRQ15: reserved for future (timers, extra UARTs, etc.)

2) **IRQ controller (h3_irq_ctrl)**

- APB-mapped at `0x4000_5000`.
- Exposes:
  - Pending register
  - Enable/mask register
  - Per-core routing/masking (simplified)
- Implements up to 16 interrupt lines internally.
- Aggregates them into:

  - For simplicity, a single external interrupt line per core:
    - CORE0_IRQ_EXT
    - CORE1_IRQ_EXT
    - CORE2_IRQ_EXT
    - CORE3_IRQ_EXT

- Hazard3 cores will be configured so that this external interrupt maps to the standard machine/external interrupt cause (through CSRs).

3) **Interrupt priority / routing**

- Phase 3/4 will implement:
  - A simple fixed priority scheme (IRQ0 highest, IRQ15 lowest) inside h3_irq_ctrl.
  - A register that reports the active IRQ ID.
  - Per-core enable bits (so some cores can be “quiet”).

Software model (Phase 6):
- `irq_init()` configures the controller.
- `irq_enable_line(line)` enables a specific IRQ line globally.
- `irq_route_to_core(line, core_id)` decides which core receives that line.
- The HAL will set up an interrupt handler table in RAM and a single trap handler.

------------------------------------------------------------
3. DMA architecture
------------------------------------------------------------

We want:

- DMA that can move data between:
  - Memory ↔ peripherals (e.g., UART RX/TX FIFO, SPI FIFO)
  - Memory ↔ memory (Instr/Data SRAM)

We define:

1) **DMA controller (DMA0)**

- APB-mapped CSRs at `0x4000_6000`.
- AHB master port to access Boot ROM, Instruction SRAM, Data SRAM, and the APB/WB peripheral window (through bus hierarchy).
- Internally:
  - One or more DMA channels (we’ll start with 1 channel for clarity).
  - Control registers:
    - SRC_ADDR, DST_ADDR, LEN, CTRL, STATUS, IRQ_ENABLE
  - Supports:
    - Incrementing addresses for memory.
    - Optional fixed destination/source for peripheral FIFOs.

2) **DMA IRQ**

- DMA0 uses IRQ5 to signal:
  - Completion.
  - Error/abort.

3) **Usage expectations**

- Early boot (Boot ROM): we will **not** depend on DMA; the bootloader will stay simple and polling-based.
- Application firmware (Phase 7+): can use DMA for:
  - High throughput UART RX/TX.
  - SPI bursts.
  - Buffered logging or streaming.

------------------------------------------------------------
4. Peripherals: register map granularity (non-placeholder)
------------------------------------------------------------

We fix the **base addresses** here and commit to them. Exact internal register bits will follow from OpenCores specs + our own wrappers in Phase 4 and HAL in Phase 6.

1) UART16550 @ 0x4000_0000

- Typical 16550 register file in 8-bit lanes, but we will access via 32-bit words at:
  - 0x4000_0000: RBR/THR/DLL
  - 0x4000_0004: IER/DLM
  - 0x4000_0008: IIR/FCR
  - 0x4000_000C: LCR
  - 0x4000_0010: MCR
  - 0x4000_0014: LSR
  - 0x4000_0018: MSR
  - 0x4000_001C: SCR
- Interrupt output:
  - `uart_irq` → IRQ0 in h3_irq_ctrl.

2) GPIO @ 0x4000_1000

- Core registers (examples, exact names depend on OpenCores GPIO):
  - 0x4000_1000: DATA_OUT
  - 0x4000_1004: DATA_DIR
  - 0x4000_1008: DATA_IN
  - 0x4000_100C: IRQ_MASK
  - 0x4000_1010: IRQ_TYPE (edge/level, rising/falling)
  - 0x4000_1014: IRQ_STATUS
  - 0x4000_1018: (optional) DEBOUNCE_CFG
- Interrupt output:
  - `gpio_irq` → IRQ1.

3) SPI master @ 0x4000_2000

- Registers (typical OpenCores SPI):
  - 0x4000_2000: RX/TX data
  - 0x4000_2004: Control (CPOL, CPHA, bits per word, enable, interrupt, CS mode)
  - 0x4000_2008: Status (busy, RX ready, TX empty, IRQ flags)
  - 0x4000_200C: Divider (SCLK rate)
  - 0x4000_2010: Chip select / manual CS override
- Interrupt output:
  - `spi_irq` → IRQ2.

4) I2C master @ 0x4000_3000

- OpenCores I2C standard map:
  - 0x4000_3000: PRER_LO (prescaler low)
  - 0x4000_3004: PRER_HI
  - 0x4000_3008: CTR (enable, interrupt enable)
  - 0x4000_300C: TXR/RXR
  - 0x4000_3010: CR/SR (start/stop, read/write, ACK/NACK, arbitration lost, TIP, etc.)
- Interrupt output:
  - `i2c_irq` → IRQ3.

5) PWM @ 0x4000_4000

- We define a richer register set:
  - Per channel (0..3):
    - PERIOD
    - DUTY
    - PHASE
    - DEADTIME
    - CTRL (enable, polarity, fault behavior)
  - Global:
    - FAULT_STATUS
    - FAULT_MASK
- Interrupt output:
  - `pwm_irq` → IRQ4.
- Fault inputs:
  - External signals from Arduino header (e.g., emergency stop input).

6) IRQ controller @ 0x4000_5000

- Registers:
  - PENDING
  - ENABLE
  - ROUTE_CORE0
  - ROUTE_CORE1
  - ROUTE_CORE2
  - ROUTE_CORE3
  - CLAIM/COMPLETE style or simple “active IRQ ID” field.

7) DMA controller @ 0x4000_6000

- Registers:
  - CH0_SRC_ADDR
  - CH0_DST_ADDR
  - CH0_LEN
  - CH0_CTRL (start, direction, increment flags)
  - CH0_STATUS (busy, error)
  - CH0_IRQ_ENABLE

------------------------------------------------------------
5. Logical Arduino I/O model (non-skeletal, but board-pin-agnostic)
------------------------------------------------------------

We must avoid inventing fake DE10-Lite pin numbers; instead, we define the **_irq` → IRQ0 in h3_irq_ctrl.

2) GPIO @ 0x4000_1000

- Core registers (examples, exact names depend on OpenCores GPIO):
  - 0x4000_1000: DATA_OUT
  - 0x4000_1004: DATA_DIR
  - 0x4000_1008: DATA_IN
  - 0x4000_100C: IRQ_MASK
  - 0x4000_1010: IRQ_TYPE (edge/level, rising/falling)
  - 0x4000_1014: IRQ_STATUS
  - 0x4000_1018: (optional) DEBOUNCE_CFG
- Interrupt output:
  - `gpio_irq` → IRQ1.

3) SPI master @ 0x4000_2000

- Registers (typical OpenCores SPI):
  - 0x4000_2000: RX/TX data
  - 0x4000_2004: Control (CPOL, CPHA, bits per word, enable, interrupt, CS mode)
  - 0x4000_2008: Status (busy, RX ready, TX empty, IRQ flags)
  - 0x4000_200C: Divider (SCLK rate)
  - 0x4000_2010: Chip select / manual CS override
- Interrupt output:
  - `spi_irq` → IRQ2.

4) I2C master @ 0x4000_3000

- OpenCores I2C standard map:
  - 0x4000_3000: PRER_LO (prescaler low)
  - 0x4000_3004: PRER_HI
  - 0x4000_3008: CTR (enable, interrupt enable)
  - 0x4000_300C: TXR/RXR
  - 0x4000_3010: CR/SR (start/stop, read/write, ACK/NACK, arbitration lost, TIP, etc.)
- Interrupt output:
  - `i2c_irq` → IRQ3.

5) PWM @ 0x4000_4000

- We define a richer register set:
  - Per channel (0..3):
    - PERIOD
    - DUTY
    - PHASE
    - DEADTIME
    - CTRL (enable, polarity, fault behavior)
  - Global:
    - FAULT_STATUS
    - FAULT_MASK
- Interrupt output:
  - `pwm_irq` → IRQ4.
- Fault inputs:
  - External signals from Arduino header (e.g., emergency stop input).

6) IRQ controller @ 0x4000_5000

- Registers:
  - PENDING
  - ENABLE
  - ROUTE_CORE0
  - ROUTE_CORE1
  - ROUTE_CORE2
  - ROUTE_CORE3
  - CLAIM/COMPLETE style or simple “active IRQ ID” field.

7) DMA controller @ 0x4000_6000

- Registers:
  - CH0_SRC_ADDR
  - CH0_DST_ADDR
  - CH0_LEN
  - CH0_CTRL (start, direction, increment flags)
  - CH0_STATUS (busy, error)
  - CH0_IRQ_ENABLE

------------------------------------------------------------
5. Logical Arduino I/O model (non-skeletal, but board-pin-agnostic)
------------------------------------------------------------

We must avoid inventing fake DE10-Lite pin numbers; instead, we define the **MCU-side logical pins** that will later be mapped to physical Arduino header pads on the DE10-Lite.

1) Logical Arduino digital pins

We define 16 logical digital pins:

- D0..D15 → 16 GPIO-capable pins.

The SoC will expose:

- `gpio_out[15:0]`
- `gpio_in[15:0]`
- `gpio_dir[15:0]`

These 16 bits will be wired to **Arduino header digital pins** in Phase 8.

2) UART pins

We define:

- `uart_rx` and `uart_tx` as the SoC UART pins.

They will be assigned to a pair of Arduino digital pins (e.g., D0/D1) in Phase 8.

3) SPI pins

We define:

- `spi_sclk`
- `spi_mosi`
- `spi_miso`
- `spi_cs[3:0]` (4 chip-selects)

They will be mapped to Arduino digital pins that are typically used for SPI (e.g., D10–D13 style mapping, but we’ll respect DE10-Lite’s actual Arduino header capabilities in Phase 8).

4) I2C pins

We define:

- `i2c_scl`
- `i2c_sda` (bidirectional)

These will be mapped to Arduino header pins typically reserved for I2C (SCL/SDA signals).

5) PWM outputs

We define:

- `pwm_out[3:0]` (4 PWM channels)

These will be mapped to Arduino digital pins that hardware users can treat as PWM pins.

6) Fault inputs / extra interrupt lines

We define:

- `fault_in[3:0]` — external fault lines (from Arduino header pins) for PWM kill/emergency stop.
- `ext_irq_in[3:0]` — extra external interrupt lines (optional) for future use (e.g., dedicated external IRQ pins independent of GPIO).

7) Debounce and edge detection

- Debounce will be implemented either:
  - Inside the GPIO core (if supported), or
  - In a small wrapper that processes `gpio_in[15:0]` before GPIO registers see changes.
- GPIO interrupts can be configured per pin for rising/falling/both edges via GPIO registers.

------------------------------------------------------------
6. CPU view vs. board view (how firmware sees pins)
------------------------------------------------------------

From **firmware’s perspective**, using the Arduino-like HAL (Phase 6):

- `pinMode(pin, mode)` uses:
  - `pin` ∈ [0..15] mapping to `gpio_*[15:0]`.
- `digitalWrite(pin, value)` and `digitalRead(pin)` operate on `gpio_*[15:0]`.
- `Serial` uses `uart_rx/uart_tx` pins (logical mapping documented).
- `SPI` uses `spi_sclk`, `spi_mosi`, `spi_miso`, `spi_cs[x]`.
- `Wire` uses `i2c_scl`, `i2c_sda`.
- `analogWrite(pin, value)` uses PWM outputs mapped to specific pins.

In **docs/pinmap/arduino_de10lite_pinout.md**, we will later fill in:

- A table: logical MCU pin (D0, D1, etc.) → DE10-Lite Arduino header pin labeling → FPGA pin name.

Phase 8 will implement the exact `set_location_assignment` constraints using Quartus and the official DE10-Lite documentation.

------------------------------------------------------------
7. Summary of committed interfaces for later phases
------------------------------------------------------------

- **Memory map** is fully specified and will not change:
  - ROM, Instr SRAM, Data SRAM, and all APB peripheral bases fixed.

- **Interrupt model**:
  - IRQ0–IRQ5 reserved for UART, GPIO, SPI, I2C, PWM, DMA.
  - IRQ controller at 0x4000_5000 feeds 1 external interrupt per Hazard3 core.

- **DMA model**:
  - Single DMA engine at 0x4000_6000 with AHB master access to all important regions.

- **Arduino I/O model**:
  - 16 GPIO pins (D0..D15).
  - Dedicated signals for UART, SPI (with 4 CS), I2C, 4 PWM outputs, 4 fault inputs, and optional external interrupt lines.
  - These will be physically mapped to DE10-Lite Arduino header pads in Phase 8, with documentation.

All subsequent phases (3–9+) will respect this structure exactly.

============================================================
END OF PHASE 2
============================================================
============================================================
PHASE 3 — SOC MICROARCHITECTURE AND TOP-LEVEL SIGNAL SET
============================================================

Goal:
- Define the **complete SoC microarchitecture** with all blocks, buses, and connections.
- Fix the **top-level RTL module interface** for the SoC:
  - Includes all signals we will later bind to DE10-Lite Arduino headers.
- Define the **internal module hierarchy** and **bus roles** (masters/slaves).
- Ensure this design matches the Phase 2 memory map and interrupt/DMA model.

This phase is purely about **structure** and **interfaces**, but with enough precision that Phase 4 (RTL integration) can be written without guessing.

------------------------------------------------------------
0. SoC overview
------------------------------------------------------------

SoC name: `h3_quad_mcu`

Core ideas:

- 4 × Hazard3 RV32IM cores.
- AHB-Lite as the main system bus:
  - CPU cores as AHB masters.
  - DMA engine as an additional AHB master.
  - Memories (Boot ROM, Instr SRAM, Data SRAM) and AHB→APB bridge as AHB slaves.
- APB bus for control/status registers of system components:
  - IRQ controller, DMA control, APB→WB bridge.
- Wishbone B3 for OpenCores peripherals:
  - UART16550, GPIO, SPI, I2C, PWM.
- All user I/O signals (GPIO, UART, SPI, I2C, PWM, fault lines) exposed as top-level ports, intended for mapping to DE10-Lite Arduino headers.

------------------------------------------------------------
1. Top-level SoC module interface (final)
------------------------------------------------------------

Top-level module: `h3_quad_mcu_top`

Clocking and reset:
- `input  wire clk`       — system clock, from board (later: DE10-Lite 50 MHz or PLL output).
- `input  wire rst_n`     — active-low system reset.

Logical Arduino I/O (from Phase 2):

1) GPIO (D0..D15)
- `input  wire  [15:0] gpio_in`   — sampled external pin levels.
- `output wire  [15:0] gpio_out`  — driven outputs.
- `output wire  [15:0] gpio_dir`  — output enable/direction (1 = output, 0 = input).

These three vectors will ultimately be tied to actual FPGA I/O buffers mapped to Arduino header pins.

2) UART
- `input  wire uart_rx`
- `output wire uart_tx`

3) SPI
- `output wire       spi_sclk`
- `output wire       spi_mosi`
- `input  wire       spi_miso`
- `output wire [3:0] spi_cs_n`   — 4 chip-select outputs, typically active-low.

4) I2C
- `inout  wire i2c_sda`
- `output wire i2c_scl`

5) PWM outputs
- `output wire [3:0] pwm_out`

6) Fault inputs for PWM
- `input  wire [3:0] fault_in`

7) Extra external interrupts (optional, reserved for future)
- `input  wire [3:0] ext_irq_in`

This interface is **fixed** and will be implemented exactly in Phase 4 RTL, then bound to real DE10-Lite Arduino header pins in Phase 8.

------------------------------------------------------------
2. Internal module hierarchy
------------------------------------------------------------

The SoC is broken into these major blocks:

- `h3_quad_core_cluster`
  - Instantiates 4 Hazard3 cores.
  - Provides their AHB master interfaces (instruction + data).
  - Receives per-core external interrupt lines from IRQ controller.

- `h3_ahb_matrix`
  - Multi-master AHB interconnect.
  - Masters:
    - 4 × Hazard3 cores.
    - 1 × DMA engine.
  - Slaves:
    - Boot ROM.
    - Instruction SRAM.
    - Data SRAM.
    - AHB→APB bridge.

- `h3_ahb_boot_rom`
  - AHB slave.
  - 16 KB ROM at 0x0000_0000.
  - Initialized from `boot_rom.hex` via $readmemh.

- `h3_ahb_instr_sram`
  - AHB slave.
  - 64 KB synchronous RAM at 0x0001_0000.
  - Executable region for user firmware.

- `h3_ahb_data_sram`
  - AHB slave.
  - 64 KB synchronous RAM at 0x1000_0000.
  - Read/write data memory for all cores and DMA.

- `h3_ahb_to_apb`
  - AHB slave, APB master.
  - Decodes the APB window at 0x4000_0000.
  - Forwards accesses into APB bus for peripheral CSRs.

- `h3_apb_subsystem`
  - APB interconnect + APB slaves:
    - IRQ controller (h3_irq_ctrl) @ 0x4000_5000
    - DMA control registers (h3_dma_ctrl_if) @ 0x4000_6000
    - APB→Wishbone bridge (h3_apb2wb) @ 0x4000_0000 region for actual Wishbone peripherals.
  - Provides APB-level decode so each APB peripheral sees only its address region.

- `h3_apb2wb_bridge`
  - APB slave for the region 0x4000_0000 - 0x4000_4FFF.
  - Single Wishbone master interface.

- `h3_wb_interconnect`
  - Wishbone B3 interconnect.
  - 1 master (APB2WB bridge).
  - 5 slaves:
    - UART16550 @ 0x4000_0000
    - GPIO @ 0x4000_1000
    - SPI @ 0x4000_2000
    - I2C @ 0x4000_3000
    - PWM @ 0x4000_4000

- `uart16550_core` (OpenCores)
- `gpio_core` (OpenCores, possibly with debounce wrapper)
- `spi_core` (OpenCores SPI master)
- `i2c_core` (OpenCores I2C master)
- `pwm_core` (OpenCores PWM or extended PWM module for dead-time/phase/fault support)

- `h3_irq_ctrl`
  - Collects IRQ lines from UART, GPIO, SPI, I2C, PWM, DMA.
  - Routes them to 4 external interrupt lines, one per Hazard3 core.
  - APB-mapped registers for pending, enable, routing, and acknowledge/complete.

- `h3_dma_engine`
  - DMA core handling memory↔memory and memory↔peripheral transfers.
  - AHB master for data movement.
  - APB/Wishbone front-end for configuration at 0x4000_6000.
  - Raises `dma_irq` to IRQ controller on completion or error.

------------------------------------------------------------
3. AHB interconnect details
------------------------------------------------------------

AHB masters:

- M0: Hazard3 core 0
- M1: Hazard3 core 1
- M2: Hazard3 core 2
- M3: Hazard3 core 3
- M4: DMA engine

AHB slaves:

- S0: Boot ROM       (0x0000_0000 – 0x0000_3FFF)
- S1: Instr SRAM     (0x0001_0000 – 0x0001_FFFF)
- S2: Data SRAM      (0x1000_0000 – 0x1000_FFFF)
- S3: AHB→APB bridge (0x4000_0000 – 0x4007_FFFF)

AHB address decoding:

- Address[31:16] used for coarse region decode:
  - 0x0000 → S0 (Boot ROM)
  - 0x0001 → S1 (Instr SRAM)
  - 0x1000 → S2 (Data SRAM)
  - 0x4000–0x4007 → S3 (AHB→APB bridge)
- Other regions default to decode-error (HRESP error).

AHB arbitration:

- Simple fixed-priority or round-robin scheme among the five masters.
- DMA is treated as a peer (not higher privileged), but implementation details can favor CPU latency or DMA throughput as needed.
- All masters are fully synchronous to the same system clock.

Hazard3 core integration:

- Each Hazard3 core uses:
  - AHB master for instruction fetch (I-port).
  - AHB master for data access (D-port).
- To simplify the fabric, we aggregate I+D ports into a single master per core via a lightweight arbiter close to the core, so `h3_ahb_matrix` sees **one master per core**.

------------------------------------------------------------
4. APB subsystem and decode
------------------------------------------------------------

AHB→APB bridge:

- Appears as a single AHB slave at 0x4000_0000–0x4007_FFFF.
- When an address hits this region, it is forwarded as APB transaction with:
  - PADDR = HADDR (truncated)
  - PWRITE, PSEL, PENABLE, PWDATA, etc. from AHB signals.

APB slaves and their ranges:

- APB0: APB→WB bridge   : 0x4000_0000 – 0x4000_4FFF
- APB1: IRQ controller  : 0x4000_5000 – 0x4000_5FFF
- APB2: DMA controller  : 0x4000_6000 – 0x4000_6FFF

APB decoding inside `h3_apb_subsystem`:

- Uses PADDR[15:12] to select one of:
  - 0x0 → APB→WB bridge
  - 0x1 → still inside APB→WB window (used by Wishbone decode)
  - 0x2 → APB→WB
  - 0x3 → APB→WB
  - 0x4 → APB→WB
  - 0x5 → IRQ controller
  - 0x6 → DMA controller
  - Others → APB decode error

The APB→WB bridge will do **fine-grain decode inside the 0x4000_0000–0x4000_4FFF region** via the Wishbone address bus.

------------------------------------------------------------
5. Wishbone interconnect and peripheral attachment
------------------------------------------------------------

APB→Wishbone bridge:

- APB slave, Wishbone master.
- Handles single transactions at a time:
  - Converts APB transactions to Wishbone cycles.
  - Holds off APB `PREADY` until Wishbone `ACK` arrives.

Wishbone address space mapping (from CPU perspective, but via APB→WB):

- UART16550:
  - Base: 0x4000_0000
  - Wishbone sees addresses offset accordingly.
- GPIO:
  - Base: 0x4000_1000
- SPI:
  - Base: 0x4000_2000
- I2C:
  - Base: 0x4000_3000
- PWM:
  - Base: 0x4000_4000

Wishbone interconnect:

- Master: APB→WB bridge.
- Slaves: 5 cores.
- Decode on address bits (e.g., [15:12]) to select the peripheral.
- Each peripheral has:
  - wb_adr_i/wb_dat_i/wb_dat_o/wb_we_i/wb_sel_i/wb_stb_i/wb_cyc_i/wb_ack_o/wb_err_o.

Peripherals:

- UART16550:
  - IRQ line: `uart_irq`.
  - External pins: `uart_rx`, `uart_tx`.
- GPIO:
  - IRQ line: `gpio_irq`.
  - External pins:
    - `gpio_in[15:0]` → external inputs.
    - `gpio_out[15:0]` / `gpio_dir[15:0]` → external outputs/dir.
- SPI:
  - IRQ line: `spi_irq`.
  - External pins: `spi_sclk`, `spi_mosi`, `spi_miso`, `spi_cs_n[3:0]`.
- I2C:
  - IRQ line: `i2c_irq`.
  - External pins: `i2c_scl`, `i2c_sda`.
- PWM:
  - IRQ line: `pwm_irq`.
  - External pins: `pwm_out[3:0]`, `fault_in[3:0]`.

------------------------------------------------------------
6. Interrupt controller wiring
------------------------------------------------------------

Interrupt sources:

- From peripherals:
  - `uart_irq`
  - `gpio_irq`
  - `spi_irq`
  - `i2c_irq`
  - `pwm_irq`
- From DMA:
  - `dma_irq`
- Optionally from external interrupt pins:
  - Could be integrated via GPIO or dedicated lines; for now, external interrupts via GPIO’s edge detection will be the main mechanism.

Interrupt controller (`h3_irq_ctrl`):

- Inputs:
  - 16 IRQ lines, of which we use:
    - IRQ0 = uart_irq
    - IRQ1 = gpio_irq
    - IRQ2 = spi_irq
    - IRQ3 = i2c_irq
    - IRQ4 = pwm_irq
    - IRQ5 = dma_irq
    - IRQ6..IRQ15 = 0 or reserved.
- Outputs:
  - 4 lines to cores:
    - `core0_ext_irq`
    - `core1_ext_irq`
    - `core2_ext_irq`
    - `core3_ext_irq`
- APB CSRs at 0x4000_5000 used for:
  - Enable/mask per IRQ line.
  - Route configuration (which core(s) see which lines).
  - Pending status and claim/complete or acknowledge semantics.

Hazard3 integration:

- Each Hazard3 core’s external interrupt port is wired to `coreN_ext_irq`.
- Firmware uses standard RISC-V M-mode CSRs to handle machine external interrupts.
- A single trap handler dispatches to per-IRQ handlers using the IRQ controller’s status registers.

------------------------------------------------------------
7. DMA engine wiring
------------------------------------------------------------

DMA engine (`h3_dma_engine`):

- AHB master:
  - Connects to `h3_ahb_matrix` as master M4.
  - Issues read/write cycles to:
    - Instr SRAM
    - Data SRAM
    - APB window (to peripheral FIFOs via AHB→APB→WB path).
- APB control interface:
  - Mapped at 0x4000_6000.
  - Exposes:
    - SRC_ADDR, DST_ADDR, LEN, CTRL, STATUS, IRQ_ENABLE.
- Interrupt output:
  - `dma_irq` → IRQ5 input of `h3_irq_ctrl`.

Intended usage:

- Memory↔memory copies (e.g., fast buffer moves).
- Peripheral↔memory transfers (e.g., UART RX into ring buffer, SPI burst to memory).
- Integration with HAL in Phase 6 for asynchronous I/O.

------------------------------------------------------------
8. Boot ROM and boot flow (architectural level only)
------------------------------------------------------------

Boot ROM:

- `h3_ahb_boot_rom` is an AHB slave at 0x0000_0000.
- ROM contents are initialized from `boot_rom.hex` produced in Phase 5.
- All cores reset to PC=0x0000_0000.
- For simplicity, **core 0** will execute the bootloader; other cores can park in a wait loop until firmware configures them.

Bootloader responsibilities (later phases):

- Initialize basic CSRs, stack, and UART.
- Receive firmware over UART.
- Write firmware to Instr SRAM at 0x0001_0000.
- Jump to 0x0001_0000 and start execution.
- Other cores may be started via software coordination later.

------------------------------------------------------------
9. How this ties to the DE10-Lite Arduino headers
------------------------------------------------------------

At this phase, we’ve fixed the **logical signal set**:

- `gpio_in/out/dir[15:0]`
- `uart_rx/uart_tx`
- `spi_sclk/spi_mosi/spi_miso/spi_cs_n[3:0]`
- `i2c_scl/i2c_sda`
- `pwm_out[3:0]`
- `fault_in[3:0]`

Phase 8 will:

- Map each of these signals to specific DE10-Lite Arduino header pins based on the board’s official pinout.
- Document the mapping in `docs/pinmap/arduino_de10lite_pinout.md`.
- Provide Quartus `.qsf` pin assignments.

From the SoC and firmware perspective, these signals are now **fully defined and stable**.

============================================================
END OF PHASE 3
============================================================
============================================================
PHASE 4 — FULL RTL INTEGRATION (CORES, AHB/APB/WISHBONE, PERIPHERALS, IRQ, DMA)
============================================================

Goal:
- Provide a single, coherent RTL integration of:
  - Quad Hazard3 core cluster
  - AHB matrix (multi-master → slaves)
  - Boot ROM, Instruction SRAM, Data SRAM
  - AHB→APB bridge
  - APB subsystem with:
    - APB→Wishbone bridge
    - Wishbone interconnect
    - OpenCores UART16550, GPIO, SPI, I2C, PWM
    - IRQ controller
    - DMA controller front-end
- Expose all logical I/O signals that will go to the DE10-Lite Arduino headers:
  - GPIO, UART, SPI, I2C, PWM, fault inputs
- No placeholders or skeletons: every module here can be dropped into `soc/rtl/` and wired.

NOTE:
- This phase assumes:
  - You have the Hazard3 core RTL as `hazard3_core.v` (or similar) in `soc/rtl/hazard3/`.
  - You cloned OpenCores peripherals under `soc/rtl/opencores/` (as discussed earlier).
- Module names for OpenCores may differ slightly in their repos; adjust if needed, but the structure and wiring here are complete.

------------------------------------------------------------
1. Directory layout for RTL
------------------------------------------------------------

Under `~/h3_quad_de10lite/soc/rtl`:

- hazard3/
  - hazard3_core.v         (CPU core)
- opencores/
  - uart16550/             (OpenCores UART)
  - gpio/
  - spi_master/
  - i2c/
  - pwm/
- soc/
  - h3_quad_mcu_top.v
  - h3_quad_core_cluster.v
  - h3_ahb_matrix.v
  - h3_ahb_boot_rom.v
  - h3_ahb_instr_sram.v
  - h3_ahb_data_sram.v
  - h3_ahb_to_apb.v
  - h3_apb_subsystem.v
  - h3_apb2wb_bridge.v
  - h3_wb_interconnect.v
  - h3_irq_ctrl.v
  - h3_dma_engine.v

Below I’ll give you all the SoC RTL modules (not the individual OpenCores IP files, which you already have from their repos).

------------------------------------------------------------
2. Top-level SoC: h3_quad_mcu_top
------------------------------------------------------------

File: `soc/h3_quad_mcu_top.v`

----------------------------------------
h3_quad_mcu_top.v
----------------------------------------
module h3_quad_mcu_top (
    input  wire         clk,
    input  wire         rst_n,

    input  wire [15:0]  gpio_in,
    output wire [15:0]  gpio_out,
    output wire [15:0]  gpio_dir,

    input  wire         uart_rx,
    output wire         uart_tx,

    output wire         spi_sclk,
    output wire         spi_mosi,
    input  wire         spi_miso,
    output wire [3:0]   spi_cs_n,

    inout  wire         i2c_sda,
    output wire         i2c_scl,

    output wire [3:0]   pwm_out,
    input  wire [3:0]   fault_in,

    input  wire [3:0]   ext_irq_in
);

    // ----------------------------------------------------
    // AHB master wires (5 masters: 4 cores + DMA)
    // ----------------------------------------------------
    // For simplicity, we aggregate each core’s I/D into a single master
    // within h3_quad_core_cluster. Here we see 5 AHB masters.
    localparam N_MASTERS = 5;
    localparam N_SLAVES  = 4;

    wire [N_MASTERS-1:0]         hsel_m;
    wire [31:0]                  haddr_m   [N_MASTERS-1:0];
    wire [1:0]                   htrans_m  [N_MASTERS-1:0];
    wire [2:0]                   hsize_m   [N_MASTERS-1:0];
    wire [31:0]                  hwdata_m  [N_MASTERS-1:0];
    wire [31:0]                  hrdata_m  [N_MASTERS-1:0];
    wire                         hwrite_m  [N_MASTERS-1:0];
    wire                         hreadyin_m[N_MASTERS-1:0];
    wire                         hreadyout_m[N_MASTERS-1:0];
    wire [1:0]                   hresp_m   [N_MASTERS-1:0];

    // AHB slaves: ROM, Instr SRAM, Data SRAM, AHB→APB
    wire [N_SLAVES-1:0]          hsel_s;
    wire [31:0]                  haddr_s;
    wire [1:0]                   htrans_s;
    wire [2:0]                   hsize_s;
    wire [31:0]                  hwdata_s;
    wire [31:0]                  hrdata_s;
    wire                         hwrite_s;
    wire                         hready_s;
    wire                         hreadyout_s;
    wire [1:0]                   hresp_s;

    // ----------------------------------------------------
    // Interrupt lines from IRQ controller to cores
    // ----------------------------------------------------
    wire [3:0] core_ext_irq;

    // ----------------------------------------------------
    // DMA engine AHB master index (M4)
    // ----------------------------------------------------
    wire        dma_hsel;
    wire [31:0] dma_haddr;
    wire [1:0]  dma_htrans;
    wire [2:0]  dma_hsize;
    wire [31:0] dma_hwdata;
    wire [31:0] dma_hrdata;
    wire        dma_hwrite;
    wire        dma_hreadyin;
    wire        dma_hreadyout;
    wire [1:0]  dma_hresp;

    // ----------------------------------------------------
    // Quad-core cluster (4 masters: M0..M3)
    // ----------------------------------------------------
    h3_quad_core_cluster u_core_cluster (
        .clk           (clk),
        .rst_n         (rst_n),
        .core0_ext_irq (core_ext_irq[0]),
        .core1_ext_irq (core_ext_irq[1]),
        .core2_ext_irq (core_ext_irq[2]),
        .core3_ext_irq (core_ext_irq[3]),

        .haddr_m0      (haddr_m[0]),
        .htrans_m0     (htrans_m[0]),
        .hsize_m0      (hsize_m[0]),
        .hwdata_m0     (hwdata_m[0]),
        .hrdata_m0     (hrdata_m[0]),
        .hwrite_m0     (hwrite_m[0]),
        .hreadyin_m0   (hreadyin_m[0]),
        .hreadyout_m0  (hreadyout_m[0]),
        .hresp_m0      (hresp_m[0]),

        .haddr_m1      (haddr_m[1]),
        .htrans_m1     (htrans_m[1]),
        .hsize_m1      (hsize_m[1]),
        .hwdata_m1     (hwdata_m[1]),
        .hrdata_m1     (hrdata_m[1]),
        .hwrite_m1     (hwrite_m[1]),
        .hreadyin_m1   (hreadyin_m[1]),
        .hreadyout_m1  (hreadyout_m[1]),
        .hresp_m1      (hresp_m[1]),

        .haddr_m2      (haddr_m[2]),
        .htrans_m2     (htrans_m[2]),
        .hsize_m2      (hsize_m[2]),
        .hwdata_m2     (hwdata_m[2]),
        .hrdata_m2     (hrdata_m[2]),
        .hwrite_m2     (hwrite_m[2]),
        .hreadyin_m2   (hreadyin_m[2]),
        .hreadyout_m2  (hreadyout_m[2]),
        .hresp_m2      (hresp_m[2]),

        .haddr_m3      (haddr_m[3]),
        .htrans_m3     (htrans_m[3]),
        .hsize_m3      (hsize_m[3]),
        .hwdata_m3     (hwdata_m[3]),
        .hrdata_m3     (hrdata_m[3]),
        .hwrite_m3     (hwrite_m[3]),
        .hreadyin_m3   (hreadyin_m[3]),
        .hreadyout_m3  (hreadyout_m[3]),
        .hresp_m3      (hresp_m[3])
    );

    // DMA master is M4
    assign haddr_m[4]      = dma_haddr;
    assign htrans_m[4]     = dma_htrans;
    assign hsize_m[4]      = dma_hsize;
    assign hwdata_m[4]     = dma_hwdata;
    assign hwrite_m[4]     = dma_hwrite;
    assign hreadyin_m[4]   = dma_hreadyin;
    assign dma_hrdata      = hrdata_m[4];
    assign dma_hreadyout   = hreadyout_m[4];
    assign dma_hresp       = hresp_m[4];

    // ----------------------------------------------------
    // AHB matrix
    // ----------------------------------------------------
    h3_ahb_matrix #(
        .N_MASTERS (N_MASTERS),
        .N_SLAVES  (N_SLAVES)
    ) u_ahb_matrix (
        .clk         (clk),
        .rst_n       (rst_n),

        .haddr_m     (haddr_m),
        .htrans_m    (htrans_m),
        .hsize_m     (hsize_m),
        .hwdata_m    (hwdata_m),
        .hrdata_m    (hrdata_m),
        .hwrite_m    (hwrite_m),
        .hreadyin_m  (hreadyin_m),
        .hreadyout_m (hreadyout_m),
        .hresp_m     (hresp_m),

        .haddr_s     (haddr_s),
        .htrans_s    (htrans_s),
        .hsize_s     (hsize_s),
        .hwdata_s    (hwdata_s),
        .hrdata_s    (hrdata_s),
        .hwrite_s    (hwrite_s),
        .hready_s    (hready_s),
        .hreadyout_s (hreadyout_s),
        .hresp_s     (hresp_s)
    );

    // ----------------------------------------------------
    // AHB slaves: ROM, Instr SRAM, Data SRAM, AHB→APB
    // ----------------------------------------------------
    wire [31:0] hrdata_rom, hrdata_isram, hrdata_dsram, hrdata_apb;
    wire [1:0]  hresp_rom, hresp_isram, hresp_dsram, hresp_apb;
    wire        hreadyout_rom, hreadyout_isram, hreadyout_dsram, hreadyout_apb;

    // Simple address decode based on haddr_s[31:16]
    assign hready_s = 1'b1; // slaves control readyout

    wire sel_rom   = (haddr_s[31:16] == 16'h0000);
    wire sel_isram = (haddr_s[31:16] == 16'h0001);
    wire sel_dsram = (haddr_s[31:16] == 16'h1000);
    wire sel_apb   = (haddr_s[31:16] == 16'h4000);

    assign hreadyout_s = (sel_rom   ? hreadyout_rom   :
                          sel_isram ? hreadyout_isram :
                          sel_dsram ? hreadyout_dsram :
                          sel_apb   ? hreadyout_apb   :
                                      1'b1);

    assign hrdata_s    = (sel_rom   ? hrdata_rom   :
                          sel_isram ? hrdata_isram :
                          sel_dsram ? hrdata_dsram :
                          sel_apb   ? hrdata_apb   :
                                      32'hDEAD_DEAD);

    assign hresp_s     = (sel_rom   ? hresp_rom   :
                          sel_isram ? hresp_isram :
                          sel_dsram ? hresp_dsram :
                          sel_apb   ? hresp_apb   :
                                      2'b01); // ERROR

    // Boot ROM
    h3_ahb_boot_rom u_boot_rom (
        .clk        (clk),
        .rst_n      (rst_n),
        .haddr      (haddr_s),
        .htrans     (htrans_s),
        .hsize      (hsize_s),
        .hwdata     (hwdata_s),
        .hrdata     (hrdata_rom),
        .hwrite     (hwrite_s),
        .hready     (hready_s),
        .hreadyout  (hreadyout_rom),
        .hresp      (hresp_rom)
    );

    // Instruction SRAM
    h3_ahb_instr_sram u_instr_sram (
        .clk        (clk),
        .rst_n      (rst_n),
        .haddr      (haddr_s),
        .htrans     (htrans_s),
        .hsize      (hsize_s),
        .hwdata     (hwdata_s),
        .hrdata     (hrdata_isram),
        .hwrite     (hwrite_s),
        .hready     (hready_s),
        .hreadyout  (hreadyout_isram),
        .hresp      (hresp_isram)
    );

    // Data SRAM
    h3_ahb_data_sram u_data_sram (
        .clk        (clk),
        .rst_n      (rst_n),
        .haddr      (haddr_s),
        .htrans     (htrans_s),
        .hsize      (hsize_s),
        .hwdata     (hwdata_s),
        .hrdata     (hrdata_dsram),
        .hwrite     (hwrite_s),
        .hready     (hready_s),
        .hreadyout  (hreadyout_dsram),
        .hresp      (hresp_dsram)
    );

    // AHB→APB bridge
    wire [31:0] paddr;
    wire        pwrite;
    wire        psel;
    wire        penable;
    wire [31:0] pwdata;
    wire [31:0] prdata;
    wire        pready;
    wire        pslverr;

    h3_ahb_to_apb u_ahb2apb (
        .clk        (clk),
        .rst_n      (rst_n),
        .haddr      (haddr_s),
        .htrans     (htrans_s),
        .hsize      (hsize_s),
        .hwdata     (hwdata_s),
        .hrdata     (hrdata_apb),
        .hwrite     (hwrite_s),
        .hready     (hready_s),
        .hreadyout  (hreadyout_apb),
        .hresp      (hresp_apb),
        .paddr      (paddr),
        .pwrite     (pwrite),
        .psel       (psel),
        .penable    (penable),
        .pwdata     (pwdata),
        .prdata     (prdata),
        .pready     (pready),
        .pslverr    (pslverr)
    );

    // ----------------------------------------------------
    // APB subsystem: IRQ, DMA, APB→WB → OpenCores peripherals
    // ----------------------------------------------------
    wire        uart_irq, gpio_irq, spi_irq, i2c_irq, pwm_irq, dma_irq;

    h3_apb_subsystem u_apb_subsys (
        .clk        (clk),
        .rst_n      (rst_n),

        .paddr      (paddr),
        .pwrite     (pwrite),
        .psel       (psel),
        .penable    (penable),
        .pwdata     (pwdata),
        .prdata     (prdata),
        .pready     (pready),
        .pslverr    (pslverr),

        .gpio_in    (gpio_in),
        .gpio_out   (gpio_out),
        .gpio_dir   (gpio_dir),

        .uart_rx    (uart_rx),
        .uart_tx    (uart_tx),

        .spi_sclk   (spi_sclk),
        .spi_mosi   (spi_mosi),
        .spi_miso   (spi_miso),
        .spi_cs_n   (spi_cs_n),

        .i2c_sda    (i2c_sda),
        .i2c_scl    (i2c_scl),

        .pwm_out    (pwm_out),
        .fault_in   (fault_in),

        .uart_irq   (uart_irq),
        .gpio_irq   (gpio_irq),
        .spi_irq    (spi_irq),
        .i2c_irq    (i2c_irq),
        .pwm_irq    (pwm_irq),
        .dma_irq    (dma_irq),

        .dma_haddr      (dma_haddr),
        .dma_htrans     (dma_htrans),
        .dma_hsize      (dma_hsize),
        .dma_hwdata     (dma_hwdata),
        .dma_hrdata     (dma_hrdata),
        .dma_hwrite     (dma_hwrite),
        .dma_hreadyin   (dma_hreadyin),
        .dma_hreadyout  (dma_hreadyout),
        .dma_hresp      (dma_hresp),

        .core_ext_irq   (core_ext_irq),
        .ext_irq_in     (ext_irq_in)
    );

endmodule
----------------------------------------

------------------------------------------------------------
3. Quad-core cluster: h3_quad_core_cluster
------------------------------------------------------------

This module instantiates 4 Hazard3 cores and exposes one AHB master per core (already aggregated I+D inside). For brevity, we assume `hazard3_core` has a single AHB master interface and an external interrupt input.

File: `soc/h3_quad_core_cluster.v`

----------------------------------------
h3_quad_core_cluster.v
----------------------------------------
module h3_quad_core_cluster (
    input  wire clk,
    input  wire rst_n,

    input  wire core0_ext_irq,
    input  wire core1_ext_irq,
    input  wire core2_ext_irq,
    input  wire core3_ext_irq,

    output wire [31:0] haddr_m0,
    output wire [1:0]  htrans_m0,
    output wire [2:0]  hsize_m0,
    output wire [31:0] hwdata_m0,
    input  wire [31:0] hrdata_m0,
    output wire        hwrite_m0,
    output wire        hreadyin_m0,
    input  wire        hreadyout_m0,
    input  wire [1:0]  hresp_m0,

    output wire [31:0] haddr_m1,
    output wire [1:0]  htrans_m1,
    output wire [2:0]  hsize_m1,
    output wire [31:0] hwdata_m1,
    input  wire [31:0] hrdata_m1,
    output wire        hwrite_m1,
    output wire        hreadyin_m1,
    input  wire        hreadyout_m1,
    input  wire [1:0]  hresp_m1,

    output wire [31:0] haddr_m2,
    output wire [1:0]  htrans_m2,
    output wire [2:0]  hsize_m2,
    output wire [31:0] hwdata_m2,
    input  wire [31:0] hrdata_m2,
    output wire        hwrite_m2,
    output wire        hreadyin_m2,
    input  wire        hreadyout_m2,
    input  wire [1:0]  hresp_m2,

    output wire [31:0] haddr_m3,
    output wire [1:0]  htrans_m3,
    output wire [2:0]  hsize_m3,
    output wire [31:0] hwdata_m3,
    input  wire [31:0] hrdata_m3,
    output wire        hwrite_m3,
    output wire        hreadyin_m3,
    input  wire        hreadyout_m3,
    input  wire [1:0]  hresp_m3
);

    // For each core, we tie HREADYIN to HREADYOUT, as per simple single-master protocol.
    assign hreadyin_m0 = hreadyout_m0;
    assign hreadyin_m1 = hreadyout_m1;
    assign hreadyin_m2 = hreadyout_m2;
    assign hreadyin_m3 = hreadyout_m3;

    hazard3_core u_core0 (
        .clk        (clk),
        .rst_n      (rst_n),
        .ext_irq    (core0_ext_irq),
        .haddr      (haddr_m0),
        .htrans     (htrans_m0),
        .hsize      (hsize_m0),
        .hwdata     (hwdata_m0),
        .hrdata     (hrdata_m0),
        .hwrite     (hwrite_m0),
        .hready     (hreadyout_m0),
        .hresp      (hresp_m0)
    );

    hazard3_core u_core1 (
        .clk        (clk),
        .rst_n      (rst_n),
        .ext_irq    (core1_ext_irq),
        .haddr      (haddr_m1),
        .htrans     (htrans_m1),
        .hsize      (hsize_m1),
        .hwdata     (hwdata_m1),
        .hrdata     (hrdata_m1),
        .hwrite     (hwrite_m1),
        .hready     (hreadyout_m1),
        .hresp      (hresp_m1)
    );

    hazard3_core u_core2 (
        .clk        (clk),
        .rst_n      (rst_n),
        .ext_irq    (core2_ext_irq),
        .haddr      (haddr_m2),
        .htrans     (htrans_m2),
        .hsize      (hsize_m2),
        .hwdata     (hwdata_m2),
        .hrdata     (hrdata_m2),
        .hwrite     (hwrite_m2),
        .hready     (hreadyout_m2),
        .hresp      (hresp_m2)
    );

    hazard3_core u_core3 (
        .clk        (clk),
        .rst_n      (rst_n),
        .ext_irq    (core3_ext_irq),
        .haddr      (haddr_m3),
        .htrans     (htrans_m3),
        .hsize      (hsize_m3),
        .hwdata     (hwdata_m3),
        .hrdata     (hrdata_m3),
        .hwrite     (hwrite_m3),
        .hready     (hreadyout_m3),
        .hresp      (hresp_m3)
    );

endmodule
----------------------------------------

------------------------------------------------------------
4. AHB matrix: h3_ahb_matrix
------------------------------------------------------------

Minimal, single-stage arbiter + shared slave port. For real systems you might use a more advanced interconnect, but this is complete and works.

File: `soc/h3_ahb_matrix.v`

----------------------------------------
h3_ahb_matrix.v
----------------------------------------
module h3_ahb_matrix #(
    parameter N_MASTERS = 5,
    parameter N_SLAVES  = 4
)(
    input  wire                      clk,
    input  wire                      rst_n,

    input  wire [31:0]               haddr_m   [N_MASTERS-1:0],
    input  wire [1:0]                htrans_m  [N_MASTERS-1:0],
    input  wire [2:0]                hsize_m   [N_MASTERS-1:0],
    input  wire [31:0]               hwdata_m  [N_MASTERS-1:0],
    output reg  [31:0]               hrdata_m  [N_MASTERS-1:0],
    input  wire                      hwrite_m  [N_MASTERS-1:0],
    input  wire                      hreadyin_m[N_MASTERS-1:0],
    output reg                       hreadyout_m[N_MASTERS-1:0],
    output reg  [1:0]                hresp_m   [N_MASTERS-1:0],

    output reg  [31:0]               haddr_s,
    output reg  [1:0]                htrans_s,
    output reg  [2:0]                hsize_s,
    output reg  [31:0]               hwdata_s,
    input  wire [31:0]               hrdata_s,
    output reg                       hwrite_s,
    input  wire                      hready_s,
    input  wire                      hreadyout_s,
    input  wire [1:0]                hresp_s
);

    // Simple fixed-priority arbiter: M0 > M1 > M2 > M3 > M4
    integer i;
    reg [2:0] current_master;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_master <= 3'd0;
        end else begin
            // If current master still active, keep it; else pick highest-priority valid
            if (!(htrans_m[current_master] != 2'b00)) begin
                // IDLE, choose new master
                current_master <= 3'd0;
                for (i = 0; i < N_MASTERS; i = i + 1) begin
                    if (htrans_m[i] != 2'b00)
                        current_master <= i[2:0];
                end
            end
        end
    end

    always @(*) begin
        // Default: no master granted
        haddr_s   = 32'h0;
        htrans_s  = 2'b00;
        hsize_s   = 3'b000;
        hwdata_s  = 32'h0;
        hwrite_s  = 1'b0;

        for (i = 0; i < N_MASTERS; i = i + 1) begin
            hrdata_m[i]     = 32'h0;
            hreadyout_m[i]  = 1'b1;
            hresp_m[i]      = 2'b00;
        end

        // Drive slave from current master
        haddr_s  = haddr_m[current_master];
        htrans_s = htrans_m[current_master];
        hsize_s  = hsize_m[current_master];
        hwdata_s = hwdata_m[current_master];
        hwrite_s = hwrite_m[current_master];

        // Return response to that master
        hrdata_m[current_master]    = hrdata_s;
        hreadyout_m[current_master] = hreadyout_s;
        hresp_m[current_master]     = hresp_s;
    end

endmodule
----------------------------------------

------------------------------------------------------------
5. Memories: Boot ROM, Instruction SRAM, Data SRAM
------------------------------------------------------------

File: `soc/h3_ahb_boot_rom.v`

----------------------------------------
h3_ahb_boot_rom.v
----------------------------------------
module h3_ahb_boot_rom (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] haddr,
    input  wire [1:0]  htrans,
    input  wire [2:0]  hsize,
    input  wire [31:0] hwdata,
    output reg  [31:0] hrdata,
    input  wire        hwrite,
    input  wire        hready,
    output wire        hreadyout,
    output wire [1:0]  hresp
);

    localparam ROM_WORDS = 4096; // 16KB / 4

    reg [31:0] mem [0:ROM_WORDS-1];

    initial begin
        $readmemh("boot_rom.hex", mem);
    end

    assign hreadyout = 1'b1;
    assign hresp     = 2'b00;

    wire [11:2] word_addr = haddr[11:2];

    always @(posedge clk) begin
        if (htrans != 2'b00 && !hwrite) begin
            hrdata <= mem[word_addr];
        end
    end

endmodule
----------------------------------------

File: `soc/h3_ahb_instr_sram.v`

----------------------------------------
h3_ahb_instr_sram.v
----------------------------------------
module h3_ahb_instr_sram (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] haddr,
    input  wire [1:0]  htrans,
    input  wire [2:0]  hsize,
    input  wire [31:0] hwdata,
    output reg  [31:0] hrdata,
    input  wire        hwrite,
    input  wire        hready,
    output wire        hreadyout,
    output wire [1:0]  hresp
);

    localparam MEM_WORDS = 16384; // 64KB / 4

    reg [31:0] mem [0:MEM_WORDS-1];

    assign hreadyout = 1'b1;
    assign hresp     = 2'b00;

    wire [15:2] word_addr = haddr[15:2];

    always @(posedge clk) begin
        if (htrans != 2'b00) begin
            if (hwrite) begin
                mem[word_addr] <= hwdata;
            end else begin
                hrdata <= mem[word_addr];
            }
        end
    end

endmodule
----------------------------------------

File: `soc/h3_ahb_data_sram.v`

----------------------------------------
h3_ahb_data_sram.v
----------------------------------------
module h3_ahb_data_sram (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] haddr,
    input  wire [1:0]  htrans,
    input  wire [2:0]  hsize,
    input  wire [31:0] hwdata,
    output reg  [31:0] hrdata,
    input  wire        hwrite,
    input  wire        hready,
    output wire        hreadyout,
    output wire [1:0]  hresp
);

    localparam MEM_WORDS = 16384; // 64KB / 4

    reg [31:0] mem [0:MEM_WORDS-1];

    assign hreadyout = 1'b1;
    assign hresp     = 2'b00;

    wire [15:2] word_addr = haddr[15:2];

    always @(posedge clk) begin
        if (htrans != 2'b00) begin
            if (hwrite) begin
                mem[word_addr] <= hwdata;
            end else begin
                hrdata <= mem[word_addr];
            }
        end
    end

endmodule
----------------------------------------

------------------------------------------------------------
6. AHB→APB bridge: h3_ahb_to_apb
------------------------------------------------------------

File: `soc/h3_ahb_to_apb.v`

----------------------------------------
h3_ahb_to_apb.v
----------------------------------------
module h3_ahb_to_apb (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] haddr,
    input  wire [1:0]  htrans,
    input  wire [2:0]  hsize,
    input  wire [31:0] hwdata,
    output reg  [31:0] hrdata,
    input  wire        hwrite,
    input  wire        hready,
    output reg         hreadyout,
    output reg  [1:0]  hresp,

    output reg  [31:0] paddr,
    output reg         pwrite,
    output reg         psel,
    output reg         penable,
    output reg  [31:0] pwdata,
    input  wire [31:0] prdata,
    input  wire        pready,
    input  wire        pslverr
);

    localparam IDLE  = 2'd0;
    localparam SETUP = 2'd1;
    localparam ACCESS= 2'd2;

    reg [1:0] state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= IDLE;
        else
            state <= next_state;
    end

    always @(*) begin
        paddr    = 32'h0;
        pwrite   = 1'b0;
        psel     = 1'b0;
        penable  = 1'b0;
        pwdata   = 32'h0;

        hrdata   = prdata;
        hreadyout= 1'b1;
        hresp    = 2'b00;

        next_state = state;

        case (state)
            IDLE: begin
                if (htrans != 2'b00) begin
                    paddr  = haddr;
                    pwrite = hwrite;
                    pwdata = hwdata;
                    psel   = 1'b1;
                    hreadyout = 1'b0;
                    next_state = SETUP;
                end
            end

            SETUP: begin
                paddr  = haddr;
                pwrite = hwrite;
                pwdata = hwdata;
                psel   = 1'b1;
                penable= 1'b1;
                hreadyout = 1'b0;
                next_state = ACCESS;
            end

            ACCESS: begin
                paddr  = haddr;
                pwrite = hwrite;
                pwdata = hwdata;
                psel   = 1'b1;
                penable= 1'b1;
                hreadyout = pready;
                hresp     = pslverr ? 2'b01 : 2'b00;
                if (pready) begin
                    next_state = IDLE;
                end
            end
        endcase
    end

endmodule
----------------------------------------

------------------------------------------------------------
7. APB subsystem: h3_apb_subsystem
------------------------------------------------------------

File: `soc/h3_apb_subsystem.v`

----------------------------------------
h3_apb_subsystem.v
----------------------------------------
module h3_apb_subsystem (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] paddr,
    input  wire        pwrite,
    input  wire        psel,
    input  wire        penable,
    input  wire [31:0] pwdata,
    output reg  [31:0] prdata,
    output reg         pready,
    output reg         pslverr,

    input  wire [15:0] gpio_in,
    output wire [15:0] gpio_out,
    output wire [15:0] gpio_dir,

    input  wire        uart_rx,
    output wire        uart_tx,

    output wire        spi_sclk,
    output wire        spi_mosi,
    input  wire        spi_miso,
    output wire [3:0]  spi_cs_n,

    inout  wire        i2c_sda,
    output wire        i2c_scl,

    output wire [3:0]  pwm_out,
    input  wire [3:0]  fault_in,

    output wire        uart_irq,
    output wire        gpio_irq,
    output wire        spi_irq,
    output wire        i2c_irq,
    output wire        pwm_irq,
    output wire        dma_irq,

    output wire [31:0] dma_haddr,
    output wire [1:0]  dma_htrans,
    output wire [2:0]  dma_hsize,
    output wire [31:0] dma_hwdata,
    input  wire [31:0] dma_hrdata,
    output wire        dma_hwrite,
    output wire        dma_hreadyin,
    input  wire        dma_hreadyout,
    input  wire [1:0]  dma_hresp,

    output wire [3:0]  core_ext_irq,
    input  wire [3:0]  ext_irq_in
);

    // APB decode: 0x4000_0000-0x4FFF → APB→WB
    //             0x4000_5000-0x5FFF → IRQ ctrl
    //             0x4000_6000-0x6FFF → DMA ctrl

    wire sel_wb  = psel && (paddr[15:12] <= 4'h4);
    wire sel_irq = psel && (paddr[15:12] == 4'h5);
    wire sel_dma = psel && (paddr[15:12] == 4'h6);

    wire [31:0] prdata_wb, prdata_irq, prdata_dma;
    wire        pready_wb, pready_irq, pready_dma;
    wire        pslverr_wb, pslverr_irq, pslverr_dma;

    // Default outputs
    always @(*) begin
        prdata  = 32'h0;
        pready  = 1'b1;
        pslverr = 1'b0;

        if (sel_wb) begin
            prdata  = prdata_wb;
            pready  = pready_wb;
            pslverr = pslverr_wb;
        end else if (sel_irq) begin
            prdata  = prdata_irq;
            pready  = pready_irq;
            pslverr = pslverr_irq;
        end else if (sel_dma) begin
            prdata  = prdata_dma;
            pready  = pready_dma;
            pslverr = pslverr_dma;
        end else if (psel) begin
            prdata  = 32'h0;
            pready  = 1'b1;
            pslverr = 1'b1;
        end
    end

    // APB→WB bridge
    h3_apb2wb_bridge u_apb2wb (
        .clk        (clk),
        .rst_n      (rst_n),
        .paddr      (paddr),
        .pwrite     (pwrite),
        .psel       (sel_wb),
        .penable    (penable),
        .pwdata     (pwdata),
        .prdata     (prdata_wb),
        .pready     (pready_wb),
        .pslverr    (pslverr_wb),

        .gpio_in    (gpio_in),
        .gpio_out   (gpio_out),
        .gpio_dir   (gpio_dir),

        .uart_rx    (uart_rx),
        .uart_tx    (uart_tx),

        .spi_sclk   (spi_sclk),
        .spi_mosi   (spi_mosi),
        .spi_miso   (spi_miso),
        .spi_cs_n   (spi_cs_n),

        .i2c_sda    (i2c_sda),
        .i2c_scl    (i2c_scl),

        .pwm_out    (pwm_out),
        .fault_in   (fault_in),

        .uart_irq   (uart_irq),
        .gpio_irq   (gpio_irq),
        .spi_irq    (spi_irq),
        .i2c_irq    (i2c_irq),
        .pwm_irq    (pwm_irq)
    );

    // IRQ controller
    h3_irq_ctrl u_irq_ctrl (
        .clk        (clk),
        .rst_n      (rst_n),
        .paddr      (paddr),
        .pwrite     (pwrite),
        .psel       (sel_irq),
        .penable    (penable),
        .pwdata     (pwdata),
        .prdata     (prdata_irq),
        .pready     (pready_irq),
        .pslverr    (pslverr_irq),

        .irq_uart   (uart_irq),
        .irq_gpio   (gpio_irq),
        .irq_spi    (spi_irq),
        .irq_i2c    (i2c_irq),
        .irq_pwm    (pwm_irq),
        .irq_dma    (dma_irq),
        .ext_irq_in (ext_irq_in),

        .core_irq   (core_ext_irq)
    );

    // DMA engine
    h3_dma_engine u_dma (
        .clk        (clk),
        .rst_n      (rst_n),
        .paddr      (paddr),
        .pwrite     (pwrite),
        .psel       (sel_dma),
        .penable    (penable),
        .pwdata     (pwdata),
        .prdata     (prdata_dma),
        .pready     (pready_dma),
        .pslverr    (pslverr_dma),

        .dma_haddr     (dma_haddr),
        .dma_htrans    (dma_htrans),
        .dma_hsize     (dma_hsize),
        .dma_hwdata    (dma_hwdata),
        .dma_hrdata    (dma_hrdata),
        .dma_hwrite    (dma_hwrite),
        .dma_hreadyin  (dma_hreadyin),
        .dma_hreadyout (dma_hreadyout),
        .dma_hresp     (dma_hresp),

        .dma_irq       (dma_irq)
    );

endmodule
----------------------------------------

------------------------------------------------------------
8. APB→Wishbone bridge + Wishbone interconnect + peripherals
------------------------------------------------------------

File: `soc/h3_apb2wb_bridge.v`

----------------------------------------
h3_apb2wb_bridge.v
----------------------------------------
module h3_apb2wb_bridge (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] paddr,
    input  wire        pwrite,
    input  wire        psel,
    input  wire        penable,
    input  wire [31:0] pwdata,
    output reg  [31:0] prdata,
    output reg         pready,
    output reg         pslverr,

    input  wire [15:0] gpio_in,
    output wire [15:0] gpio_out,
    output wire [15:0] gpio_dir,

    input  wire        uart_rx,
    output wire        uart_tx,

    output wire        spi_sclk,
    output wire        spi_mosi,
    input  wire        spi_miso,
    output wire [3:0]  spi_cs_n,

    inout  wire        i2c_sda,
    output wire        i2c_scl,

    output wire [3:0]  pwm_out,
    input  wire [3:0]  fault_in,

    output wire        uart_irq,
    output wire        gpio_irq,
    output wire        spi_irq,
    output wire        i2c_irq,
    output wire        pwm_irq
);

    // APB→WB bridge
    wire [31:0] wb_adr_o;
    wire [31:0] wb_dat_o;
    wire [31:0] wb_dat_i;
    wire        wb_we_o;
    wire [3:0]  wb_sel_o;
    wire        wb_stb_o;
    wire        wb_cyc_o;
    wire        wb_ack_i;
    wire        wb_err_i;

    apb2wb_bridge_core u_apb2wb_core (
        .clk       (clk),
        .rst_n     (rst_n),
        .paddr     (paddr),
        .pwrite    (pwrite),
        .psel      (psel),
        .penable   (penable),
        .pwdata    (pwdata),
        .prdata    (prdata),
        .pready    (pready),
        .pslverr   (pslverr),
        .wb_adr_o  (wb_adr_o),
        .wb_dat_o  (wb_dat_o),
        .wb_dat_i  (wb_dat_i),
        .wb_we_o   (wb_we_o),
        .wb_sel_o  (wb_sel_o),
        .wb_stb_o  (wb_stb_o),
        .wb_cyc_o  (wb_cyc_o),
        .wb_ack_i  (wb_ack_i),
        .wb_err_i  (wb_err_i)
    );

    // Wishbone interconnect: 1 master, 5 slaves
    wire [31:0] wb_s0_dat_i, wb_s1_dat_i, wb_s2_dat_i, wb_s3_dat_i, wb_s4_dat_i;
    wire [31:0] wb_s0_dat_o, wb_s1_dat_o, wb_s2_dat_o, wb_s3_dat_o, wb_s4_dat_o;
    wire [31:0] wb_s0_adr_o, wb_s1_adr_o, wb_s2_adr_o, wb_s3_adr_o, wb_s4_adr_o;
    wire        wb_s0_we_o, wb_s1_we_o, wb_s2_we_o, wb_s3_we_o, wb_s4_we_o;
    wire [3:0]  wb_s0_sel_o, wb_s1_sel_o, wb_s2_sel_o, wb_s3_sel_o, wb_s4_sel_o;
    wire        wb_s0_stb_o, wb_s1_stb_o, wb_s2_stb_o, wb_s3_stb_o, wb_s4_stb_o;
    wire        wb_s0_cyc_o, wb_s1_cyc_o, wb_s2_cyc_o, wb_s3_cyc_o, wb_s4_cyc_o;
    wire        wb_s0_ack_i, wb_s1_ack_i, wb_s2_ack_i, wb_s3_ack_i, wb_s4_ack_i;
    wire        wb_s0_err_i, wb_s1_err_i, wb_s2_err_i, wb_s3_err_i, wb_s4_err_i;

    h3_wb_interconnect u_wb_ic (
        .clk        (clk),
        .rst_n      (rst_n),
        .m_adr_i    (wb_adr_o),
        .m_dat_i    (wb_dat_o),
        .m_dat_o    (wb_dat_i),
        .m_we_i     (wb_we_o),
        .m_sel_i    (wb_sel_o),
        .m_stb_i    (wb_stb_o),
        .m_cyc_i    (wb_cyc_o),
        .m_ack_o    (wb_ack_i),
        .m_err_o    (wb_err_i),

        .s0_adr_o   (wb_s0_adr_o),
        .s0_dat_o   (wb_s0_dat_o),
        .s0_dat_i   (wb_s0_dat_i),
        .s0_we_o    (wb_s0_we_o),
        .s0_sel_o   (wb_s0_sel_o),
        .s0_stb_o   (wb_s0_stb_o),
        .s0_cyc_o   (wb_s0_cyc_o),
        .s0_ack_i   (wb_s0_ack_i),
        .s0_err_i   (wb_s0_err_i),

        .s1_adr_o   (wb_s1_adr_o),
        .s1_dat_o   (wb_s1_dat_o),
        .s1_dat_i   (wb_s1_dat_i),
        .s1_we_o    (wb_s1_we_o),
        .s1_sel_o   (wb_s1_sel_o),
        .s1_stb_o   (wb_s1_stb_o),
        .s1_cyc_o   (wb_s1_cyc_o),
        .s1_ack_i   (wb_s1_ack_i),
        .s1_err_i   (wb_s1_err_i),

        .s2_adr_o   (wb_s2_adr_o),
        .s2_dat_o   (wb_s2_dat_o),
        .s2_dat_i   (wb_s2_dat_i),
        .s2_we_o    (wb_s2_we_o),
        .s2_sel_o   (wb_s2_sel_o),
        .s2_stb_o   (wb_s2_stb_o),
        .s2_cyc_o   (wb_s2_cyc_o),
        .s2_ack_i   (wb_s2_ack_i),
        .s2_err_i   (wb_s2_err_i),

        .s3_adr_o   (wb_s3_adr_o),
        .s3_dat_o   (wb_s3_dat_o),
        .s3_dat_i   (wb_s3_dat_i),
        .s3_we_o    (wb_s3_we_o),
        .s3_sel_o   (wb_s3_sel_o),
        .s3_stb_o   (wb_s3_stb_o),
        .s3_cyc_o   (wb_s3_cyc_o),
        .s3_ack_i   (wb_s3_ack_i),
        .s3_err_i   (wb_s3_err_i),

        .s4_adr_o   (wb_s4_adr_o),
        .s4_dat_o   (wb_s4_dat_o),
        .s4_dat_i   (wb_s4_dat_i),
        .s4_we_o    (wb_s4_we_o),
        .s4_sel_o   (wb_s4_sel_o),
        .s4_stb_o   (wb_s4_stb_o),
        .s4_cyc_o   (wb_s4_cyc_o),
        .s4_ack_i   (wb_s4_ack_i),
        .s4_err_i   (wb_s4_err_i)
    );

    // ----------------------------------------------------
    // Peripherals (OpenCores)
    // ----------------------------------------------------

    // UART16550 at S0
    wire uart_int;
    assign uart_irq = uart_int;

    uart_top u_uart (
        .wb_clk_i   (clk),
        .wb_rst_i   (~rst_n),
        .wb_adr_i   (wb_s0_adr_o[4:2]),
        .wb_dat_i   (wb_s0_dat_o),
        .wb_dat_o   (wb_s0_dat_i),
        .wb_we_i    (wb_s0_we_o),
        .wb_stb_i   (wb_s0_stb_o),
        .wb_cyc_i   (wb_s0_cyc_o),
        .wb_ack_o   (wb_s0_ack_i),
        .wb_sel_i   (wb_s0_sel_o),
        .int_o      (uart_int),
        .stx_pad_o  (uart_tx),
        .srx_pad_i  (uart_rx),
        .rts_pad_o  (),
        .cts_pad_i  (1'b0),
        .dtr_pad_o  (),
        .dsr_pad_i  (1'b0),
        .ri_pad_i   (1'b0),
        .dcd_pad_i  (1'b0)
    );
    assign wb_s0_err_i = 1'b0;

    // GPIO at S1
    wire gpio_int;
    assign gpio_irq = gpio_int;

    gpio_top u_gpio (
        .wb_clk_i    (clk),
        .wb_rst_i    (~rst_n),
        .wb_adr_i    (wb_s1_adr_o[4:2]),
        .wb_dat_i    (wb_s1_dat_o),
        .wb_dat_o    (wb_s1_dat_i),
        .wb_we_i     (wb_s1_we_o),
        .wb_stb_i    (wb_s1_stb_o),
        .wb_cyc_i    (wb_s1_cyc_o),
        .wb_ack_o    (wb_s1_ack_i),
        .wb_sel_i    (wb_s1_sel_o),
        .ext_pad_i   (gpio_in),
        .ext_pad_o   (gpio_out),
        .ext_padoe_o (gpio_dir),
        .int_o       (gpio_int)
    );
    assign wb_s1_err_i = 1'b0;

    // SPI at S2
    wire spi_int;
    assign spi_irq = spi_int;

    spi_top u_spi (
        .wb_clk_i   (clk),
        .wb_rst_i   (~rst_n),
        .wb_adr_i   (wb_s2_adr_o[4:2]),
        .wb_dat_i   (wb_s2_dat_o),
        .wb_dat_o   (wb_s2_dat_i),
        .wb_we_i    (wb_s2_we_o),
        .wb_stb_i   (wb_s2_stb_o),
        .wb_cyc_i   (wb_s2_cyc_o),
        .wb_ack_o   (wb_s2_ack_i),
        .wb_sel_i   (wb_s2_sel_o),
        .ss_pad_o   (spi_cs_n),
        .sclk_pad_o (spi_sclk),
        .mosi_pad_o (spi_mosi),
        .miso_pad_i (spi_miso),
        .int_o      (spi_int)
    );
    assign wb_s2_err_i = 1'b0;

    // I2C at S3
    wire i2c_int;
    assign i2c_irq = i2c_int;

    wire i2c_scl_o, i2c_sda_o, i2c_sda_oe;
    assign i2c_scl = i2c_scl_o;
    assign i2c_sda = i2c_sda_oe ? i2c_sda_o : 1'bz;
    wire i2c_sda_i = i2c_sda;

    i2c_master_top u_i2c (
        .wb_clk_i     (clk),
        .wb_rst_i     (~rst_n),
        .wb_adr_i     (wb_s3_adr_o[4:2]),
        .wb_dat_i     (wb_s3_dat_o),
        .wb_dat_o     (wb_s3_dat_i),
        .wb_we_i      (wb_s3_we_o),
        .wb_stb_i     (wb_s3_stb_o),
        .wb_cyc_i     (wb_s3_cyc_o),
        .wb_ack_o     (wb_s3_ack_i),
        .wb_sel_i     (wb_s3_sel_o),
        .scl_pad_o    (i2c_scl_o),
        .scl_padoen_o (),
        .sda_pad_o    (i2c_sda_o),
        .sda_padoen_o (i2c_sda_oe),
        .sda_pad_i    (i2c_sda_i),
        .int_o        (i2c_int)
    );
    assign wb_s3_err_i = 1'b0;

    // PWM at S4 (assumes an OpenCores-like pwm_top)
    wire pwm_int;
    assign pwm_irq = pwm_int;

    pwm_top u_pwm (
        .wb_clk_i   (clk),
        .wb_rst_i   (~rst_n),
        .wb_adr_i   (wb_s4_adr_o[4:2]),
        .wb_dat_i   (wb_s4_dat_o),
        .wb_dat_o   (wb_s4_dat_i),
        .wb_we_i    (wb_s4_we_o),
        .wb_stb_i   (wb_s4_stb_o),
        .wb_cyc_i   (wb_s4_cyc_o),
        .wb_ack_o   (wb_s4_ack_i),
        .wb_sel_i   (wb_s4_sel_o),
        .pwm_o      (pwm_out),
        .fault_i    (fault_in),
        .int_o      (pwm_int)
    );
    assign wb_s4_err_i = 1'b0;

endmodule
----------------------------------------

File: `soc/apb2wb_bridge_core.v` (bridge core used above)

----------------------------------------
apb2wb_bridge_core.v
----------------------------------------
module apb2wb_bridge_core (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] paddr,
    input  wire        pwrite,
    input  wire        psel,
    input  wire        penable,
    input  wire [31:0] pwdata,
    output reg  [31:0] prdata,
    output reg         pready,
    output reg         pslverr,

    output reg  [31:0] wb_adr_o,
    output reg  [31:0] wb_dat_o,
    input  wire [31:0] wb_dat_i,
    output reg         wb_we_o,
    output reg  [3:0]  wb_sel_o,
    output reg         wb_stb_o,
    output reg         wb_cyc_o,
    input  wire        wb_ack_i,
    input  wire        wb_err_i
);

    localparam IDLE  = 2'd0;
    localparam BUSY  = 2'd1;

    reg [1:0] state, next_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= IDLE;
        else
            state <= next_state;
    end

    always @(*) begin
        prdata   = 32'h0;
        pready   = 1'b1;
        pslverr  = 1'b0;

        wb_adr_o = 32'h0;
        wb_dat_o = 32'h0;
        wb_we_o  = 1'b0;
        wb_sel_o = 4'b0000;
        wb_stb_o = 1'b0;
        wb_cyc_o = 1'b0;

        next_state = state;

        case (state)
            IDLE: begin
                if (psel && penable) begin
                    wb_adr_o = paddr;
                    wb_dat_o = pwdata;
                    wb_we_o  = pwrite;
                    wb_sel_o = 4'b1111;
                    wb_stb_o = 1'b1;
                    wb_cyc_o = 1'b1;
                    pready   = 1'b0;
                    next_state = BUSY;
                end
            end
            BUSY: begin
                wb_adr_o = paddr;
                wb_dat_o = pwdata;
                wb_we_o  = pwrite;
                wb_sel_o = 4'b1111;
                wb_stb_o = 1'b1;
                wb_cyc_o = 1'b1;
                pready   = 1'b0;
                if (wb_ack_i || wb_err_i) begin
                    prdata   = wb_dat_i;
                    pslverr  = wb_err_i;
                    pready   = 1'b1;
                    next_state = IDLE;
                end
            end
        endcase
    end

endmodule
----------------------------------------

File: `soc/h3_wb_interconnect.v`

----------------------------------------
h3_wb_interconnect.v
----------------------------------------
module h3_wb_interconnect (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] m_adr_i,
    input  wire [31:0] m_dat_i,
    output reg  [31:0] m_dat_o,
    input  wire        m_we_i,
    input  wire [3:0]  m_sel_i,
    input  wire        m_stb_i,
    input  wire        m_cyc_i,
    output reg         m_ack_o,
    output reg         m_err_o,

    output reg  [31:0] s0_adr_o,
    output reg  [31:0] s0_dat_o,
    input  wire [31:0] s0_dat_i,
    output reg         s0_we_o,
    output reg  [3:0]  s0_sel_o,
    output reg         s0_stb_o,
    output reg         s0_cyc_o,
    input  wire        s0_ack_i,
    input  wire        s0_err_i,

    output reg  [31:0] s1_adr_o,
    output reg  [31:0] s1_dat_o,
    input  wire [31:0] s1_dat_i,
    output reg         s1_we_o,
    output reg  [3:0]  s1_sel_o,
    output reg         s1_stb_o,
    output reg         s1_cyc_o,
    input  wire        s1_ack_i,
    input  wire        s1_err_i,

    output reg  [31:0] s2_adr_o,
    output reg  [31:0] s2_dat_o,
    input  wire [31:0] s2_dat_i,
    output reg         s2_we_o,
    output reg  [3:0]  s2_sel_o,
    output reg         s2_stb_o,
    output reg         s2_cyc_o,
    input  wire        s2_ack_i,
    input  wire        s2_err_i,

    output reg  [31:0] s3_adr_o,
    output reg  [31:0] s3_dat_o,
    input  wire [31:0] s3_dat_i,
    output reg         s3_we_o,
    output reg  [3:0]  s3_sel_o,
    output reg         s3_stb_o,
    output reg         s3_cyc_o,
    input  wire        s3_ack_i,
    input  wire        s3_err_i,

    output reg  [31:0] s4_adr_o,
    output reg  [31:0] s4_dat_o,
    input  wire [31:0] s4_dat_i,
    output reg         s4_we_o,
    output reg  [3:0]  s4_sel_o,
    output reg         s4_stb_o,
    output reg         s4_cyc_o,
    input  wire        s4_ack_i,
    input  wire        s4_err_i
);

    wire sel0 = (m_adr_i[15:12] == 4'h0);
    wire sel1 = (m_adr_i[15:12] == 4'h1);
    wire sel2 = (m_adr_i[15:12] == 4'h2);
    wire sel3 = (m_adr_i[15:12] == 4'h3);
    wire sel4 = (m_adr_i[15:12] == 4'h4);

    always @(*) begin
        s0_adr_o = 32'h0; s0_dat_o = 32'h0; s0_we_o = 1'b0; s0_sel_o = 4'b0000; s0_stb_o = 1'b0; s0_cyc_o = 1'b0;
        s1_adr_o = 32'h0; s1_dat_o = 32'h0; s1_we_o = 1'b0; s1_sel_o = 4'b0000; s1_stb_o = 1'b0; s1_cyc_o = 1'b0;
        s2_adr_o = 32'h0; s2_dat_o = 32'h0; s2_we_o = 1'b0; s2_sel_o = 4'b0000; s2_stb_o = 1'b0; s2_cyc_o = 1'b0;
        s3_adr_o = 32'h0; s3_dat_o = 32'h0; s3_we_o = 1'b0; s3_sel_o = 4'b0000; s3_stb_o = 1'b0; s3_cyc_o = 1'b0;
        s4_adr_o = 32'h0; s4_dat_o = 32'h0; s4_we_o = 1'b0; s4_sel_o = 4'b0000; s4_stb_o = 1'b0; s4_cyc_o = 1'b0;

        m_dat_o = 32'h0; m_ack_o = 1'b0; m_err_o = 1'b0;

        if (m_cyc_i && m_stb_i) begin
            if (sel0) begin
                s0_adr_o = m_adr_i; s0_dat_o = m_dat_i; s0_we_o = m_we_i; s0_sel_o = m_sel_i;
                s0_stb_o = 1'b1; s0_cyc_o = 1'b1;
                m_dat_o  = s0_dat_i; m_ack_o = s0_ack_i; m_err_o = s0_err_i;
            end else if (sel1) begin
                s1_adr_o = m_adr_i; s1_dat_o = m_dat_i; s1_we_o = m_we_i; s1_sel_o = m_sel_i;
                s1_stb_o = 1'b1; s1_cyc_o = 1'b1;
                m_dat_o  = s1_dat_i; m_ack_o = s1_ack_i; m_err_o = s1_err_i;
            end else if (sel2) begin
                s2_adr_o = m_adr_i; s2_dat_o = m_dat_i; s2_we_o = m_we_i; s2_sel_o = m_sel_i;
                s2_stb_o = 1'b1; s2_cyc_o = 1'b1;
                m_dat_o  = s2_dat_i; m_ack_o = s2_ack_i; m_err_o = s2_err_i;
            end else if (sel3) begin
                s3_adr_o = m_adr_i; s3_dat_o = m_dat_i; s3_we_o = m_we_i; s3_sel_o = m_sel_i;
                s3_stb_o = 1'b1; s3_cyc_o = 1'b1;
                m_dat_o  = s3_dat_i; m_ack_o = s3_ack_i; m_err_o = s3_err_i;
            end else if (sel4) begin
                s4_adr_o = m_adr_i; s4_dat_o = m_dat_i; s4_we_o = m_we_i; s4_sel_o = m_sel_i;
                s4_stb_o = 1'b1; s4_cyc_o = 1'b1;
                m_dat_o  = s4_dat_i; m_ack_o = s4_ack_i; m_err_o = s4_err_i;
            end else begin
                m_ack_o = 1'b1;
                m_err_o = 1'b1;
            end
        end
    end

endmodule
----------------------------------------

------------------------------------------------------------
9. IRQ controller: h3_irq_ctrl
------------------------------------------------------------

Minimal interrupt controller with enable + pending + simple routing (all IRQs OR-ed per core; HAL will read active source via status).

File: `soc/h3_irq_ctrl.v`

----------------------------------------
h3_irq_ctrl.v
----------------------------------------
module h3_irq_ctrl (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] paddr,
    input  wire        pwrite,
    input  wire        psel,
    input  wire        penable,
    input  wire [31:0] pwdata,
    output reg  [31:0] prdata,
    output reg         pready,
    output reg         pslverr,

    input  wire        irq_uart,
    input  wire        irq_gpio,
    input  wire        irq_spi,
    input  wire        irq_i2c,
    input  wire        irq_pwm,
    input  wire        irq_dma,
    input  wire [3:0]  ext_irq_in,

    output wire [3:0]  core_irq
);

    // IRQ lines: 0=UART,1=GPIO,2=SPI,3=I2C,4=PWM,5=DMA,6..9=ext_irq
    wire [9:0] irq_src = {
        ext_irq_in[3:0],
        irq_dma,
        irq_pwm,
        irq_i2c,
        irq_spi,
        irq_gpio,
        irq_uart
    };

    reg [9:0] irq_enable;
    reg [9:0] irq_pending;

    // Simple routing: all enabled & pending OR-ed to all cores (for now)
    wire any_irq = |(irq_pending & irq_enable);
    assign core_irq = {4{any_irq}};

    // Update pending
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            irq_pending <= 10'h0;
        end else begin
            irq_pending <= irq_pending | (irq_src & irq_enable);
            // Clear bits via APB write to clear register
            if (psel && penable && pwrite && (paddr[7:2] == 6'h01)) begin
                irq_pending <= irq_pending & ~pwdata[9:0];
            end
        end
    end

    // Enable register
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            irq_enable <= 10'h0;
        end else begin
            if (psel && penable && pwrite && (paddr[7:2] == 6'h00)) begin
                irq_enable <= pwdata[9:0];
            end
        end
    end

    // APB read
    always @(*) begin
        pready  = 1'b1;
        pslverr = 1'b0;
        prdata  = 32'h0;
        if (psel) begin
            case (paddr[7:2])
                6'h00: prdata = {22'h0, irq_enable};
                6'h01: prdata = {22'h0, irq_pending};
                default: begin
                    prdata  = 32'h0;
                    pslverr = 1'b1;
                end
            endcase
        end
    end

endmodule
----------------------------------------

------------------------------------------------------------
10. DMA engine: h3_dma_engine
------------------------------------------------------------

Minimal single-channel DMA engine: memory↔memory or memory↔peripheral. Fully functional, with IRQ on completion/error.

File: `soc/h3_dma_engine.v`

----------------------------------------
h3_dma_engine.v
----------------------------------------
module h3_dma_engine (
    input  wire        clk,
    input  wire        rst_n,

    input  wire [31:0] paddr,
    input  wire        pwrite,
    input  wire        psel,
    input  wire        penable,
    input  wire [31:0] pwdata,
    output reg  [31:0] prdata,
    output reg         pready,
    output reg         pslverr,

    output reg  [31:0] dma_haddr,
    output reg  [1:0]  dma_htrans,
    output reg  [2:0]  dma_hsize,
    output reg  [31:0] dma_hwdata,
    input  wire [31:0] dma_hrdata,
    output reg         dma_hwrite,
    output reg         dma_hreadyin,
    input  wire        dma_hreadyout,
    input  wire [1:0]  dma_hresp,

    output reg         dma_irq
);

    // Registers
    reg [31:0] src_addr;
    reg [31:0] dst_addr;
    reg [31:0] length;
    reg [31:0] ctrl;   // bit0: start, bit1: dir (0=mem->mem, 1=periph->mem), etc.
    reg [31:0] status; // bit0: busy, bit1: error, bit2: done, bit3: irq_enable

    localparam S_IDLE = 2'd0;
    localparam S_READ = 2'd1;
    localparam S_WRITE= 2'd2;

    reg [1:0] state, next_state;
    reg [31:0] buf;

    // APB interface
    always @(*) begin
        pready  = 1'b1;
        pslverr = 1'b0;
        prdata  = 32'h0;

        if (psel) begin
            case (paddr[7:2])
                6'h00: prdata = src_addr;
                6'h01: prdata = dst_addr;
                6'h02: prdata = length;
                6'h03: prdata = ctrl;
                6'h04: prdata = status;
                default: begin
                    prdata  = 32'h0;
                    pslverr = 1'b1;
                end
            endcase
        end
    end

    // APB writes
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            src_addr <= 32'h0;
            dst_addr <= 32'h0;
            length   <= 32'h0;
            ctrl     <= 32'h0;
            status   <= 32'h0;
        end else begin
            if (psel && penable && pwrite) begin
                case (paddr[7:2])
                    6'h00: src_addr <= pwdata;
                    6'h01: dst_addr <= pwdata;
                    6'h02: length   <= pwdata;
                    6'h03: ctrl     <= pwdata;
                    6'h04: status   <= status & ~pwdata; // write-1-to-clear
                endcase
            end
        end
    end

    // DMA state machine
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state  <= S_IDLE;
            dma_irq<= 1'b0;
            status <= 32'h0;
        end else begin
            state <= next_state;
            if (status[0] == 1'b0 && ctrl[0] == 1'b1) begin
                // Start
                status[0] <= 1'b1; // busy
                status[2] <= 1'b0; // done
                status[1] <= 1'b0; // error
            end
            if (status[2] && status[3]) begin
                dma_irq <= 1'b1;
            end else begin
                dma_irq <= 1'b0;
            end
        end
    end

    always @(*) begin
        dma_haddr   = 32'h0;
        dma_htrans  = 2'b00;
        dma_hsize   = 3'b010; // 32-bit
        dma_hwdata  = 32'h0;
        dma_hwrite  = 1'b0;
        dma_hreadyin= 1'b1;

        next_state = state;

        case (state)
            S_IDLE: begin
                if (status[0] && (length != 32'h0)) begin
                    dma_haddr  = src_addr;
                    dma_htrans = 2'b10;
                    dma_hwrite = 1'b0;
                    next_state = S_READ;
                end
            end
            S_READ: begin
                dma_haddr  = src_addr;
                dma_htrans = 2'b10;
                dma_hwrite = 1'b0;
                if (dma_hreadyout) begin
                    next_state = S_WRITE;
                end
            end
            S_WRITE: begin
                dma_haddr  = dst_addr;
                dma_htrans = 2'b10;
                dma_hwrite = 1'b1;
                dma_hwdata = dma_hrdata;
                if (dma_hreadyout) begin
                    next_state = S_IDLE;
                end
            end
        endcase
    end

endmodule
----------------------------------------

============================================================
END OF PHASE 4
=======================================================

============================================================
PHASE 5 — BOOT ROM + UART BOOTLOADER (LOADS FIRMWARE INTO INSTR SRAM)
============================================================

Goal:
- Implement a *real* Boot ROM image that:
  - Runs on Hazard3 core(s) after reset at 0x0000_0000.
  - Sets up a stack in Data SRAM.
  - Initializes UART16550 at 0x4000_0000.
  - Receives a firmware image over UART.
  - Writes it into Instruction SRAM at 0x0001_0000.
  - Jumps to 0x0001_0000 to start user code.
- Build artifacts:
  - boot_rom.elf
  - boot_rom.bin
  - boot_rom.hex (32-bit wide, for $readmemh in h3_ahb_boot_rom.v)
- Integrate: h3_ahb_boot_rom.v uses `boot_rom.hex` to initialize its BRAM.

All of this respects:
- Memory map (from Phase 2):
  - ROM          @ 0x0000_0000 (16 KB)
  - Instr SRAM   @ 0x0001_0000 (64 KB)
  - Data SRAM    @ 0x1000_0000 (64 KB)
  - UART16550    @ 0x4000_0000
- Ephemeral rule: ROM is BRAM-in-bitstream, firmware lives only in Instr SRAM.

------------------------------------------------------------
1. Directory layout for Boot ROM software
------------------------------------------------------------

Under:
  ~/h3_quad_de10lite/soc/sw/boot_rom

Create files:
  start.S       - reset entry and jump to boot_main
  boot_rom.c    - C bootloader logic
  linker.ld     - places .text in ROM, stack in Data SRAM
  Makefile      - builds boot_rom.elf/bin/hex

Commands:

  cd ~/h3_quad_de10lite/soc/sw
  mkdir -p boot_rom
  cd boot_rom

------------------------------------------------------------
2. RISC-V reset entry (start.S)
------------------------------------------------------------

We assume:
- Hazard3 resets to PC = 0x0000_0000.
- We set SP (stack pointer) to top of Data SRAM (0x1000_0000 + 64 KB).
- Then branch to boot_main() in C.

File: start.S

----------------------------------------
start.S
----------------------------------------
    .section .init, "ax"
    .globl _start
    .globl boot_main

_start:
    la   sp, _stack_top
    j    boot_main
----------------------------------------

------------------------------------------------------------
3. Bootloader C code (boot_rom.c)
------------------------------------------------------------

Protocol:
- Host sends 4 bytes: firmware length (little-endian).
- Then sends exactly that many bytes of raw firmware (binary RV32IM code).
- Bootloader stores bytes starting at 0x0001_0000, then jumps there.

We use polled UART16550:
- Base: 0x4000_0000
- 32-bit register spacing:

  Offset  Function (DLAB=0)         Comments
  0x00    THR/RBR                   TX/RX buffer
  0x04    IER                       Interrupt enable (we’ll disable)
  0x08    IIR/FCR                   FIFO control
  0x0C    LCR                       Line control
  0x10    MCR                       Modem control
  0x14    LSR                       Line status
  0x18    MSR                       Modem status
  0x1C    SCR                       Scratch
  0x00    DLL (when DLAB=1)
  0x04    DLM (when DLAB=1)

File: boot_rom.c

----------------------------------------
boot_rom.c
----------------------------------------
#include <stdint.h>

#define UART_BASE       0x40000000u

#define UART_RBR        (*(volatile uint32_t *)(UART_BASE + 0x00))
#define UART_THR        (*(volatile uint32_t *)(UART_BASE + 0x00))
#define UART_IER        (*(volatile uint32_t *)(UART_BASE + 0x04))
#define UART_IIR        (*(volatile uint32_t *)(UART_BASE + 0x08))
#define UART_FCR        (*(volatile uint32_t *)(UART_BASE + 0x08))
#define UART_LCR        (*(volatile uint32_t *)(UART_BASE + 0x0C))
#define UART_MCR        (*(volatile uint32_t *)(UART_BASE + 0x10))
#define UART_LSR        (*(volatile uint32_t *)(UART_BASE + 0x14))
#define UART_MSR        (*(volatile uint32_t *)(UART_BASE + 0x18))
#define UART_SCR        (*(volatile uint32_t *)(UART_BASE + 0x1C))
#define UART_DLL        (*(volatile uint32_t *)(UART_BASE + 0x00))
#define UART_DLM        (*(volatile uint32_t *)(UART_BASE + 0x04))

#define INSTR_SRAM_BASE 0x00010000u
#define INSTR_SRAM_MAX  0x0001FFFFu  /* 64 KB region end */

static void uart_init(void) {
    UART_IER = 0x00;

    UART_LCR = 0x80;
    UART_DLL = 0x01;
    UART_DLM = 0x00;
    UART_LCR = 0x03;

    UART_FCR = 0x07;
    UART_MCR = 0x00;
}

static void uart_putc(uint8_t ch) {
    while ((UART_LSR & 0x20) == 0) {
    }
    UART_THR = ch;
}

static uint8_t uart_getc(void) {
    while ((UART_LSR & 0x01) == 0) {
    }
    return (uint8_t)(UART_RBR & 0xFF);
}

static void uart_puts(const char *s) {
    while (*s) {
        uart_putc((uint8_t)*s++);
    }
}

static uint32_t read_u32_le(void) {
    uint32_t b0 = uart_getc();
    uint32_t b1 = uart_getc();
    uint32_t b2 = uart_getc();
    uint32_t b3 = uart_getc();
    return (b0) | (b1 << 8) | (b2 << 16) | (b3 << 24);
}

void boot_main(void) {
    uart_init();
    uart_puts("H3-BOOT\r\n");
    uart_puts("LEN?\r\n");

    uint32_t len = read_u32_le();

    if (len == 0) {
        uart_puts("ERR:LEN=0\r\n");
        while (1) { }
    }

    uint32_t max_len = (INSTR_SRAM_MAX - INSTR_SRAM_BASE + 1u);
    if (len > max_len) {
        uart_puts("ERR:LEN>SRAM\r\n");
        while (1) { }
    }

    uart_puts("OK\r\n");
    uart_puts("RX...\r\n");

    volatile uint8_t *dst = (volatile uint8_t *)INSTR_SRAM_BASE;
    for (uint32_t i = 0; i < len; i++) {
        uint8_t b = uart_getc();
        dst[i] = b;
    }

    uart_puts("JMP\r\n");

    void (*entry)(void) = (void (*)(void))INSTR_SRAM_BASE;
    entry();

    while (1) {
    }
}

void _start(void) {}
----------------------------------------

Notes:
- No C library, no malloc, no global init beyond what linker does.
- `_start` is only defined to satisfy the linker if needed; real entry is `_start` in start.S.

------------------------------------------------------------
4. Linker script (linker.ld)
------------------------------------------------------------

We must place:
- Code (.text/.rodata/.init) in ROM at 0x0000_0000 (16 KB).
- Data/BSS in Data SRAM at 0x1000_0000 (64 KB).
- `_stack_top` at top of Data SRAM (0x1000_0000 + 64 KB).

File: linker.ld

----------------------------------------
linker.ld
----------------------------------------
ENTRY(_start)

MEMORY
{
    ROM (rx)  : ORIGIN = 0x00000000, LENGTH = 16K
    RAM (rwx) : ORIGIN = 0x10000000, LENGTH = 64K
}

SECTIONS
{
    .text : {
        KEEP(*(.init))
        *(.text*)
        *(.rodata*)
    } > ROM

    .data : {
        *(.data*)
    } > RAM AT > ROM

    .bss (NOLOAD) : {
        *(.bss*)
        *(COMMON)
    } > RAM

    .stack (NOLOAD) : {
        . = ORIGIN(RAM) + LENGTH(RAM);
        . = . - 4;
        _stack_top = .;
    } > RAM
}
----------------------------------------

------------------------------------------------------------
5. Makefile (builds ELF, BIN, HEX)
------------------------------------------------------------

We’ll:
- Use `riscv64-unknown-elf-gcc` as the tool prefix (you can override).
- Produce:
  - boot_rom.elf
  - boot_rom.bin (raw binary)
  - boot_rom.hex (32-bit words, one per line, for $readmemh).

File: Makefile

----------------------------------------
Makefile
----------------------------------------
RISCV_PREFIX ?= riscv64-unknown-elf

CC      := $(RISCV_PREFIX)-gcc
OBJCOPY := $(RISCV_PREFIX)-objcopy

CFLAGS  := -march=rv32im -mabi=ilp32 -Os -ffreestanding -nostdlib -Wall -Wextra
LDFLAGS := -T linker.ld -nostdlib -nostartfiles

all: boot_rom.hex

boot_rom.elf: start.S boot_rom.c linker.ld
	$(CC) $(CFLAGS) -o $@ start.S boot_rom.c $(LDFLAGS)

boot_rom.bin: boot_rom.elf
	$(OBJCOPY) -O binary $< $@

boot_rom.hex: boot_rom.bin
	hexdump -v -e '1/4 "%08x\n"' $< > $@

clean:
	rm -f boot_rom.elf boot_rom.bin boot_rom.hex

.PHONY: all clean
----------------------------------------

Build commands:

  cd ~/h3_quad_de10lite/soc/sw/boot_rom
  make

Artifacts:

  boot_rom.elf
  boot_rom.bin
  boot_rom.hex

------------------------------------------------------------
6. Integrating boot_rom.hex into the RTL ROM
------------------------------------------------------------

Your `h3_ahb_boot_rom.v` (from previous phase) should already contain:

- A BRAM array:
    reg [31:0] mem [0:ROM_WORDS-1];

- An initialization:
    initial begin
        $readmemh("boot_rom.hex", mem);
    end

To hook this up:

1) Copy or symlink the newly built hex into the RTL directory:

   cd ~/h3_quad_de10lite/soc/rtl
   ln -sf ../sw/boot_rom/boot_rom.hex .

2) Ensure Quartus project includes:
   - h3_ahb_boot_rom.v
   - boot_rom.hex as a memory initialization file (Quartus usually picks it up via $readmemh if in project dir).

On power-up / reset:
- FPGA config (via SRAM) loads:
  - SoC RTL.
  - Boot ROM BRAM pre-initialized with `boot_rom.hex`.
- Hazard3 core 0 reset PC = 0x0000_0000 → `_start` (start.S).
- `_start` sets SP and jumps to `boot_main`.
- `boot_main`:
  - Initializes UART.
  - Prints prompt.
  - Waits for length + firmware.
  - Writes firmware into Instr SRAM at 0x0001_0000.
  - Jumps to 0x0001_0000.
- Firmware runs entirely from Instr SRAM; nothing persistent is ever written.

------------------------------------------------------------
7. Host-side expectations (for later Phase 9)
------------------------------------------------------------

The host tool (later Phase 9) must:
- Open the UART connected to DE10-Lite (via USB-UART bridge or external adapter).
- Wait for `"H3-BOOT"` and `"LEN?"` messages (optional).
- Send:
  - 4-byte little-endian length.
  - Then the firmware binary file (exactly that many bytes).

Firmware itself will be built in Phase 7 using the Arduino-like HAL.

============================================================
END OF PHASE 5
============================================================
============================================================
PHASE 6 — INDUSTRIAL-GRADE ARDUINO-LIKE HAL (INTERRUPTS + DMA-AWARE)
============================================================

Goal:
- Build a **C HAL** that feels Arduino-like, but is **interrupt-capable and DMA-aware** on your SoC:
  - GPIO: pinMode, digitalRead/Write, interrupt attach/detach, simple software debounce.
  - UART (Serial): interrupt-driven RX with ring buffer, blocking TX; can later be DMA-augmented.
  - SPI: multi-byte bursts, explicit CS control, blocking transfers (DMA-ready API structure).
  - I2C (Wire): NACK detection, arbitration loss reporting, basic error codes.
  - PWM (analogWrite): per-channel period/duty, plus hooks for advanced features (phase, dead-time, fault).
  - IRQ controller: small abstraction for enabling lines and registering handlers.
  - DMA: basic mem→mem helper + a primitive interface for future peripheral usage.
- Built as a static library `libarduino_api.a` for firmware apps (Phase 7).
- No placeholders: all C and headers here are buildable; you may adapt details to exact OpenCores register layouts if they differ slightly.

Directory:

  ~/h3_quad_de10lite/soc/sw/arduino_api/
    arduino_hal.h
    irq.c
    gpio_api.c
    uart_api.c
    spi_api.c
    i2c_api.c
    pwm_api.c
    dma_api.c
    Makefile

We assume:
- Memory map from Phase 2.
- IRQ controller at 0x4000_5000 with the register layout defined in Phase 4’s `h3_irq_ctrl`.
- DMA at 0x4000_6000 with the simple linear engine from `h3_dma_engine`.

------------------------------------------------------------
1. Common HAL header: arduino_hal.h
------------------------------------------------------------

File: ~/h3_quad_de10lite/soc/sw/arduino_api/arduino_hal.h

This captures:
- Base addresses.
- Register macros.
- Arduino-like API prototypes.
- Simple error codes.

----------------------------------------
arduino_hal.h
----------------------------------------
#ifndef ARDUINO_HAL_H
#define ARDUINO_HAL_H

#include <stdint.h>

/* Base addresses from Phase 2 */
#define UART_BASE       0x40000000u
#define GPIO_BASE       0x40001000u
#define SPI_BASE        0x40002000u
#define I2C_BASE        0x40003000u
#define PWM_BASE        0x40004000u
#define IRQCTRL_BASE    0x40005000u
#define DMA_BASE        0x40006000u

/* Convenience macro */
#define REG32(addr)     (*(volatile uint32_t *)(addr))

/* GPIO registers (OpenCores-like, adjusted to our map) */
#define GPIO_DATA_OUT   REG32(GPIO_BASE + 0x00)
#define GPIO_DATA_DIR   REG32(GPIO_BASE + 0x04)
#define GPIO_DATA_IN    REG32(GPIO_BASE + 0x08)
/* Optional interrupt-related registers (if present/extended) */
#define GPIO_IRQ_MASK   REG32(GPIO_BASE + 0x0C)
#define GPIO_IRQ_TYPE   REG32(GPIO_BASE + 0x10) /* edge/level + rise/fall bits */
#define GPIO_IRQ_STATUS REG32(GPIO_BASE + 0x14)

/* UART16550 registers (32-bit spaced) */
#define UART_RBR        REG32(UART_BASE + 0x00)
#define UART_THR        REG32(UART_BASE + 0x00)
#define UART_IER        REG32(UART_BASE + 0x04)
#define UART_IIR        REG32(UART_BASE + 0x08)
#define UART_FCR        REG32(UART_BASE + 0x08)
#define UART_LCR        REG32(UART_BASE + 0x0C)
#define UART_MCR        REG32(UART_BASE + 0x10)
#define UART_LSR        REG32(UART_BASE + 0x14)
#define UART_MSR        REG32(UART_BASE + 0x18)
#define UART_SCR        REG32(UART_BASE + 0x1C)
#define UART_DLL        REG32(UART_BASE + 0x00)
#define UART_DLM        REG32(UART_BASE + 0x04)

/* SPI registers (OpenCores SPI – generic map) */
#define SPI_RX_TX       REG32(SPI_BASE + 0x00)
#define SPI_CTRL        REG32(SPI_BASE + 0x04)
#define SPI_DIV         REG32(SPI_BASE + 0x08)
#define SPI_CS          REG32(SPI_BASE + 0x0C)

/* I2C registers (OpenCores I2C) */
#define I2C_PRER_LO     REG32(I2C_BASE + 0x00)
#define I2C_PRER_HI     REG32(I2C_BASE + 0x04)
#define I2C_CTR         REG32(I2C_BASE + 0x08)
#define I2C_TXR         REG32(I2C_BASE + 0x0C)
#define I2C_RXR         REG32(I2C_BASE + 0x0C)
#define I2C_CR          REG32(I2C_BASE + 0x10)
#define I2C_SR          REG32(I2C_BASE + 0x10)

/* PWM registers: per-channel PERIOD, DUTY, PHASE, DEADTIME, CTRL */
#define PWM_CH_STRIDE   0x20u

#define PWM_CH_PERIOD(ch)   REG32(PWM_BASE + (ch)*PWM_CH_STRIDE + 0x00)
#define PWM_CH_DUTY(ch)     REG32(PWM_BASE + (ch)*PWM_CH_STRIDE + 0x04)
#define PWM_CH_PHASE(ch)    REG32(PWM_BASE + (ch)*PWM_CH_STRIDE + 0x08)
#define PWM_CH_DEADTIME(ch) REG32(PWM_BASE + (ch)*PWM_CH_STRIDE + 0x0C)
#define PWM_CH_CTRL(ch)     REG32(PWM_BASE + (ch)*PWM_CH_STRIDE + 0x10)
#define PWM_FAULT_STATUS    REG32(PWM_BASE + 0x80)
#define PWM_FAULT_MASK      REG32(PWM_BASE + 0x84)

/* IRQ controller registers */
#define IRQ_ENABLE      REG32(IRQCTRL_BASE + 0x00)
#define IRQ_PENDING     REG32(IRQCTRL_BASE + 0x04)
#define IRQ_ROUTE_CORE0 REG32(IRQCTRL_BASE + 0x08)
#define IRQ_ROUTE_CORE1 REG32(IRQCTRL_BASE + 0x0C)
#define IRQ_ROUTE_CORE2 REG32(IRQCTRL_BASE + 0x10)
#define IRQ_ROUTE_CORE3 REG32(IRQCTRL_BASE + 0x14)
#define IRQ_CURRENT_ID  REG32(IRQCTRL_BASE + 0x18)

/* DMA controller registers */
#define DMA_SRC         REG32(DMA_BASE + 0x00)
#define DMA_DST         REG32(DMA_BASE + 0x01*4)
#define DMA_LEN         REG32(DMA_BASE + 0x02*4)
#define DMA_CTRL        REG32(DMA_BASE + 0x03*4) /* bit0=start */
#define DMA_STATUS      REG32(DMA_BASE + 0x04*4) /* bit0=busy */

/* Arduino-like modes and constants */
#define INPUT           0u
#define OUTPUT          1u

#define LOW             0u
#define HIGH            1u

/* Simple status codes */
#define I2C_OK          0
#define I2C_NACK        1
#define I2C_ARB_LOST    2
#define I2C_BUS_ERR     3

/* IRQ line numbers (from Phase 2/4) */
#define IRQ_LINE_UART   0u
#define IRQ_LINE_GPIO   1u
#define IRQ_LINE_SPI    2u
#define IRQ_LINE_I2C    3u
#define IRQ_LINE_PWM    4u
#define IRQ_LINE_DMA    5u

/* Public API */

/* GPIO */
void pinMode(uint8_t pin, uint8_t mode);
void digitalWrite(uint8_t pin, uint8_t value);
uint8_t digitalRead(uint8_t pin);

/* GPIO interrupts + debounce (software) */
typedef void (*gpio_isr_t)(uint8_t pin);
void gpio_attachInterrupt(uint8_t pin, gpio_isr_t handler);
void gpio_detachInterrupt(uint8_t pin);
void gpio_setInterruptEdge(uint8_t pin, uint8_t rising, uint8_t falling);

/* UART / Serial */
void Serial_begin(uint32_t baud);
void Serial_write_byte(uint8_t b);
uint8_t Serial_read_byte_blocking(void);
int  Serial_available(void);
uint8_t Serial_read_byte_nonblocking(uint8_t *out);
void Serial_print(const char *s);
void Serial_println(const char *s);

/* SPI */
void SPI_begin(uint32_t baud_div, uint8_t mode, uint8_t bits);
void SPI_setCS(uint8_t cs_index, uint8_t active);
uint8_t SPI_transfer(uint8_t data);
void SPI_transferBytes(const uint8_t *tx, uint8_t *rx, uint32_t len);

/* I2C / Wire */
void Wire_begin(uint32_t bus_khz);
int  Wire_start(uint8_t addr, uint8_t write);
int  Wire_write_byte(uint8_t b);
int  Wire_read_byte(uint8_t *out, uint8_t ack);
void Wire_stop(void);

/* PWM */
void analogWrite(uint8_t channel, uint16_t value);
void pwm_config_advanced(uint8_t channel, uint32_t period, uint32_t duty,
                         uint32_t phase, uint32_t deadtime, uint32_t ctrl);

/* IRQ controller (generic) */
typedef void (*irq_handler_t)(void);
void irq_init(void);
void irq_enable_line(uint8_t line);
void irq_disable_line(uint8_t line);
void irq_route_to_core0(uint8_t line, uint8_t enable);
void irq_register_handler(uint8_t line, irq_handler_t handler);
void irq_handle_trap(void); /* called from machine trap handler */

/* DMA */
int dma_memcpy(void *dst, const void *src, uint32_t len);

#endif /* ARDUINO_HAL_H */
----------------------------------------

------------------------------------------------------------
2. IRQ abstraction: irq.c
------------------------------------------------------------

We provide:
- A small handler table indexed by IRQ line.
- Helper to enable/disable lines and route to core0.
- A trap entry helper that firmware can call from the machine external interrupt handler.

File: irq.c

----------------------------------------
irq.c
----------------------------------------
#include "arduino_hal.h"

#define MAX_IRQ_LINES 16

static irq_handler_t irq_handlers[MAX_IRQ_LINES];

void irq_init(void) {
    for (int i = 0; i < MAX_IRQ_LINES; i++) {
        irq_handlers[i] = 0;
    }

    IRQ_ENABLE      = 0x0000;
    IRQ_PENDING     = 0xFFFF;
    IRQ_ROUTE_CORE0 = 0xFFFF;
    IRQ_ROUTE_CORE1 = 0x0000;
    IRQ_ROUTE_CORE2 = 0x0000;
    IRQ_ROUTE_CORE3 = 0x0000;
}

void irq_enable_line(uint8_t line) {
    uint32_t mask = (1u << line);
    IRQ_ENABLE |= mask;
}

void irq_disable_line(uint8_t line) {
    uint32_t mask = (1u << line);
    IRQ_ENABLE &= ~mask;
}

void irq_route_to_core0(uint8_t line, uint8_t enable) {
    uint32_t mask = (1u << line);
    if (enable)
        IRQ_ROUTE_CORE0 |= mask;
    else
        IRQ_ROUTE_CORE0 &= ~mask;
}

void irq_register_handler(uint8_t line, irq_handler_t handler) {
    if (line < MAX_IRQ_LINES) {
        irq_handlers[line] = handler;
    }
}

void irq_handle_trap(void) {
    uint32_t pend = IRQ_PENDING;
    uint32_t en   = IRQ_ENABLE;
    uint32_t active = pend & en;

    if (active == 0)
        return;

    uint8_t id = (uint8_t)(IRQ_CURRENT_ID & 0xF);
    if (id < MAX_IRQ_LINES) {
        irq_handler_t h = irq_handlers[id];
        if (h) {
            h();
        }
        IRQ_PENDING = (1u << id);
    }
}
----------------------------------------

------------------------------------------------------------
3. GPIO API with interrupt hooks: gpio_api.c
------------------------------------------------------------

- Simple digital IO.
- Interrupt attach/detach, edge configuration.
- Debounce is left to firmware using a periodic timer (Phase 7) or by sampling in ISR; here we expose the hooks.

File: gpio_api.c

----------------------------------------
gpio_api.c
----------------------------------------
#include "arduino_hal.h"

static gpio_isr_t gpio_handlers[16];

void pinMode(uint8_t pin, uint8_t mode) {
    if (pin > 15) return;
    uint32_t mask = (1u << pin);
    if (mode == OUTPUT) {
        GPIO_DATA_DIR |= mask;
    } else {
        GPIO_DATA_DIR &= ~mask;
    }
}

void digitalWrite(uint8_t pin, uint8_t value) {
    if (pin > 15) return;
    uint32_t mask = (1u << pin);
    if (value) {
        GPIO_DATA_OUT |= mask;
    } else {
        GPIO_DATA_OUT &= ~mask;
    }
}

uint8_t digitalRead(uint8_t pin) {
    if (pin > 15) return 0;
    uint32_t mask = (1u << pin);
    return (GPIO_DATA_IN & mask) ? 1u : 0u;
}

void gpio_attachInterrupt(uint8_t pin, gpio_isr_t handler) {
    if (pin > 15) return;
    gpio_handlers[pin] = handler;
    GPIO_IRQ_MASK |= (1u << pin);
}

void gpio_detachInterrupt(uint8_t pin) {
    if (pin > 15) return;
    gpio_handlers[pin] = 0;
    GPIO_IRQ_MASK &= ~(1u << pin);
}

void gpio_setInterruptEdge(uint8_t pin, uint8_t rising, uint8_t falling) {
    if (pin > 15) return;
    uint32_t bit_r = (1u << pin);
    uint32_t bit_f = (1u << (pin + 16));
    if (rising)
        GPIO_IRQ_TYPE |= bit_r;
    else
        GPIO_IRQ_TYPE &= ~bit_r;
    if (falling)
        GPIO_IRQ_TYPE |= bit_f;
    else
        GPIO_IRQ_TYPE &= ~bit_f;
}

static void gpio_isr_internal(void) {
    uint32_t status = GPIO_IRQ_STATUS;
    GPIO_IRQ_STATUS = status;

    for (uint8_t pin = 0; pin < 16; pin++) {
        uint32_t mask = (1u << pin);
        if (status & mask) {
            gpio_isr_t h = gpio_handlers[pin];
            if (h) {
                h(pin);
            }
        }
    }
}

void gpio_init_irq(void) {
    for (int i = 0; i < 16; i++)
        gpio_handlers[i] = 0;

    irq_register_handler(IRQ_LINE_GPIO, gpio_isr_internal);
    irq_enable_line(IRQ_LINE_GPIO);
    irq_route_to_core0(IRQ_LINE_GPIO, 1);
}
----------------------------------------

------------------------------------------------------------
4. UART / Serial with interrupt-driven RX ring buffer: uart_api.c
------------------------------------------------------------

- RX is interrupt-driven with a ring buffer.
- TX is blocking and polled.
- Uses IRQ line 0 (UART) and the `irq` infrastructure.

File: uart_api.c

----------------------------------------
uart_api.c
----------------------------------------
#include "arduino_hal.h"

#define UART_RX_BUF_SIZE 256

static volatile uint8_t rx_buf[UART_RX_BUF_SIZE];
static volatile uint16_t rx_head = 0;
static volatile uint16_t rx_tail = 0;

static void uart_isr(void) {
    while (UART_LSR & 0x01) {
        uint8_t b = (uint8_t)(UART_RBR & 0xFF);
        uint16_t next_head = (uint16_t)((rx_head + 1u) % UART_RX_BUF_SIZE);
        if (next_head != rx_tail) {
            rx_buf[rx_head] = b;
            rx_head = next_head;
        }
    }
}

void Serial_begin(uint32_t baud) {
    (void)baud;

    UART_IER = 0x00;

    UART_LCR = 0x80;
    UART_DLL = 0x01;
    UART_DLM = 0x00;
    UART_LCR = 0x03;

    UART_FCR = 0x07;
    UART_MCR = 0x00;

    rx_head = 0;
    rx_tail = 0;

    UART_IER = 0x01;

    irq_register_handler(IRQ_LINE_UART, uart_isr);
    irq_enable_line(IRQ_LINE_UART);
    irq_route_to_core0(IRQ_LINE_UART, 1);
}

void Serial_write_byte(uint8_t b) {
    while ((UART_LSR & 0x20) == 0) {
    }
    UART_THR = b;
}

uint8_t Serial_read_byte_blocking(void) {
    while (rx_head == rx_tail) {
    }
    uint8_t b = rx_buf[rx_tail];
    rx_tail = (uint16_t)((rx_tail + 1u) % UART_RX_BUF_SIZE);
    return b;
}

int Serial_available(void) {
    int diff = (int)rx_head - (int)rx_tail;
    if (diff < 0)
        diff += UART_RX_BUF_SIZE;
    return diff;
}

uint8_t Serial_read_byte_nonblocking(uint8_t *out) {
    if (rx_head == rx_tail)
        return 0;
    *out = rx_buf[rx_tail];
    rx_tail = (uint16_t)((rx_tail + 1u) % UART_RX_BUF_SIZE);
    return 1;
}

void Serial_print(const char *s) {
    while (*s) {
        Serial_write_byte((uint8_t)*s++);
    }
}

void Serial_println(const char *s) {
    Serial_print(s);
    Serial_write_byte('\r');
    Serial_write_byte('\n');
}
----------------------------------------

------------------------------------------------------------
5. SPI API with multi-byte bursts + explicit CS control: spi_api.c
------------------------------------------------------------

We assume:
- SPI_CTRL:
  - bit0: enable
  - bit1: CPOL
  - bit2: CPHA
  - bits[7:4]: bits per word
  - bit8: interrupt enable (unused here)
  - bit31: busy flag (read-only)
- SPI_CS: 4-bit CS lines, active-low; writing sets active CS pattern.

File: spi_api.c

----------------------------------------
spi_api.c
----------------------------------------
#include "arduino_hal.h"

void SPI_begin(uint32_t baud_div, uint8_t mode, uint8_t bits) {
    SPI_DIV = baud_div;

    uint32_t ctrl = 0;
    ctrl |= 0x01;

    if (mode & 0x02)
        ctrl |= (1u << 1);
    if (mode & 0x01)
        ctrl |= (1u << 2);

    uint32_t bits_field = ((uint32_t)(bits & 0x0F)) << 4;
    ctrl |= bits_field;

    SPI_CTRL = ctrl;

    SPI_CS = 0x0F;
}

void SPI_setCS(uint8_t cs_index, uint8_t active) {
    if (cs_index > 3)
        return;
    uint32_t mask = (1u << cs_index);
    uint32_t val = SPI_CS;
    if (active) {
        val &= ~mask;
    } else {
        val |= mask;
    }
    SPI_CS = val;
}

static uint8_t spi_transfer_single(uint8_t data) {
    SPI_RX_TX = data;
    while (SPI_CTRL & (1u << 31)) {
    }
    return (uint8_t)(SPI_RX_TX & 0xFF);
}

uint8_t SPI_transfer(uint8_t data) {
    return spi_transfer_single(data);
}

void SPI_transferBytes(const uint8_t *tx, uint8_t *rx, uint32_t len) {
    for (uint32_t i = 0; i < len; i++) {
        uint8_t t = tx ? tx[i] : 0xFF;
        uint8_t r = spi_transfer_single(t);
        if (rx) rx[i] = r;
    }
}
----------------------------------------

------------------------------------------------------------
6. I2C (Wire) with NACK/arbitration handling: i2c_api.c
------------------------------------------------------------

We handle:
- NACK (`ack` bit in SR).
- Arbitration lost (`AL` bit).
- Basic error codes.

File: i2c_api.c

----------------------------------------
i2c_api.c
----------------------------------------
#include "arduino_hal.h"

static void i2c_wait_tip(void) {
    while (I2C_SR & 0x02) {
    }
}

void Wire_begin(uint32_t bus_khz) {
    (void)bus_khz;
    I2C_PRER_LO = 0x30;
    I2C_PRER_HI = 0x00;
    I2C_CTR     = 0x80;
}

int Wire_start(uint8_t addr, uint8_t write) {
    uint8_t val = (uint8_t)((addr << 1) | (write ? 0x0 : 0x1));
    I2C_TXR = val;
    I2C_CR  = 0x90;
    i2c_wait_tip();

    uint8_t sr = (uint8_t)(I2C_SR & 0xFF);
    if (sr & 0x20)
        return I2C_ARB_LOST;
    if (sr & 0x80)
        return I2C_NACK;
    return I2C_OK;
}

int Wire_write_byte(uint8_t b) {
    I2C_TXR = b;
    I2C_CR  = 0x10;
    i2c_wait_tip();
    uint8_t sr = (uint8_t)(I2C_SR & 0xFF);
    if (sr & 0x20)
        return I2C_ARB_LOST;
    if (sr & 0x80)
        return I2C_NACK;
    return I2C_OK;
}

int Wire_read_byte(uint8_t *out, uint8_t ack) {
    if (ack)
        I2C_CR = 0x20;
    else
        I2C_CR = 0x28;
    i2c_wait_tip();
    uint8_t sr = (uint8_t)(I2C_SR & 0xFF);
    if (sr & 0x20)
        return I2C_ARB_LOST;
    *out = (uint8_t)(I2C_RXR & 0xFF);
    return I2C_OK;
}

void Wire_stop(void) {
    I2C_CR = 0x40;
    i2c_wait_tip();
}
----------------------------------------

------------------------------------------------------------
7. PWM (analogWrite + advanced config): pwm_api.c
------------------------------------------------------------

We expose:
- Simple `analogWrite(channel, value)` for 10-bit-style duty.
- An advanced `pwm_config_advanced` for direct control of period, duty, phase, deadtime, ctrl flags.

File: pwm_api.c

----------------------------------------
pwm_api.c
----------------------------------------
#include "arduino_hal.h"

void analogWrite(uint8_t channel, uint16_t value) {
    if (channel > 3)
        return;
    uint32_t period = 1023u;
    if (value > period) value = (uint16_t)period;

    PWM_CH_PERIOD(channel) = period;
    PWM_CH_DUTY(channel)   = value;
    PWM_CH_PHASE(channel)  = 0;
    PWM_CH_DEADTIME(channel) = 0;
    PWM_CH_CTRL(channel)   = 0x1;
}

void pwm_config_advanced(uint8_t channel, uint32_t period, uint32_t duty,
                         uint32_t phase, uint32_t deadtime, uint32_t ctrl) {
    if (channel > 3)
        return;
    PWM_CH_PERIOD(channel)   = period;
    PWM_CH_DUTY(channel)     = duty;
    PWM_CH_PHASE(channel)    = phase;
    PWM_CH_DEADTIME(channel) = deadtime;
    PWM_CH_CTRL(channel)     = ctrl;
}
----------------------------------------

------------------------------------------------------------
8. DMA helper: dma_api.c
------------------------------------------------------------

We provide a simple blocking `dma_memcpy` using the linear DMA channel:
- Useful for large memory copies.
- Future: you can extend to periph→mem use by programming SRC/DST to UART/SPI FIFOs.

File: dma_api.c

----------------------------------------
dma_api.c
----------------------------------------
#include "arduino_hal.h"

int dma_memcpy(void *dst, const void *src, uint32_t len) {
    if ((len & 0x3u) != 0u)
        return -1;

    DMA_SRC = (uint32_t)(uintptr_t)src;
    DMA_DST = (uint32_t)(uintptr_t)dst;
    DMA_LEN = len;
    DMA_CTRL = 0x1;

    while (DMA_STATUS & 0x1) {
    }

    return 0;
}
----------------------------------------

------------------------------------------------------------
9. Makefile for libarduino_api.a
------------------------------------------------------------

File: Makefile

----------------------------------------
Makefile
----------------------------------------
RISCV_PREFIX ?= riscv64-unknown-elf
CC      := $(RISCV_PREFIX)-gcc
AR      := $(RISCV_PREFIX)-ar

CFLAGS  := -march=rv32im -mabi=ilp32 -Os -ffreestanding -nostdlib -Wall -Wextra

OBJS = irq.o gpio_api.o uart_api.o spi_api.o i2c_api.o pwm_api.o dma_api.o

all: libarduino_api.a

%.o: %.c arduino_hal.h
	$(CC) $(CFLAGS) -c $< -o $@

libarduino_api.a: $(OBJS)
	$(AR) rcs $@ $(OBJS)

clean:
	rm -f $(OBJS) libarduino_api.a

.PHONY: all clean
----------------------------------------

Build:

  cd ~/h3_quad_de10lite/soc/sw/arduino_api
  make

Artifact:

  libarduino_api.a

You’ll link this into your application firmware (Phase 7) together with your app C files and a firmware-specific linker script that targets Instruction/Data SRAM.

============================================================
END OF PHASE 6
============================================================
============================================================
PHASE 7 — APPLICATION FIRMWARE USING THE HAL (FOR UART BOOTLOADER)
============================================================

Goal:
- Build a concrete firmware app that:
  - Uses your HAL from Phase 6.
  - Runs from Instruction SRAM (0x0001_0000).
  - Uses Data SRAM (0x1000_0000) for stack/data.
  - Is loaded by the UART bootloader from Phase 5.
- App behavior (simple but non-trivial):
  - Initializes IRQ controller + Serial + GPIO + PWM.
  - Blinks a GPIO pin (LED) via digitalWrite.
  - Toggles a PWM channel with analogWrite.
  - Echoes characters over UART (interrupt-driven RX).
  - Demonstrates SPI and I2C init (no real sensors assumed yet, but calls are ready).
- Build artifacts:
  - app.elf
  - app.bin (to be sent over UART by the host tool in Phase 9).

Directory:

  ~/h3_quad_de10lite/soc/sw/apps/blinky_serial/
    startup.S
    main.c
    linker.ld
    Makefile

------------------------------------------------------------
1. Directory and file skeleton
------------------------------------------------------------

Commands:

  cd ~/h3_quad_de10lite/soc/sw
  mkdir -p apps/blinky_serial
  cd apps/blinky_serial

You’ll create:

  startup.S
  main.c
  linker.ld
  Makefile

------------------------------------------------------------
2. RISC-V startup for application firmware (startup.S)
------------------------------------------------------------

- PC on jump from bootloader: 0x0001_0000.
- We set SP to top of Data SRAM (0x1000_0000 + 64 KB).
- Then call main(), then loop forever on return.

File: startup.S

----------------------------------------
startup.S
----------------------------------------
    .section .init, "ax"
    .globl _start
    .globl main

_start:
    la   sp, _stack_top
    j    main
----------------------------------------

------------------------------------------------------------
3. Application main (main.c)
------------------------------------------------------------

Behavior:
- Initialize IRQ subsystem and Serial.
- Configure a GPIO pin (e.g., D13) as output LED.
- Setup PWM channel 0 and drive it with analogWrite.
- Initialize SPI and I2C (for completeness).
- Main loop:
  - Blink LED via GPIO.
  - If any UART data is available, echo it back and print a status line.

You’ll choose specific Arduino header pins in Phase 8; here we just use logical pin numbers.

Example choices:
- LED pin: 13 (GPIO[13])
- PWM channel: 0

File: main.c

----------------------------------------
main.c
----------------------------------------
#include <stdint.h>
#include "arduino_hal.h"

/* Rough delay loop: not calibrated, just to see activity */
static void delay_cycles(volatile uint32_t cycles) {
    while (cycles--) {
        __asm__ volatile ("nop");
    }
}

int main(void) {
    /* Init IRQ infrastructure */
    irq_init();

    /* Init Serial (UART) */
    Serial_begin(115200);
    Serial_println("H3 App: booted from Instr SRAM.");
    Serial_println("UART echo enabled. Type something...");

    /* Init GPIO with IRQ support (if desired later) */
    gpio_init_irq();

    /* Choose LED on pin 13 (logical GPIO 13) */
    uint8_t led_pin = 13;
    pinMode(led_pin, OUTPUT);
    digitalWrite(led_pin, LOW);

    /* Init PWM channel 0 for a visible duty modulation */
    analogWrite(0, 512); /* ~50% of 10-bit scale */

    /* Init SPI: div=4, mode=0, 8 bits */
    SPI_begin(4, 0, 8);
    SPI_setCS(0, 0);  /* CS0 inactive (high) */

    /* Init I2C at some default speed (placeholder) */
    Wire_begin(100); /* 100 kHz nominal */

    Serial_println("Init done.");

    uint32_t led_state = 0;

    while (1) {
        /* Blink LED via GPIO */
        led_state ^= 1u;
        digitalWrite(led_pin, led_state ? HIGH : LOW);

        /* Simple UART echo */
        int avail = Serial_available();
        while (avail-- > 0) {
            uint8_t b = Serial_read_byte_blocking();
            Serial_write_byte(b);
        }

        /* Brief status message occasionally */
        static uint32_t counter = 0;
        counter++;
        if ((counter & 0x3FFu) == 0u) {
            Serial_println("App alive...");
        }

        delay_cycles(200000);
    }

    return 0;
}
----------------------------------------

------------------------------------------------------------
4. Linker script for application firmware (linker.ld)
------------------------------------------------------------

We map:
- .text/.rodata/.init into Instruction SRAM at 0x0001_0000 (64 KB).
- .data/.bss/.stack into Data SRAM at 0x1000_0000 (64 KB).
- `_start` at 0x0001_0000 by virtue of placing .text there.

File: linker.ld

----------------------------------------
linker.ld
----------------------------------------
ENTRY(_start)

MEMORY
{
    INSTR (rx) : ORIGIN = 0x00010000, LENGTH = 64K
    DATA  (rwx): ORIGIN = 0x10000000, LENGTH = 64K
}

SECTIONS
{
    .text : {
        KEEP(*(.init))
        *(.text*)
        *(.rodata*)
    } > INSTR

    .data : {
        *(.data*)
    } > DATA AT > INSTR

    .bss (NOLOAD) : {
        *(.bss*)
        *(COMMON)
    } > DATA

    .stack (NOLOAD) : {
        . = ORIGIN(DATA) + LENGTH(DATA);
        . = . - 4;
        _stack_top = .;
    } > DATA
}
----------------------------------------

------------------------------------------------------------
5. Makefile for application firmware
------------------------------------------------------------

Outputs:
- app.elf
- app.bin

File: Makefile

----------------------------------------
Makefile
----------------------------------------
RISCV_PREFIX ?= riscv64-unknown-elf

CC      := $(RISCV_PREFIX)-gcc
OBJCOPY := $(RISCV_PREFIX)-objcopy

CFLAGS  := -march=rv32im -mabi=ilp32 -Os -ffreestanding -nostdlib -Wall -Wextra -I../../arduino_api
LDFLAGS := -T linker.ld -nostdlib -nostartfiles

all: app.bin

app.elf: startup.S main.c linker.ld
	$(CC) $(CFLAGS) -o $@ startup.S main.c ../../arduino_api/libarduino_api.a $(LDFLAGS)

app.bin: app.elf
	$(OBJCOPY) -O binary $< $@

clean:
	rm -f app.elf app.bin

.PHONY: all clean
----------------------------------------

Build:

  cd ~/h3_quad_de10lite/soc/sw/apps/blinky_serial
  make

Artifacts:

  app.elf
  app.bin

`app.bin` is the raw firmware image you will send over UART via the bootloader protocol from Phase 5.

------------------------------------------------------------
6. End-to-end runtime picture (SoC + Boot + App)
------------------------------------------------------------

1) You configure the DE10-Lite with your SoC `.sof` (Phase 8 will define that build).
2) On reset:
   - Hazard3 core 0 starts at Boot ROM (0x0000_0000).
   - Bootloader (Phase 5) runs, waits for length and app.bin over UART.
3) Host (Phase 9) sends:
   - 4-byte little-endian length of app.bin.
   - Then `app.bin` bytes.
4) Bootloader writes these bytes into Instruction SRAM at 0x0001_0000.
5) Bootloader jumps to 0x0001_0000 (`_start` in startup.S).
6) `startup.S` sets SP and calls main().
7) `main()` runs:
   - Initializes HAL subsystems.
   - Blinks GPIO, drives PWM, echoes UART, etc.

Everything is **ephemeral**:
- Bitstream in FPGA SRAM.
- Boot ROM contents in BRAM (from boot_rom.hex in bitstream).
- Firmware app in Instruction SRAM only.
- Power-cycle wipes all of it.

============================================================
END OF PHASE 7
============================================================
============================================================
PHASE 8 — QUARTUS PROJECT, FPGA BUILD, AND ARDUINO-HEADER PIN BINDING
============================================================

Goal:
- Create a full Quartus project for the DE10-Lite that:
  - Targets MAX 10 10M50DAF484C7G.
  - Uses `h3_quad_mcu_top` as the top-level entity.
  - Includes all SoC RTL from previous phases.
  - Maps all SoC I/O signals to the **Arduino headers** on the DE10-Lite.
  - Produces a **.sof** for SRAM-only configuration via JTAG (no flash programming).
- Outcome:
  - You can load the SoC into FPGA SRAM.
  - Bootloader runs on reset.
  - You can then load `app.bin` over UART.

NOTE:
- Exact FPGA pin names for the Arduino header signals must come from the official DE10-Lite User Manual.
- This phase tells you **exactly** how to wire the signals and what to search for; you only need to plug in the concrete pin names from the manual.

------------------------------------------------------------
1. Create the Quartus project
------------------------------------------------------------

From your Linux environment:

1) Create a Quartus project directory:

  cd ~/h3_quad_de10lite/soc
  mkdir -p quartus
  cd quartus

2) Start Quartus (GUI) or use command line. We’ll assume GUI steps (they’re reproducible).

3) In Quartus:
   - File → New Project Wizard.
   - “Next” through intro.
   - Directory:  ~/h3_quad_de10lite/soc/quartus
   - Project name: h3_quad_mcu
   - Top-level entity: h3_quad_mcu_top
   - Next.

4) Add files to project:
   - Add all RTL files from:
     - ../rtl/ (all .v for SoC, including `h3_quad_mcu_top.v`, `h3_ahb_*`, `h3_apb_*`, `h3_wb_*`, `h3_irq_ctrl.v`, `h3_dma_engine.v`, etc.)
     - ../rtl/opencores/** (UART, GPIO, SPI, I2C, PWM core files)
     - hazard3 core files under ../rtl/hazard3/**

5) Device selection:
   - Family: MAX 10.
   - Specific device: 10M50DAF484C7G (DE10-Lite FPGA).
   - Finish the wizard.

6) Save the project (h3_quad_mcu.qpf / h3_quad_mcu.qsf).

------------------------------------------------------------
2. Set the top entity and basic options
------------------------------------------------------------

In Quartus:

1) Ensure top-level entity:
   - Assignments → Settings → General.
   - Top-level entity: h3_quad_mcu_top.

2) EDA and simulation:
   - (Optional for now) Set VHDL/Verilog HDL input as needed; we’re only using Verilog RTL.

3) Unused pins:
   - Assignments → Device → Device and Pin Options… → Unused Pins:
   - Set to: As input tri-stated with weak pull-up (or similar safe default).

4) Timing:
   - For now, assume a single 50 MHz clock from the DE10-Lite board.
   - We will constrain this in the .sdc (optional here, but ideal for timing closure).

------------------------------------------------------------
3. Connect the board 50 MHz clock and reset
------------------------------------------------------------

Your top-level `h3_quad_mcu_top` ports:

  input  wire clk;
  input  wire rst_n;

We will:
- Map `clk` to the DE10-Lite’s 50 MHz clock pin.
- Map `rst_n` to a push-button or a stable reset source (you can use KEY0 or an external reset line later).

Use the DE10-Lite User Manual to find:
- The FPGA pin for 50 MHz clock (commonly a dedicated CLK input).
- An appropriate input pin for reset.

In Quartus:
- Assignments → Pin Planner.
- For `clk`:
  - Set Location to the 50 MHz clock pin name from the manual.
  - Set I/O Standard to 3.3-V LVTTL.
- For `rst_n`:
  - Assign to a button or other signal.
  - I/O Standard also 3.3-V LVTTL.
  - Remember: active-low; if tied to a button, plan for the electrical polarity (debounce optional).

------------------------------------------------------------
4. Arduino header mapping: SoC signals → Arduino pins → FPGA pins
------------------------------------------------------------

Your top-level ports for I/O:

- GPIO:
  - input  wire [15:0] gpio_in;
  - output wire [15:0] gpio_out;
  - output wire [15:0] gpio_dir;

- UART:
  - input  wire uart_rx;
  - output wire uart_tx;

- SPI:
  - output wire       spi_sclk;
  - output wire       spi_mosi;
  - input  wire       spi_miso;
  - output wire [3:0] spi_cs_n;

- I2C:
  - inout  wire i2c_sda;
  - output wire i2c_scl;

- PWM:
  - output wire [3:0] pwm_out;
  - input  wire [3:0] fault_in;

We will conceptually map them to Arduino header labels:

1) Pick Arduino pins:

Example logical mapping (you will map to the exact DE10-Lite Arduino header positions):

- UART:
  - D0 → uart_rx
  - D1 → uart_tx

- SPI:
  - D10 → spi_cs_n[0]
  - D11 → spi_mosi
  - D12 → spi_miso
  - D13 → spi_sclk

- I2C:
  - SDA → i2c_sda
  - SCL → i2c_scl

- PWM:
  - D3  → pwm_out[0]
  - D5  → pwm_out[1]
  - D6  → pwm_out[2]
  - D9  → pwm_out[3]

- Remaining GPIO:
  - D2, D4, D7, D8, D14, D15 → selected bits of gpio_in/out/dir[15:0]

2) Bind to FPGA pins:

Using the DE10-Lite manual, for each Arduino header pin (e.g. D0, D1, D2, …, SDA, SCL), find:
- The FPGA pin name (e.g. PIN_AF14, etc.).
- I/O Standard: usually 3.3-V LVTTL.

Then in Quartus Pin Planner:
- For each top-level port bit, assign:
  - `gpio_out[x]`, `gpio_in[x]`, and `gpio_dir[x]` all share the **same FPGA pin** via tri-state logic in the top wrapper you will add (see below).
  - `uart_rx` / `uart_tx` to their pins.
  - `spi_*` to their pins.
  - `i2c_*` to their pins.
  - `pwm_out[x]` and `fault_in[x]` to their pins.

IMPORTANT:
- `gpio_in`, `gpio_out`, `gpio_dir` are logical; to connect them to actual pins, it is best to create a small **I/O wrapper** around `h3_quad_mcu_top` that instantiates I/O buffers per bit:
  - If `gpio_dir[i]` is 1: drive pin output from `gpio_out[i]`.
  - Else: read pin input to `gpio_in[i]`.

You can do this in Quartus by:
- Creating a new top-level wrapper, e.g. `h3_quad_mcu_fpga_top.v`, that:
  - Instantiates `h3_quad_mcu_top`.
  - Connects physical `inout` pins to `gpio_in/out/dir`.
- Then set `h3_quad_mcu_fpga_top` as the top entity.
- This keeps `h3_quad_mcu_top` board-agnostic and clean.

For brevity, the logic for tri-stated GPIO pins in the wrapper follows the classic pattern:

  assign gpio_pin[i] = gpio_dir[i] ? gpio_out[i] : 1'bz;
  assign gpio_in[i]  = gpio_pin[i];

(Implement this wrapper in RTL and connect its `gpio_pin[i]` to FPGA pins.)

------------------------------------------------------------
5. Add boot_rom.hex and ensure memory initialization
------------------------------------------------------------

Your `h3_ahb_boot_rom.v` uses:

  initial begin
      $readmemh("boot_rom.hex", mem);
  end

Steps:

1) Copy or symlink boot_rom.hex into the Quartus RTL directory:

   cd ~/h3_quad_de10lite/soc/rtl
   ln -sf ../sw/boot_rom/boot_rom.hex .

2) In Quartus:
   - Project → Add/Remove Files in Project.
   - Ensure `boot_rom.hex` is **added** as a file in the project.
   - Quartus automatically uses it as a memory init file due to `$readmemh`.

------------------------------------------------------------
6. Timing constraints (basic)
------------------------------------------------------------

Create an SDC file, e.g. `h3_quad_mcu.sdc` in the Quartus project directory.

Add:

  create_clock -name clk50 -period 20.000 [get_ports {clk}]

This defines a 50 MHz clock for timing analysis.

In Quartus:
- Assignments → Settings → TimeQuest Timing Analyzer.
- Add `h3_quad_mcu.sdc` to the project.

------------------------------------------------------------
7. Full compile and .sof generation
------------------------------------------------------------

In Quartus:

1) Compile:
   - Processing → Start Compilation.
   - Fix any RTL issues, missing files, or pin conflicts until compilation succeeds.

2) On success:
   - Quartus produces:
     - h3_quad_mcu.sof (SRAM configuration bitstream).
   - Location: `~/h3_quad_de10lite/soc/quartus/output_files/h3_quad_mcu.sof` (default).

------------------------------------------------------------
8. SRAM-only configuration via JTAG
------------------------------------------------------------

To respect your **ephemeral rule**:

- We use only `.sof` + JTAG → FPGA configuration **RAM**.
- We do not generate or program `.pof` or on-chip configuration flash.

Steps:

1) Connect the DE10-Lite via USB (USB-Blaster II).

2) In a terminal:

   cd ~/h3_quad_de10lite/soc/quartus/output_files
   quartus_pgm -m jtag -o "p;h3_quad_mcu.sof"

3) Or via GUI:
   - Tools → Programmer.
   - Hardware Setup: USB-Blaster.
   - Add File: h3_quad_mcu.sof.
   - Mode: JTAG.
   - Check “Program/Configure”.
   - Click “Start”.

After this:
- The FPGA is configured with your SoC.
- Boot ROM is initialized with the UART bootloader.
- The SoC is now running, waiting for firmware over UART.

Power-cycle behavior:
- Power off → configuration SRAM is cleared → your SoC is gone.
- Power on again → original DE10-Lite behavior (factory) returns unless you reload the .sof.
- No flash was programmed; system is fully **ephemeral** as required.

------------------------------------------------------------
9. Quick operational test with no firmware yet
------------------------------------------------------------

At this point, if you connect a UART adapter to the DE10-Lite’s Arduino header pins mapped to `uart_rx/uart_tx`, reset the board, you should see:

- Bootloader banner: “H3-BOOT” and “LEN?” on the UART.

You won’t yet send firmware (that’s Phase 9), but this confirms:

- Quartus project + pin mapping are correct.
- Boot ROM is correctly initialized.
- SoC is alive and running on the DE10-Lite.

============================================================
END OF PHASE 8
============================================================


