============================================================
PHASE 1 — LINUX VM + QUARTUS LITE + RISC‑V TOOLCHAIN SETUP
============================================================

----------------------------------------
1. Install VirtualBox on Windows
----------------------------------------
Download: https://www.virtualbox.org/wiki/Downloads
Install “Windows hosts” package with defaults.

----------------------------------------
2. Download Ubuntu 22.04.5 LTS ISO
----------------------------------------
Download: https://ubuntu.com/download/desktop
File: ubuntu-22.04.5-desktop-amd64.iso

----------------------------------------
3. Create VM in VirtualBox
----------------------------------------
Name: Ubuntu-Quartus
Type: Linux
Version: Ubuntu (64-bit)
Memory: 8192 MB (or 4096 MB minimum)
CPUs: 2+
Disk: 80 GB VDI, dynamically allocated
Attach ISO: Settings → Storage → Empty → Choose ISO

----------------------------------------
4. Install Ubuntu
----------------------------------------
Boot VM → Install Ubuntu
Normal installation
Install third-party software
Erase disk (virtual disk only)
Create user:
  Name: quartususer
  Username: quartususer
  Password: your choice
Finish installation → Reboot

----------------------------------------
5. Install VirtualBox Guest Additions
----------------------------------------
Inside Ubuntu:
sudo apt update
sudo apt install -y build-essential dkms linux-headers-$(uname -r)
VirtualBox menu → Devices → Insert Guest Additions CD
If not auto-run:
cd /media/$USER/VBox_GAs_*/
sudo ./VBoxLinuxAdditions.run
sudo reboot

----------------------------------------
6. Install Quartus Prime Lite (Linux)
----------------------------------------
Download from Intel:
https://www.intel.com/content/www/us/en/software-kit/795330/intel-quartus-prime-lite-edition-design-software-version.html
Download Linux installer:
QuartusLiteSetup-XX.Xstd.X.X-linux.run

Make executable:
cd ~/Downloads
chmod +x QuartusLiteSetup-*-linux.run

Run installer:
./QuartusLiteSetup-*-linux.run
Install Quartus Prime Lite + MAX 10 device support.

----------------------------------------
7. Install Quartus dependencies
----------------------------------------
sudo apt update
sudo apt install -y \
  build-essential \
  libx11-6 libxext6 libxft2 libxrender1 libxtst6 \
  libgtk2.0-0 libncurses5 libtinfo5 libxau6 libxdmcp6 \
  git curl wget unzip python3 python3-pip

----------------------------------------
8. Add Quartus to PATH
----------------------------------------
echo 'export PATH="$HOME/intelFPGA_lite/22.1std/quartus/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc

----------------------------------------
9. Install RISC‑V GCC Toolchain (RV32IM)
----------------------------------------
cd ~
git clone https://github.com/riscv-collab/riscv-gnu-toolchain.git
cd riscv-gnu-toolchain
sudo apt install -y gawk bison flex texinfo libgmp-dev libmpfr-dev libmpc-dev
./configure --prefix=$HOME/riscv --with-arch=rv32im --with-abi=ilp32 --disable-linux
make newlib -j$(nproc)

Add to PATH:
echo 'export PATH="$HOME/riscv/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc

Verify:
riscv32-unknown-elf-gcc -v

----------------------------------------
10. Install Python UART uploader dependencies
----------------------------------------
pip3 install pyserial

============================================================
END OF PHASE 1
============================================================
============================================================
PHASE 2 — PROJECT LAYOUT, HAZARD3 CLONE, MEMORY MAP, ADDRESS MAP
============================================================

Goal of this phase:
- Create a clean directory structure for the whole SoC.
- Clone Hazard3.
- Define memory map (Boot ROM, Instruction SRAM, Data SRAM).
- Define peripheral address map.
- Fix all paths that later phases will rely on.

All paths assume:
- Base directory:  $HOME/h3_quad_de10lite
- Hazard3 repo:    $HOME/h3_quad_de10lite/Hazard3
- SoC project:     $HOME/h3_quad_de10lite/soc

----------------------------------------
1. Create base project directory
----------------------------------------
cd ~
mkdir -p h3_quad_de10lite
cd h3_quad_de10lite

----------------------------------------
2. Clone Hazard3
----------------------------------------
cd ~/h3_quad_de10lite
git clone https://github.com/Wren6991/Hazard3.git

----------------------------------------
3. Create SoC project structure
----------------------------------------
cd ~/h3_quad_de10lite
mkdir -p soc/rtl
mkdir -p soc/sw/boot_rom
mkdir -p soc/sw/bootloader
mkdir -p soc/sw/app
mkdir -p soc/sw/arduino_api
mkdir -p soc/quartus
mkdir -p soc/scripts

Final tree (conceptual):
~/h3_quad_de10lite
  ├─ Hazard3/              (upstream core + docs)
  └─ soc/
     ├─ rtl/               (all custom RTL: top, interconnect, peripherals, memories)
     ├─ sw/
     │  ├─ boot_rom/       (reset stub, minimal init, jumps into bootloader region)
     │  ├─ bootloader/     (UART loader that fills instruction SRAM)
     │  ├─ app/            (user firmware main, built against Arduino-like API)
     │  └─ arduino_api/    (pinMode, digitalWrite, Serial, SPI, I2C, PWM wrappers)
     ├─ quartus/           (Quartus project, .qpf/.qsf, constraint files)
     └─ scripts/           (helper scripts, UART uploader)

----------------------------------------
4. Memory map (R3, Harvard)
----------------------------------------

We define:

- Boot ROM:          16 KB at 0x0000_0000
- Instruction SRAM:  64 KB at 0x0001_0000
- Data SRAM:         64 KB at 0x1000_0000
- APB peripherals:   0x4000_0000 and above

These align with R3 (Harvard) and keep things simple.

Detail:

Boot ROM:
  Base:   0x0000_0000
  Size:   16 KB (0x0000_4000)
  Use:    Very small ROM that initializes cores, sets up stack, jumps to bootloader
          (which is also in ROM or in instruction SRAM preload area depending on design).

Instruction SRAM:
  Base:   0x0001_0000
  Size:   64 KB (0x0001_0000–0x0001_FFFF)
  Use:    Firmware text (code) loaded over UART by bootloader.
          All cores fetch instructions from here.

Data SRAM:
  Base:   0x1000_0000
  Size:   64 KB (0x1000_0000–0x1000_FFFF)
  Use:    .data, .bss, heap, stack for all cores.

----------------------------------------
5. Peripheral address map (APB)
----------------------------------------

APB base: 0x4000_0000

We carve simple 4 KB windows per peripheral:

UART:
  Base:   0x4000_0000
  Size:   4 KB (0x4000_0000–0x4000_0FFF)

GPIO:
  Base:   0x4000_1000
  Size:   4 KB (0x4000_1000–0x4000_1FFF)

SPI:
  Base:   0x4000_2000
  Size:   4 KB (0x4000_2000–0x4000_2FFF)

I2C:
  Base:   0x4000_3000
  Size:   4 KB (0x4000_3000–0x4000_3FFF)

PWM:
  Base:   0x4000_4000
  Size:   4 KB (0x4000_4000–0x4000_4FFF)

This will be enforced by the APB address decoder in the SoC RTL.

----------------------------------------
6. Core architecture decisions (fixed)
----------------------------------------

Cores:
- 4× Hazard3 cores, RV32IM, no caches.

Boot:
- Reset vector at 0x0000_0000 (Boot ROM).
- Boot ROM sets up minimal environment, then enters the UART bootloader logic.
- Bootloader receives firmware over UART and writes it into Instruction SRAM starting at 0x0001_0000.
- After upload, bootloader jumps to 0x0001_0000.

Heap/stack:
- Data, BSS, stack, and heap are all in Data SRAM region 0x1000_0000–0x1000_FFFF.

Instruction-side vs data-side:
- All cores share the same instruction SRAM and data SRAM.
- Cores use `mhartid` to customize behavior.

----------------------------------------
7. File naming conventions for later phases
----------------------------------------

In soc/rtl/:

- h3_config_quad.vh        Hazard3 configuration header
- h3_ahb_arbiter.v         AHB-Lite round-robin arbiter (4 masters)
- h3_ahb_instr_sram.v      Instruction SRAM AHB slave (64 KB)
- h3_ahb_data_sram.v       Data SRAM AHB slave (64 KB)
- h3_ahb_boot_rom.v        Boot ROM AHB slave (16 KB, uses boot_rom.hex)
- h3_ahb_to_apb.v          AHB-to-APB bridge
- apb_uart.v               Simple UART (TX+RX)
- apb_gpio.v               32-bit GPIO
- apb_spi.v                SPI master
- apb_i2c.v                I2C bit-bang master
- apb_pwm.v                4-channel PWM
- h3_quad_soc.v            SoC-level integration (cores + bus + memories + peripherals)
- de10lite_quadcore_top.v  Board-level top for DE10-Lite (clock, reset, pins)

In soc/sw/boot_rom/:
- boot_rom.c               Minimal reset stub
- linker.ld                ROM linker script
- Makefile                 Build to boot_rom.hex

In soc/sw/bootloader/:
- bootloader.c             UART-based firmware loader
- linker.ld                Bootloader linker script (if separate)
- Makefile                 Build bootloader binary (may be merged with boot_rom)

In soc/sw/arduino_api/:
- arduino_hal.h            Basic definitions
- gpio_api.c               pinMode, digitalWrite, digitalRead
- uart_api.c               Serial.begin, Serial.print
- pwm_api.c                analogWrite
- spi_api.c                SPI functions
- i2c_api.c                Wire functions
- Makefile                 Build as a static library (libarduino_api.a)

In soc/sw/app/:
- main.c                   Example Arduino-like application
- linker.ld                App linker script (Instruction SRAM + Data SRAM)
- Makefile                 Build app.elf and app.bin

In soc/scripts/:
- uart_upload.py           Python script to upload app.bin over UART
- quartus_setup.tcl        Script to create and configure Quartus project

In soc/quartus/:
- de10lite_quadcore.qpf    Quartus project file
- de10lite_quadcore.qsf    Settings + pin assignment file(s)
- (auto-generated output files, db/, etc.)

----------------------------------------
8. Clone Hazard3 and note core RTL path
----------------------------------------

cd ~/h3_quad_de10lite/Hazard3
ls

Key directories:
- hdl/                     Hazard3 core and support RTL
- doc/                     Docs

Later, you will add to Quartus project:
- hazard3_core.v
- any required support files (e.g., multiply/div, CSR, etc.)

We keep Hazard3 unmodified and configure it with our own config header.

----------------------------------------
9. Confirm toolchain + repo layout
----------------------------------------

Check:
- RISC-V GCC:
  which riscv32-unknown-elf-gcc

- Hazard3:
  ls ~/h3_quad_de10lite/Hazard3

- SoC tree:
  ls ~/h3_quad_de10lite/soc
  ls ~/h3_quad_de10lite/soc/rtl
  ls ~/h3_quad_de10lite/soc/sw
  ls ~/h3_quad_de10lite/soc/quartus
  ls ~/h3_quad_de10lite/soc/scripts

If everything matches, you are ready for RTL integration.

============================================================
END OF PHASE 2
============================================================
============================================================
PHASE 3 — HAZARD3 QUAD-CORE + AHB + MEMORIES (NO BOARD PINS)
============================================================

All files in this phase live under:
  ~/h3_quad_de10lite/soc/rtl

Assumptions from earlier phases:
- Boot ROM:         0x0000_0000, 16 KB
- Instruction SRAM: 0x0001_0000, 64 KB
- Data SRAM:        0x1000_0000, 64 KB
- APB window:       0x4000_0000+

You must adapt Hazard3 core port names if they differ in the actual repo.
The structure (signals, directions, widths) is what matters.

----------------------------------------
1. Hazard3 configuration header
----------------------------------------
File: ~/h3_quad_de10lite/soc/rtl/h3_config_quad.vh

----------------------------------------
h3_config_quad.vh
----------------------------------------
`ifndef H3_CONFIG_QUAD_VH
`define H3_CONFIG_QUAD_VH

`define H3_HAVE_M_EXTENSION          1
`define H3_HAVE_A_EXTENSION          0
`define H3_HAVE_C_EXTENSION          0
`define H3_HAVE_ZICSR                1
`define H3_HAVE_ZIFENCEI             0
`define H3_HAVE_ZICNTR               1
`define H3_HAVE_DEBUG                0

`define H3_NUM_IRQS                  16

`define H3_ICACHE_SIZE_WORDS         0
`define H3_DCACHE_SIZE_WORDS         0

`endif
----------------------------------------

----------------------------------------
2. AHB-Lite arbiter (4 masters → 1 slave)
----------------------------------------
File: ~/h3_quad_de10lite/soc/rtl/h3_ahb_arbiter.v

----------------------------------------
h3_ahb_arbiter.v
----------------------------------------
module h3_ahb_arbiter #(
    parameter NUM_MASTERS = 4
) (
    input  wire                        clk,
    input  wire                        rst_n,

    input  wire [NUM_MASTERS-1:0]      m_hsel,
    input  wire [NUM_MASTERS-1:0]      m_hwrite,
    input  wire [NUM_MASTERS*2-1:0]    m_htrans,
    input  wire [NUM_MASTERS*3-1:0]    m_hsize,
    input  wire [NUM_MASTERS*32-1:0]   m_haddr,
    input  wire [NUM_MASTERS*32-1:0]   m_hwdata,
    output reg  [NUM_MASTERS-1:0]      m_hready,
    output reg  [NUM_MASTERS*32-1:0]   m_hrdata,
    output reg  [NUM_MASTERS-1:0]      m_hresp,

    output reg                         s_hsel,
    output reg  [31:0]                 s_haddr,
    output reg  [1:0]                  s_htrans,
    output reg                         s_hwrite,
    output reg  [2:0]                  s_hsize,
    output reg  [31:0]                 s_hwdata,
    input  wire                        s_hready,
    input  wire [31:0]                 s_hrdata,
    input  wire                        s_hresp
);

    reg [1:0] current;
    integer i;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current <= 2'd0;
        else if (s_hready)
            current <= current + 2'd1;
    end

    always @(*) begin
        s_hsel   = 1'b0;
        s_haddr  = 32'h0;
        s_htrans = 2'b00;
        s_hwrite = 1'b0;
        s_hsize  = 3'b010;
        s_hwdata = 32'h0;

        for (i = 0; i < NUM_MASTERS; i = i + 1) begin
            m_hready[i] = 1'b0;
            m_hresp[i]  = 1'b0;
        end
        m_hrdata = {NUM_MASTERS{32'h0}};

        s_hsel   = m_hsel[current];
        s_hwrite = m_hwrite[current];
        s_htrans = m_htrans[current*2 +: 2];
        s_hsize  = m_hsize[current*3 +: 3];
        s_haddr  = m_haddr[current*32 +: 32];
        s_hwdata = m_hwdata[current*32 +: 32];

        m_hready[current]         = s_hready;
        m_hresp[current]          = s_hresp;
        m_hrdata[current*32 +:32] = s_hrdata;
    end

endmodule
----------------------------------------

----------------------------------------
3. AHB-Lite Boot ROM (16 KB at 0x0000_0000)
----------------------------------------
File: ~/h3_quad_de10lite/soc/rtl/h3_ahb_boot_rom.v

This expects a Verilog hex file named boot_rom.hex in the same directory.

----------------------------------------
h3_ahb_boot_rom.v
----------------------------------------
module h3_ahb_boot_rom #(
    parameter ADDR_BASE = 32'h0000_0000,
    parameter BYTES     = 16384
) (
    input  wire        clk,
    input  wire        rst_n,

    input  wire        hsel,
    input  wire [31:0] haddr,
    input  wire [1:0]  htrans,
    input  wire        hwrite,
    input  wire [2:0]  hsize,
    input  wire [31:0] hwdata,
    output reg         hready,
    output reg  [31:0] hrdata,
    output reg         hresp
);

    localparam WORDS = BYTES / 4;
    reg [31:0] mem [0:WORDS-1];

    initial begin
        $readmemh("boot_rom.hex", mem);
    end

    wire access = hsel && htrans[1];
    wire [31:0] addr_off   = haddr - ADDR_BASE;
    wire [31:0] word_index = addr_off[17:2];

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            hready <= 1'b1;
            hresp  <= 1'b0;
            hrdata <= 32'h0;
        end else begin
            if (access && !hwrite) begin
                if (word_index < WORDS)
                    hrdata <= mem[word_index];
                else
                    hrdata <= 32'hDEAD_BEEF;
            end
            hready <= 1'b1;
            hresp  <= 1'b0;
        end
    end

endmodule
----------------------------------------

----------------------------------------
4. AHB-Lite Instruction SRAM (64 KB at 0x0001_0000)
----------------------------------------
File: ~/h3_quad_de10lite/soc/rtl/h3_ahb_instr_sram.v

----------------------------------------
h3_ahb_instr_sram.v
----------------------------------------
module h3_ahb_instr_sram #(
    parameter ADDR_BASE = 32'h0001_0000,
    parameter BYTES     = 65536
) (
    input  wire        clk,
    input  wire        rst_n,

    input  wire        hsel,
    input  wire [31:0] haddr,
    input  wire [1:0]  htrans,
    input  wire        hwrite,
    input  wire [2:0]  hsize,
    input  wire [31:0] hwdata,
    output reg         hready,
    output reg  [31:0] hrdata,
    output reg         hresp
);

    localparam WORDS = BYTES / 4;
    reg [31:0] mem [0:WORDS-1];

    wire access = hsel && htrans[1];
    wire [31:0] addr_off   = haddr - ADDR_BASE;
    wire [31:0] word_index = addr_off[17:2];

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            hready <= 1'b1;
            hresp  <= 1'b0;
            hrdata <= 32'h0;
        end else begin
            if (access) begin
                if (hwrite) begin
                    if (word_index < WORDS)
                        mem[word_index] <= hwdata;
                end else begin
                    if (word_index < WORDS)
                        hrdata <= mem[word_index];
                    else
                        hrdata <= 32'hBAD0_0000;
                end
            end
            hready <= 1'b1;
            hresp  <= 1'b0;
        end
    end

endmodule
----------------------------------------

----------------------------------------
5. AHB-Lite Data SRAM (64 KB at 0x1000_0000)
----------------------------------------
File: ~/h3_quad_de10lite/soc/rtl/h3_ahb_data_sram.v

----------------------------------------
h3_ahb_data_sram.v
----------------------------------------
module h3_ahb_data_sram #(
    parameter ADDR_BASE = 32'h1000_0000,
    parameter BYTES     = 65536
) (
    input  wire        clk,
    input  wire        rst_n,

    input  wire        hsel,
    input  wire [31:0] haddr,
    input  wire [1:0]  htrans,
    input  wire        hwrite,
    input  wire [2:0]  hsize,
    input  wire [31:0] hwdata,
    output reg         hready,
    output reg  [31:0] hrdata,
    output reg         hresp
);

    localparam WORDS = BYTES / 4;
    reg [31:0] mem [0:WORDS-1];

    wire access = hsel && htrans[1];
    wire [31:0] addr_off   = haddr - ADDR_BASE;
    wire [31:0] word_index = addr_off[17:2];

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            hready <= 1'b1;
            hresp  <= 1'b0;
            hrdata <= 32'h0;
        end else begin
            if (access) begin
                if (hwrite) begin
                    if (word_index < WORDS)
                        mem[word_index] <= hwdata;
                end else begin
                    if (word_index < WORDS)
                        hrdata <= mem[word_index];
                    else
                        hrdata <= 32'hDA7A_0000;
                end
            end
            hready <= 1'b1;
            hresp  <= 1'b0;
        end
    end

endmodule
----------------------------------------

----------------------------------------
6. AHB-to-APB bridge
----------------------------------------
File: ~/h3_quad_de10lite/soc/rtl/h3_ahb_to_apb.v

----------------------------------------
h3_ahb_to_apb.v
----------------------------------------
module h3_ahb_to_apb (
    input  wire        clk,
    input  wire        rst_n,

    input  wire        hsel,
    input  wire [31:0] haddr,
    input  wire [1:0]  htrans,
    input  wire        hwrite,
    input  wire [2:0]  hsize,
    input  wire [31:0] hwdata,
    output reg         hready,
    output reg  [31:0] hrdata,
    output reg         hresp,

    output reg  [31:0] paddr,
    output reg         pwrite,
    output reg  [31:0] pwdata,
    output reg         psel,
    output reg         penable,
    input  wire [31:0] prdata,
    input  wire        pready,
    input  wire        pslverr
);

    localparam IDLE   = 2'd0;
    localparam SETUP  = 2'd1;
    localparam ACCESS = 2'd2;

    reg [1:0] state, next_state;
    reg [31:0] addr_r, wdata_r;
    reg write_r;

    wire ahb_valid = hsel && htrans[1];

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state   <= IDLE;
            addr_r  <= 32'h0;
            wdata_r <= 32'h0;
            write_r <= 1'b0;
        end else begin
            state <= next_state;
            if (ahb_valid && state == IDLE) begin
                addr_r  <= haddr;
                wdata_r <= hwdata;
                write_r <= hwrite;
            end
        end
    end

    always @(*) begin
        next_state = state;
        case (state)
            IDLE:   if (ahb_valid) next_state = SETUP;
            SETUP:  next_state = ACCESS;
            ACCESS: if (pready) next_state = IDLE;
            default: next_state = IDLE;
        endcase
    end

    always @(*) begin
        hready  = 1'b0;
        hresp   = 1'b0;
        hrdata  = 32'h0;

        paddr   = 32'h0;
        pwrite  = 1'b0;
        pwdata  = 32'h0;
        psel    = 1'b0;
        penable = 1'b0;

        case (state)
            IDLE: begin
                hready = !ahb_valid;
            end
            SETUP: begin
                paddr   = addr_r;
                pwrite  = write_r;
                pwdata  = wdata_r;
                psel    = 1'b1;
                penable = 1'b0;
            end
            ACCESS: begin
                paddr   = addr_r;
                pwrite  = write_r;
                pwdata  = wdata_r;
                psel    = 1'b1;
                penable = 1'b1;
                hready  = pready;
                hrdata  = prdata;
                hresp   = pslverr;
            end
        endcase
    end

endmodule
----------------------------------------

----------------------------------------
7. Quad-core Hazard3 SoC (no board pins)
----------------------------------------
File: ~/h3_quad_de10lite/soc/rtl/h3_quad_soc.v

This module instantiates:
- 4× Hazard3 cores as AHB masters
- AHB arbiter
- Boot ROM, Instruction SRAM, Data SRAM
- AHB-to-APB bridge
- APB peripheral bus (UART, GPIO, SPI, I2C, PWM will be added in Phase 4)

For now, we wire APB outward as generic signals; Phase 4 will attach peripherals.

----------------------------------------
h3_quad_soc.v
----------------------------------------
`include "h3_config_quad.vh"

module h3_quad_soc #(
    parameter N_CORES = 4
)(
    input  wire         clk,
    input  wire         rst_n,

    output wire [31:0]  apb_paddr,
    output wire         apb_pwrite,
    output wire [31:0]  apb_pwdata,
    output wire         apb_psel,
    output wire         apb_penable,
    input  wire [31:0]  apb_prdata,
    input  wire         apb_pready,
    input  wire         apb_pslverr,

    output wire [31:0]  core_hartid_dbg
);

    wire [N_CORES-1:0]     core_hsel;
    wire [N_CORES-1:0]     core_hwrite;
    wire [N_CORES*2-1:0]   core_htrans;
    wire [N_CORES*3-1:0]   core_hsize;
    wire [N_CORES*32-1:0]  core_haddr;
    wire [N_CORES*32-1:0]  core_hwdata;
    wire [N_CORES-1:0]     core_hready;
    wire [N_CORES*32-1:0]  core_hrdata;
    wire [N_CORES-1:0]     core_hresp;

    genvar i;
    generate
        for (i = 0; i < N_CORES; i = i + 1) begin : G_CORES
            hazard3_core u_core (
                .clk           (clk),
                .rst_n         (rst_n),

                .haddr         (core_haddr[i*32 +: 32]),
                .hwrite        (core_hwrite[i]),
                .htrans        (core_htrans[i*2 +: 2]),
                .hsize         (core_hsize[i*3 +: 3]),
                .hwdata        (core_hwdata[i*32 +: 32]),
                .hrdata        (core_hrdata[i*32 +: 32]),
                .hready        (core_hready[i]),
                .hresp         (core_hresp[i]),

                .irq           (16'h0000),
                .mhartid       (i[31:0])
            );
            assign core_hsel[i] = 1'b1;
        end
    endgenerate

    assign core_hartid_dbg = {28'h0, 4'hF};

    wire        s_hsel;
    wire [31:0] s_haddr;
    wire [1:0]  s_htrans;
    wire        s_hwrite;
    wire [2:0]  s_hsize;
    wire [31:0] s_hwdata;
    wire        s_hready;
    wire [31:0] s_hrdata;
    wire        s_hresp;

    h3_ahb_arbiter #(
        .NUM_MASTERS(N_CORES)
    ) u_arbiter (
        .clk       (clk),
        .rst_n     (rst_n),
        .m_hsel    (core_hsel),
        .m_hwrite  (core_hwrite),
        .m_htrans  (core_htrans),
        .m_hsize   (core_hsize),
        .m_haddr   (core_haddr),
        .m_hwdata  (core_hwdata),
        .m_hready  (core_hready),
        .m_hrdata  (core_hrdata),
        .m_hresp   (core_hresp),
        .s_hsel    (s_hsel),
        .s_haddr   (s_haddr),
        .s_htrans  (s_htrans),
        .s_hwrite  (s_hwrite),
        .s_hsize   (s_hsize),
        .s_hwdata  (s_hwdata),
        .s_hready  (s_hready),
        .s_hrdata  (s_hrdata),
        .s_hresp   (s_hresp)
    );

    wire hsel_boot   = s_hsel && (s_haddr[31:16] == 16'h0000);
    wire hsel_instr  = s_hsel && (s_haddr[31:16] == 16'h0001);
    wire hsel_data   = s_hsel && (s_haddr[31:16] == 16'h1000);
    wire hsel_apb    = s_hsel && (s_haddr[31:16] == 16'h4000);

    wire [31:0] hrdata_boot, hrdata_instr, hrdata_data, hrdata_apb;
    wire        hready_boot, hready_instr, hready_data, hready_apb;
    wire        hresp_boot,  hresp_instr,  hresp_data,  hresp_apb;

    assign s_hrdata = hsel_boot  ? hrdata_boot  :
                      hsel_instr ? hrdata_instr :
                      hsel_data  ? hrdata_data  :
                      hsel_apb   ? hrdata_apb   : 32'h0;

    assign s_hready = hsel_boot  ? hready_boot  :
                      hsel_instr ? hready_instr :
                      hsel_data  ? hready_data  :
                      hsel_apb   ? hready_apb   : 1'b1;

    assign s_hresp  = hsel_boot  ? hresp_boot   :
                      hsel_instr ? hresp_instr  :
                      hsel_data  ? hresp_data   :
                      hsel_apb   ? hresp_apb    : 1'b0;

    h3_ahb_boot_rom #(
        .ADDR_BASE(32'h0000_0000),
        .BYTES(16384)
    ) u_boot_rom (
        .clk    (clk),
        .rst_n  (rst_n),
        .hsel   (hsel_boot),
        .haddr  (s_haddr),
        .htrans (s_htrans),
        .hwrite (s_hwrite),
        .hsize  (s_hsize),
        .hwdata (s_hwdata),
        .hready (hready_boot),
        .hrdata (hrdata_boot),
        .hresp  (hresp_boot)
    );

    h3_ahb_instr_sram #(
        .ADDR_BASE(32'h0001_0000),
        .BYTES(65536)
    ) u_instr_sram (
        .clk    (clk),
        .rst_n  (rst_n),
        .hsel   (hsel_instr),
        .haddr  (s_haddr),
        .htrans (s_htrans),
        .hwrite (s_hwrite),
        .hsize  (s_hsize),
        .hwdata (s_hwdata),
        .hready (hready_instr),
        .hrdata (hrdata_instr),
        .hresp  (hresp_instr)
    );

    h3_ahb_data_sram #(
        .ADDR_BASE(32'h1000_0000),
        .BYTES(65536)
    ) u_data_sram (
        .clk    (clk),
        .rst_n  (rst_n),
        .hsel   (hsel_data),
        .haddr  (s_haddr),
        .htrans (s_htrans),
        .hwrite (s_hwrite),
        .hsize  (s_hsize),
        .hwdata (s_hwdata),
        .hready (hready_data),
        .hrdata (hrdata_data),
        .hresp  (hresp_data)
    );

    h3_ahb_to_apb u_ahb2apb (
        .clk     (clk),
        .rst_n   (rst_n),
        .hsel    (hsel_apb),
        .haddr   (s_haddr),
        .htrans  (s_htrans),
        .hwrite  (s_hwrite),
        .hsize   (s_hsize),
        .hwdata  (s_hwdata),
        .hready  (hready_apb),
        .hrdata  (hrdata_apb),
        .hresp   (hresp_apb),
        .paddr   (apb_paddr),
        .pwrite  (apb_pwrite),
        .pwdata  (apb_pwdata),
        .psel    (apb_psel),
        .penable (apb_penable),
        .prdata  (apb_prdata),
        .pready  (apb_pready),
        .pslverr (apb_pslverr)
    );

endmodule
----------------------------------------

----------------------------------------
8. Next step
----------------------------------------

At this point you have:
- Quad-core Hazard3 SoC backbone (no peripherals attached yet).
- Boot ROM, Instruction SRAM, Data SRAM mapped at the correct addresses.
- AHB-to-APB bridge with external APB master signals.

Phase 4 will:
- Implement APB UART, GPIO, SPI, I2C, PWM.
- Add an APB decoder beneath h3_quad_soc.
- Introduce a board-level top for DE10-Lite that exposes UART pins, GPIO LEDs, etc.

============================================================
END OF PHASE 3
============================================================
