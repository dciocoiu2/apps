============================================================
PHASE 1 — FRESH START: TOOLCHAIN, REPO, AND ARDUINO-HEADER FOCUS
============================================================

Goal:
- Start from zero with a clean, reproducible environment.
- Lock in: DE10-Lite (MAX 10 10M50DAF484C7G) + Arduino headers as the *primary* SoC I/O interface.
- Install and verify:
  - Linux environment (VM or bare metal)
  - Quartus Lite for MAX 10
  - RISC-V GCC toolchain
  - Git + basic directory structure for the SoC project
- Make an explicit design rule: **all user-facing digital I/O uses the DE10-Lite Arduino headers**, not random GPIO pins or on-board LEDs/switches.

Reference:
- DE10-Lite has a MAX 10 10M50 and dedicated Arduino-compatible headers for GPIO/ADC[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://faculty-web.msoe.edu/johnsontimoj/Common/FILES/de10-lite.pdf?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054&citationId=1&citationId=2 "MSOE Faculty Web").
- We will treat those Arduino headers as the “MCU pinout” for the SoC.

------------------------------------------------------------
0. High-level design constraints (locked in now)
------------------------------------------------------------

These are invariants for ALL later phases:

- Board:
  - Terasic DE10-Lite with MAX 10 10M50DAF484C7G.

- Configuration model:
  - FPGA is configured **only into SRAM** via `.sof` over JTAG.
  - We do **not** program on-board configuration flash.
  - On power-cycle, the SoC disappears; we re-load the bitstream when needed.

- SoC I/O model:
  - All user-facing digital I/O (GPIO, SPI, I2C, UART, PWM, external interrupts) are mapped to the **Arduino-style headers** on the DE10-Lite[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://faculty-web.msoe.edu/johnsontimoj/Common/FILES/de10-lite.pdf?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054&citationId=1 "MSOE Faculty Web").
  - On-board LEDs, switches, keys may be exposed as *extras*, but the canonical/user pinout is Arduino headers.

- Philosophy:
  - Open-source IP only (Hazard3, OpenCores, or small custom RTL).
  - Industrial-capable: IRQ, DMA, advanced PWM/GPIO/I2C/SPI features, but always auditable and deterministic.
  - Arduino-like firmware UX via a C HAL.

These constraints will drive Phase 2 (memory + pin map), Phase 3 (SoC fabric), and especially Phase 8 (pin assignment to Arduino headers).

------------------------------------------------------------
1. Base OS environment
------------------------------------------------------------

Use a modern Linux environment (VM or bare metal). For example:

- Ubuntu 22.04 LTS (recommended)
- At least:
  - 4 GB RAM (8 GB+ nicer)
  - 30+ GB disk

Ensure the following packages are installed:

- Build essentials:
  - sudo apt update
  - sudo apt install -y build-essential git cmake python3 python3-pip

- Utilities:
  - sudo apt install -y curl unzip hexdump

------------------------------------------------------------
2. Quartus Lite for MAX 10 (DE10-Lite)
------------------------------------------------------------

1) Download Quartus Prime Lite Edition that supports MAX 10 devices.
   - Install Quartus Lite + MAX 10 device support following Intel’s installer.

2) After installation, ensure `quartus_sh` is in PATH, e.g.:

   - echo 'export PATH="/opt/intelFPGA_lite/23.1/quartus/bin:$PATH"' >> ~/.bashrc
   - source ~/.bashrc

3) Verify:

   - quartus_sh --version

4) Install USB-Blaster udev rules (if needed):

   - Create `/etc/udev/rules.d/51-usbblaster.rules` with Intel’s recommended rules.
   - Reload udev and replug the DE10-Lite.

5) Plug in DE10-Lite, run:

   - jtagconfig

   You should see the MAX 10 device detected.

------------------------------------------------------------
3. RISC-V toolchain (RV32IM bare-metal)
------------------------------------------------------------

We’ll use a standard GCC-based RISC-V bare-metal toolchain:

1) Install prebuilt toolchain (if available for your distro), or build from source. For example:

   - sudo apt install -y gcc-riscv64-unknown-elf

   If your distro uses a different triplet, adapt accordingly.

2) Verify:

   - riscv64-unknown-elf-gcc --version

3) For this project we’ll target RV32IM / ilp32. We’ll use flags like:

   - -march=rv32im -mabi=ilp32

We’ll standardize on the prefix:

- RISCV_PREFIX = riscv64-unknown-elf

but we’ll compile 32-bit code with `-march`/`-mabi`.

------------------------------------------------------------
4. Project root and repository layout
------------------------------------------------------------

Create a root directory for the entire SoC project:

- mkdir -p ~/h3_quad_de10lite
- cd ~/h3_quad_de10lite
- git init

We’ll use this top-level layout:

~/h3_quad_de10lite/
  soc/
    rtl/            # Verilog RTL for SoC + IP integration
    quartus/        # Quartus project tcl, qsf, sdc
    sw/
      boot_rom/     # Bootloader (UART-based, Instr SRAM loader)
      arduino_api/  # Arduino-like HAL library
      apps/         # User firmware examples (Phase 7+)
    docs/
      pinmap/       # Pin mapping docs, including Arduino headers on DE10-Lite
      memmap/       # Memory and register maps
      build/        # Build + usage documentation

Initialize basic directories:

- mkdir -p soc/rtl soc/quartus soc/sw/boot_rom soc/sw/arduino_api soc/sw/apps docs/pinmap docs/memmap docs/build

Add a minimal README capturing the key constraints:

File: ~/h3_quad_de10lite/README.md

- echo 'H3 Quad-Core SoC on DE10-Lite (Arduino Headers as Primary I/O)' > README.md
- echo '' >> README.md
- echo '- Board: DE10-Lite (MAX 10 10M50DAF484C7G)' >> README.md
- echo '- FPGA config: SRAM-only (.sof via JTAG), no flash' >> README.md
- echo '- CPU: Quad-core Hazard3 RV32IM' >> README.md
- echo '- Buses: AHB backbone, APB + Wishbone peripherals' >> README.md
- echo '- Peripherals: UART16550, SPI, I2C, GPIO, PWM, DMA, IRQ ctrl (OpenCores/custom)' >> README.md
- echo '- All user I/O via DE10-Lite Arduino headers' >> README.md

Commit:

- git add .
- git commit -m "Phase 1: initial repo layout and toolchain assumptions"

------------------------------------------------------------
5. Arduino headers on DE10-Lite (design rule)
------------------------------------------------------------

DE10-Lite provides a set of Arduino headers for GPIO/ADC interfacing[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://faculty-web.msoe.edu/johnsontimoj/Common/FILES/de10-lite.pdf?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054&citationId=1&citationId=2 "MSOE Faculty Web"). We will:

- Treat Arduino header pins as the canonical “MCU pins” of our SoC.
- Map:
  - GPIO, PWM outputs, SPI, I2C, UART pins to specific Arduino I/O pins.
- Document this thoroughly in:
  - docs/pinmap/arduino_de10lite_pinout.md

For now, just create the file and a placeholder heading; detailed mapping will be done in Phase 2/Phase 8 when we pin down exact FPGA pins:

- touch docs/pinmap/arduino_de10lite_pinout.md
- echo '# DE10-Lite Arduino Header Pin Mapping for H3 SoC' > docs/pinmap/arduino_de10lite_pinout.md

(We will fill this with a complete mapping once the SoC’s signal set is fully defined.)

------------------------------------------------------------
6. Sanity checks
------------------------------------------------------------

At the end of Phase 1, verify:

- `quartus_sh --version` works.
- `jtagconfig` detects the MAX 10 on DE10-Lite.
- `riscv64-unknown-elf-gcc --version` works.
- The directory structure under `~/h3_quad_de10lite/` matches what we defined.
- README.md exists and reflects:
  - SRAM-only configuration rule.
  - Arduino headers as primary I/O.

============================================================
END OF PHASE 1
============================================================
