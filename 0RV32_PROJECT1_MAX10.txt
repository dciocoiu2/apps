For opencore urls see 0RV32_PROJECT1_OCURLS.txt
================================================================================
PHASE 1A: QUAD-CORE-READY SINGLE-HART HAZARD3 SoC SKELETON ON DE0-LITE
(core tile + 4-master-capable AHB interconnect + Boot ROM + top-level)
ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX
================================================================================

GOAL OF PHASE 1A
----------------
Build the minimal but structurally “correct” SoC skeleton that:

- Instantiates ONE Hazard3 core *via a tile wrapper* with HART_ID = 0.
- Uses an AHB interconnect that is architected for up to FOUR masters (M0..M3), but
  currently only connects M0.
- Has a Boot ROM at 0x2000_0000, implemented in BRAM, with contents from bootrom.hex.
- Has a top-level for DE0-Lite that wires clock/reset and exposes *no SDRAM, no UART*
  yet (we’ll add those in later sub-phases).
- Is synthesizable, programmable, and “alive” (core runs and loops in ROM).

From here, all later phases add:
- AHB→WB bridge
- SDRAM, UART, I2C, SPI, GPIO, JTAG-UART
- Bootloader, HAL, firmware
- Extra cores (for dual / quad)

Directory layout for Phase 1A:
- ~/fpga/h3_phase1_sc/
    - rtl/
        - cores/
            - hazard3/           (git clone)
        - soc/
            - hazard3_tile.sv
            - ahb_interconnect_4m.sv
            - boot_rom.sv
            - top_soc.sv
    - quartus/
        - h3_phase1_sc.qpf / .qsf / etc.
- ~/hazard3_fw/
    - bootrom/
        - bootrom.c
        - linker.ld
        - Makefile

================================================================================
STEP 1 — BASIC SETUP (DIRECTORIES + HAZARD3 REPO)
================================================================================

1. Create directories:

   mkdir -p ~/fpga/h3_phase1_sc/rtl/cores
   mkdir -p ~/fpga/h3_phase1_sc/rtl/soc
   mkdir -p ~/fpga/h3_phase1_sc/quartus
   mkdir -p ~/hazard3_fw/bootrom

2. Clone official Hazard3:

   cd ~/fpga/h3_phase1_sc/rtl/cores
   git clone https://github.com/Wren6991/hazard3.git

   You will use the AHB-based core from this repo; the exact module name might differ
   (e.g. hazard3_core, hazard3_cpu, etc.). In hazard3_tile.sv below, adapt instance
   names/ports to match the actual RTL after inspecting the repo.

================================================================================
STEP 2 — BOOT ROM C CODE + LINKER + HEX (PHASE 1A MINIMAL)
================================================================================

We’ll use a very simple ROM program that:
- Defines _start at 0x2000_0000.
- Executes an infinite loop (heartbeat).
- No peripherals yet.

----- FILE: ~/hazard3_fw/bootrom/linker.ld ------------------------------------

ENTRY(_start)

MEMORY
{
  ROM (rx) : ORIGIN = 0x20000000, LENGTH = 16K
}

SECTIONS
{
  .text :
  {
    *(.text.entry)
    *(.text*)
    *(.rodata*)
  } > ROM

  .data :
  {
    *(.data*)
  } > ROM

  .bss :
  {
    *(.bss*)
    *(COMMON)
  } > ROM
}

----- FILE: ~/hazard3_fw/bootrom/bootrom.c ------------------------------------

#include <stdint.h>

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    // Minimal ROM stub for Phase 1A:
    // Just loop forever to prove the core is fetching and executing.
    while (1) {
        __asm__ volatile("wfi");
    }
}

----- FILE: ~/hazard3_fw/bootrom/Makefile -------------------------------------

RISCV_PREFIX = riscv64-unknown-elf-
CC      = $(RISCV_PREFIX)gcc
OBJCOPY = $(RISCV_PREFIX)objcopy

CFLAGS  = -march=rv32imc -mabi=ilp32 -Os -nostdlib -ffreestanding -Wall -Wextra
LDFLAGS = -T linker.ld -nostartfiles -nostdlib

all: bootrom.hex

bootrom.elf: bootrom.c linker.ld
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ bootrom.c

bootrom.hex: bootrom.elf
	$(OBJCOPY) -O verilog $< $@

clean:
	rm -f bootrom.elf bootrom.hex

Build the ROM hex:

   cd ~/hazard3_fw/bootrom
   make

This produces bootrom.hex; you’ll point boot_rom.sv to this file.

================================================================================
STEP 3 — BOOT_ROM RTL (AHB-LITE SLAVE @ 0x2000_0000)
================================================================================

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/boot_rom.sv ---------------------------

module boot_rom
(
    input  wire        clk,
    input  wire        rst,

    // AHB-Lite slave interface (read-only)
    input  wire [31:0] HADDR,
    input  wire [2:0]  HSIZE,
    input  wire [1:0]  HBURST,
    input  wire [1:0]  HTRANS,
    input  wire        HWRITE,
    input  wire [31:0] HWDATA,
    output reg  [31:0] HRDATA,
    output wire        HREADY,
    output wire        HRESP
);

    // 16 KB ROM = 4K words of 32 bits
    localparam ADDR_WIDTH = 12;        // 2^12 = 4096 words
    localparam MEM_DEPTH  = 1 << ADDR_WIDTH;

    reg [31:0] rom [0:MEM_DEPTH-1];

    initial begin
        // expects bootrom.hex in simulation/synthesis directory
        $readmemh("bootrom.hex", rom);
    end

    assign HREADY = 1'b1; // zero-wait read
    assign HRESP  = 1'b0; // OKAY

    // Word-aligned address; ignore HSIZE for now (32-bit accesses)
    wire [ADDR_WIDTH-1:0] word_addr = HADDR[ADDR_WIDTH+1:2];

    always @(posedge clk) begin
        if (HTRANS[1] && !HWRITE) begin
            HRDATA <= rom[word_addr];
        end
    end

endmodule

================================================================================
STEP 4 — HAZARD3 TILE WRAPPER (HART TILE, AHB MASTER)
================================================================================

We wrap a Hazard3 core into a “tile” with:

- HART_ID parameter.
- AHB-Lite master port.
- Separate clk, rst.

You MUST adapt the internal instance to match the actual Hazard3 core’s module
name and ports from the cloned repo (hazard3/rtl/core/…).

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/hazard3_tile.sv -----------------------

module hazard3_tile #(
    parameter integer HART_ID = 0
)(
    input  wire        clk,
    input  wire        rst,

    // AHB-Lite master interface
    output wire [31:0] HADDR,
    output wire [2:0]  HSIZE,
    output wire [1:0]  HBURST,
    output wire [1:0]  HTRANS,
    output wire        HWRITE,
    output wire [31:0] HWDATA,
    input  wire [31:0] HRDATA,
    input  wire        HREADY,
    input  wire        HRESP

    // later: interrupts, debug, etc.
);

    // TODO: adapt this to the actual Hazard3 AHB core module and ports.
    // The following is a schematic example:

    hazard3_core_ahb #(
        .HART_ID(HART_ID)
    ) u_core (
        .clk_i     (clk),
        .rst_i     (rst),

        // AHB master out
        .haddr_o   (HADDR),
        .hsize_o   (HSIZE),
        .hburst_o  (HBURST),
        .htrans_o  (HTRANS),
        .hwrite_o  (HWRITE),
        .hwdata_o  (HWDATA),

        // AHB master in
        .hrdata_i  (HRDATA),
        .hready_i  (HREADY),
        .hresp_i   (HRESP)

        // interrupts, etc. → tie off or connect later
    );

endmodule

NOTE:
- After cloning Hazard3, inspect the source to find the AHB-enabled core wrapper.
- Replace hazard3_core_ahb and the signal names above with the actual ones.

================================================================================
STEP 5 — AHB INTERCONNECT, 4-MASTER CAPABLE (PHASE 1 USES ONLY M0)
================================================================================

We design an AHB-Lite interconnect structured to support up to 4 masters (M0..M3)
and N slaves. For Phase 1A:

- Only M0 is actually driven (from hazard3_tile HART0).
- Only S0 is used (Boot ROM).
- S1..Sx are left to future phases (AHB→WB bridge, etc.).

We’ll implement:
- Simple fixed-priority arbitration M0 > M1 > M2 > M3.
- Single shared bus; slaves see a single “arbiter output” view.
- For now, one slave region: ROM at 0x2000_0000; everything else unmapped.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/ahb_interconnect_4m.sv ----------------

module ahb_interconnect_4m
(
    input  wire        clk,
    input  wire        rst,

    //=====================
    // MASTER PORTS (4x)
    //=====================

    // Master 0
    input  wire [31:0] m0_haddr,
    input  wire [2:0]  m0_hsize,
    input  wire [1:0]  m0_hburst,
    input  wire [1:0]  m0_htrans,
    input  wire        m0_hwrite,
    input  wire [31:0] m0_hwdata,
    output reg  [31:0] m0_hrdata,
    output reg         m0_hready,
    output reg         m0_hresp,

    // Master 1 (unused in Phase 1A)
    input  wire [31:0] m1_haddr,
    input  wire [2:0]  m1_hsize,
    input  wire [1:0]  m1_hburst,
    input  wire [1:0]  m1_htrans,
    input  wire        m1_hwrite,
    input  wire [31:0] m1_hwdata,
    output reg  [31:0] m1_hrdata,
    output reg         m1_hready,
    output reg         m1_hresp,

    // Master 2
    input  wire [31:0] m2_haddr,
    input  wire [2:0]  m2_hsize,
    input  wire [1:0]  m2_hburst,
    input  wire [1:0]  m2_htrans,
    input  wire        m2_hwrite,
    input  wire [31:0] m2_hwdata,
    output reg  [31:0] m2_hrdata,
    output reg         m2_hready,
    output reg         m2_hresp,

    // Master 3
    input  wire [31:0] m3_haddr,
    input  wire [2:0]  m3_hsize,
    input  wire [1:0]  m3_hburst,
    input  wire [1:0]  m3_htrans,
    input  wire        m3_hwrite,
    input  wire [31:0] m3_hwdata,
    output reg  [31:0] m3_hrdata,
    output reg         m3_hready,
    output reg         m3_hresp,

    //=====================
    // SLAVE PORTS (here: 2, but only s0 is used)
    //=====================

    // Slave 0 (Boot ROM at 0x2000_0000)
    output reg  [31:0] s0_haddr,
    output reg  [2:0]  s0_hsize,
    output reg  [1:0]  s0_hburst,
    output reg  [1:0]  s0_htrans,
    output reg         s0_hwrite,
    output reg  [31:0] s0_hwdata,
    input  wire [31:0] s0_hrdata,
    input  wire        s0_hready,
    input  wire        s0_hresp,

    // Slave 1 (future: AHB→WB bridge for SDRAM+periph)
    output reg  [31:0] s1_haddr,
    output reg  [2:0]  s1_hsize,
    output reg  [1:0]  s1_hburst,
    output reg  [1:0]  s1_htrans,
    output reg         s1_hwrite,
    output reg  [31:0] s1_hwdata,
    input  wire [31:0] s1_hrdata,
    input  wire        s1_hready,
    input  wire        s1_hresp
);

    // -------------------------------------------------------------------------
    // ARBITRATION
    // -------------------------------------------------------------------------
    // Simple fixed priority: M0 > M1 > M2 > M3
    // "Request" = HTRANS[1] (NONSEQ or SEQ)
    wire m0_req = m0_htrans[1];
    wire m1_req = m1_htrans[1];
    wire m2_req = m2_htrans[1];
    wire m3_req = m3_htrans[1];

    reg [1:0] grant; // 0..3 = which master is granted

    always @(*) begin
        if (m0_req)      grant = 2'd0;
        else if (m1_req) grant = 2'd1;
        else if (m2_req) grant = 2'd2;
        else if (m3_req) grant = 2'd3;
        else             grant = 2'd0; // default to 0 if idle
    end

    // -------------------------------------------------------------------------
    // MUX MASTER → SHARED BUS VIEW
    // -------------------------------------------------------------------------
    reg [31:0] HADDR_bus;
    reg [2:0]  HSIZE_bus;
    reg [1:0]  HBURST_bus;
    reg [1:0]  HTRANS_bus;
    reg        HWRITE_bus;
    reg [31:0] HWDATA_bus;

    always @(*) begin
        case (grant)
            2'd0: begin
                HADDR_bus  = m0_haddr;
                HSIZE_bus  = m0_hsize;
                HBURST_bus = m0_hburst;
                HTRANS_bus = m0_htrans;
                HWRITE_bus = m0_hwrite;
                HWDATA_bus = m0_hwdata;
            end
            2'd1: begin
                HADDR_bus  = m1_haddr;
                HSIZE_bus  = m1_hsize;
                HBURST_bus = m1_hburst;
                HTRANS_bus = m1_htrans;
                HWRITE_bus = m1_hwrite;
                HWDATA_bus = m1_hwdata;
            end
            2'd2: begin
                HADDR_bus  = m2_haddr;
                HSIZE_bus  = m2_hsize;
                HBURST_bus = m2_hburst;
                HTRANS_bus = m2_htrans;
                HWRITE_bus = m2_hwrite;
                HWDATA_bus = m2_hwdata;
            end
            2'd3: begin
                HADDR_bus  = m3_haddr;
                HSIZE_bus  = m3_hsize;
                HBURST_bus = m3_hburst;
                HTRANS_bus = m3_htrans;
                HWRITE_bus = m3_hwrite;
                HWDATA_bus = m3_hwdata;
            end
            default: begin
                HADDR_bus  = 32'h0000_0000;
                HSIZE_bus  = 3'b010;
                HBURST_bus = 2'b00;
                HTRANS_bus = 2'b00;
                HWRITE_bus = 1'b0;
                HWDATA_bus = 32'h0000_0000;
            end
        endcase
    end

    // -------------------------------------------------------------------------
    // ADDRESS DECODE (ROM vs future-periph)
    // -------------------------------------------------------------------------
    // ROM at 0x2000_0000 (e.g. match upper nibble 0x2)
    wire sel_s0 = (HADDR_bus[31:28] == 4'h2);
    wire sel_s1 = !sel_s0; // everything else to slave 1 for now

    always @(*) begin
        // defaults
        s0_haddr  = 32'h0;
        s0_hsize  = 3'b010;
        s0_hburst = 2'b00;
        s0_htrans = 2'b00;
        s0_hwrite = 1'b0;
        s0_hwdata = 32'h0;

        s1_haddr  = 32'h0;
        s1_hsize  = 3'b010;
        s1_hburst = 2'b00;
        s1_htrans = 2'b00;
        s1_hwrite = 1'b0;
        s1_hwdata = 32'h0;

        if (sel_s0) begin
            s0_haddr  = HADDR_bus;
            s0_hsize  = HSIZE_bus;
            s0_hburst = HBURST_bus;
            s0_htrans = HTRANS_bus;
            s0_hwrite = HWRITE_bus;
            s0_hwdata = HWDATA_bus;
        end else begin
            s1_haddr  = HADDR_bus;
            s1_hsize  = HSIZE_bus;
            s1_hburst = HBURST_bus;
            s1_htrans = HTRANS_bus;
            s1_hwrite = HWRITE_bus;
            s1_hwdata = HWDATA_bus;
        end
    end

    // -------------------------------------------------------------------------
    // RETURN DATA/READY/RESP TO THE GRANTED MASTER
    // -------------------------------------------------------------------------
    wire [31:0] HRDATA_bus = sel_s0 ? s0_hrdata : s1_hrdata;
    wire        HREADY_bus = sel_s0 ? s0_hready : s1_hready;
    wire        HRESP_bus  = sel_s0 ? s0_hresp  : s1_hresp;

    always @(*) begin
        // default all masters to idle OKAY
        m0_hrdata = 32'h0;
        m0_hready = 1'b1;
        m0_hresp  = 1'b0;

        m1_hrdata = 32'h0;
        m1_hready = 1'b1;
        m1_hresp  = 1'b0;

        m2_hrdata = 32'h0;
        m2_hready = 1'b1;
        m2_hresp  = 1'b0;

        m3_hrdata = 32'h0;
        m3_hready = 1'b1;
        m3_hresp  = 1'b0;

        case (grant)
            2'd0: begin
                m0_hrdata = HRDATA_bus;
                m0_hready = HREADY_bus;
                m0_hresp  = HRESP_bus;
            end
            2'd1: begin
                m1_hrdata = HRDATA_bus;
                m1_hready = HREADY_bus;
                m1_hresp  = HRESP_bus;
            end
            2'd2: begin
                m2_hrdata = HRDATA_bus;
                m2_hready = HREADY_bus;
                m2_hresp  = HRESP_bus;
            end
            2'd3: begin
                m3_hrdata = HRDATA_bus;
                m3_hready = HREADY_bus;
                m3_hresp  = HRESP_bus;
            end
        endcase
    end

endmodule

NOTES:
- In Phase 1A, we will:
  - Connect only M0 to hazard3_tile HART0.
  - Leave M1..M3 unconnected or tied off.
  - Connect S0 to boot_rom.
  - Tie S1 to a dummy “error slave” that returns error or zero (simple stub).

================================================================================
STEP 6 — TOP-LEVEL FOR DE0-LITE (MINIMAL, NO PERIPHERALS YET)
================================================================================

We now define a minimal top-level that:

- Instantiates one hazard3_tile with HART_ID=0.
- Instantiates ahb_interconnect_4m.
- Instantiates boot_rom.
- Exposes only clock and reset pins for now (we’ll add IO in later phases).

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv ----------------------------

module top_soc
(
    input  wire clk_50,   // 50 MHz clock from DE0-Lite
    input  wire reset_n   // active-low reset (pushbutton)
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    //======================
    // AHB master signals from HART0 tile (M0)
    //======================
    wire [31:0] m0_haddr;
    wire [2:0]  m0_hsize;
    wire [1:0]  m0_hburst;
    wire [1:0]  m0_htrans;
    wire        m0_hwrite;
    wire [31:0] m0_hwdata;
    wire [31:0] m0_hrdata;
    wire        m0_hready;
    wire        m0_hresp;

    // M1..M3 unconnected in Phase 1A
    wire [31:0] m1_haddr = 32'h0;
    wire [2:0]  m1_hsize = 3'b010;
    wire [1:0]  m1_hburst = 2'b00;
    wire [1:0]  m1_htrans = 2'b00;
    wire        m1_hwrite = 1'b0;
    wire [31:0] m1_hwdata = 32'h0;
    wire [31:0] m1_hrdata;
    wire        m1_hready;
    wire        m1_hresp;

    wire [31:0] m2_haddr = 32'h0;
    wire [2:0]  m2_hsize = 3'b010;
    wire [1:0]  m2_hburst = 2'b00;
    wire [1:0]  m2_htrans = 2'b00;
    wire        m2_hwrite = 1'b0;
    wire [31:0] m2_hwdata = 32'h0;
    wire [31:0] m2_hrdata;
    wire        m2_hready;
    wire        m2_hresp;

    wire [31:0] m3_haddr = 32'h0;
    wire [2:0]  m3_hsize = 3'b010;
    wire [1:0]  m3_hburst = 2'b00;
    wire [1:0]  m3_htrans = 2'b00;
    wire        m3_hwrite = 1'b0;
    wire [31:0] m3_hwdata = 32'h0;
    wire [31:0] m3_hrdata;
    wire        m3_hready;
    wire        m3_hresp;

    //======================
    // Slave 0 = boot ROM
    // Slave 1 = dummy error slave (for Phase 1A)
    //======================
    wire [31:0] s0_haddr, s1_haddr;
    wire [2:0]  s0_hsize, s1_hsize;
    wire [1:0]  s0_hburst, s1_hburst;
    wire [1:0]  s0_htrans, s1_htrans;
    wire        s0_hwrite, s1_hwrite;
    wire [31:0] s0_hwdata, s1_hwdata;
    wire [31:0] s0_hrdata, s1_hrdata;
    wire        s0_hready, s1_hready;
    wire        s0_hresp,  s1_hresp;

    // HART0 tile
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m0_haddr),
        .HSIZE  (m0_hsize),
        .HBURST (m0_hburst),
        .HTRANS (m0_htrans),
        .HWRITE (m0_hwrite),
        .HWDATA (m0_hwdata),
        .HRDATA (m0_hrdata),
        .HREADY (m0_hready),
        .HRESP  (m0_hresp)
    );

    // AHB interconnect, 4 masters, 2 slaves
    ahb_interconnect_4m u_ahb_ic (
        .clk        (clk),
        .rst        (rst),

        // M0
        .m0_haddr   (m0_haddr),
        .m0_hsize   (m0_hsize),
        .m0_hburst  (m0_hburst),
        .m0_htrans  (m0_htrans),
        .m0_hwrite  (m0_hwrite),
        .m0_hwdata  (m0_hwdata),
        .m0_hrdata  (m0_hrdata),
        .m0_hready  (m0_hready),
        .m0_hresp   (m0_hresp),

        // M1..M3 (unused)
        .m1_haddr   (m1_haddr),
        .m1_hsize   (m1_hsize),
        .m1_hburst  (m1_hburst),
        .m1_htrans  (m1_htrans),
        .m1_hwrite  (m1_hwrite),
        .m1_hwdata  (m1_hwdata),
        .m1_hrdata  (m1_hrdata),
        .m1_hready  (m1_hready),
        .m1_hresp   (m1_hresp),

        .m2_haddr   (m2_haddr),
        .m2_hsize   (m2_hsize),
        .m2_hburst  (m2_hburst),
        .m2_htrans  (m2_htrans),
        .m2_hwrite  (m2_hwrite),
        .m2_hwdata  (m2_hwdata),
        .m2_hrdata  (m2_hrdata),
        .m2_hready  (m2_hready),
        .m2_hresp   (m2_hresp),

        .m3_haddr   (m3_haddr),
        .m3_hsize   (m3_hsize),
        .m3_hburst  (m3_hburst),
        .m3_htrans  (m3_htrans),
        .m3_hwrite  (m3_hwrite),
        .m3_hwdata  (m3_hwdata),
        .m3_hrdata  (m3_hrdata),
        .m3_hready  (m3_hready),
        .m3_hresp   (m3_hresp),

        // Slave 0 = ROM
        .s0_haddr   (s0_haddr),
        .s0_hsize   (s0_hsize),
        .s0_hburst  (s0_hburst),
        .s0_htrans  (s0_htrans),
        .s0_hwrite  (s0_hwrite),
        .s0_hwdata  (s0_hwdata),
        .s0_hrdata  (s0_hrdata),
        .s0_hready  (s0_hready),
        .s0_hresp   (s0_hresp),

        // Slave 1 = dummy
        .s1_haddr   (s1_haddr),
        .s1_hsize   (s1_hsize),
        .s1_hburst  (s1_hburst),
        .s1_htrans  (s1_htrans),
        .s1_hwrite  (s1_hwrite),
        .s1_hwdata  (s1_hwdata),
        .s1_hrdata  (s1_hrdata),
        .s1_hready  (s1_hready),
        .s1_hresp   (s1_hresp)
    );

    // Boot ROM at 0x2000_0000
    boot_rom u_boot_rom (
        .clk    (clk),
        .rst    (rst),
        .HADDR  (s0_haddr),
        .HSIZE  (s0_hsize),
        .HBURST (s0_hburst),
        .HTRANS (s0_htrans),
        .HWRITE (s0_hwrite),
        .HWDATA (s0_hwdata),
        .HRDATA (s0_hrdata),
        .HREADY (s0_hready),
        .HRESP  (s0_hresp)
    );

    // Dummy slave 1: always ready, returns 0, OKAY
    assign s1_hrdata = 32'hDEAD_DEAD;
    assign s1_hready = 1'b1;
    assign s1_hresp  = 1'b0;

endmodule

================================================================================
STEP 7 — QUARTUS PROJECT (PHASE 1A) AND BRING-UP
================================================================================

1. Create Quartus project:

   cd ~/fpga/h3_phase1_sc/quartus
   quartus &

   - New Project Wizard:
     - Directory: ~/fpga/h3_phase1_sc/quartus
     - Name: h3_phase1_sc
     - Top-level entity: top_soc
   - Device: MAX 10 → 10M50DAF484C7G (DE0-Lite)

2. Add RTL files:
   - Project → Add/Remove Files in Project:
     - ../rtl/soc/top_soc.sv
     - ../rtl/soc/hazard3_tile.sv
     - ../rtl/soc/ahb_interconnect_4m.sv
     - ../rtl/soc/boot_rom.sv
     - All relevant Hazard3 core files from ../rtl/cores/hazard3/rtl/...
   - Make sure SystemVerilog (.sv) is enabled where needed.

3. Boot ROM hex:
   - Copy bootrom.hex into the Quartus project directory (or adjust relative
     path in boot_rom.sv to point to ../../hazard3_fw/bootrom/bootrom.hex).
   - Quartus must see bootrom.hex at compile time.

4. Pin assignments (minimal for Phase 1A):
   - clk_50: assign to the DE0-Lite 50 MHz pin (per board manual).
   - reset_n: assign to a pushbutton (e.g. KEY0).
   - No other pins needed yet.

5. Compile:
   - Processing → Start Compilation.
   - If there are missing module names/ports:
     - Fix hazard3_tile.sv to match the actual Hazard3 core wrapper.
     - Ensure all Hazard3 RTL files are included.

6. Program DE0-Lite:
   - Open Quartus Programmer (quartus_pgmw).
   - Hardware Setup → select USB-Blaster.
   - Add h3_phase1_sc.sof from output_files/.
   - Check “Program/Configure”.
   - Click Start.

7. After programming:
   - The Hazard3 core (HART0) begins executing at 0x2000_0000 (Boot ROM).
   - It runs _start(), which loops and executes WFI.
   - From the outside, nothing visible happens yet — but the SoC is structurally
     correct, and the CPU is alive and fetching from ROM.

================================================================================
WHAT PHASE 1A HAS ACHIEVED (QUAD-CORE FUTURE IN MIND)
================================================================================

- You now have a **single-hart Hazard3 SoC skeleton** with:
  - A HART tile abstraction (`hazard3_tile`) with HART_ID.
  - A **4-master-capable** AHB interconnect (`ahb_interconnect_4m`) that will
    easily scale to dual/quad core by adding more tiles and connecting M1..M3.
  - A Boot ROM subsystem at 0x2000_0000 using bootrom.hex.
  - A minimal top-level for DE0-Lite that compiles and runs.

- This is a **clean base** for:
  - Phase 1B: AHB→Wishbone bridge + Wishbone interconnect.
  - Phase 1C+: SDRAM, UART, I2C, SPI, GPIO, JTAG-UART, bootloader, HAL.
  - Phase 2: dual-core bring-up.
  - Phase 3: quad-core with core control and hart coordination.
№############END PHASE1_A################

================================================================================
PHASE 1B: AHB→WISHBONE BRIDGE + WISHBONE FABRIC SHELL (QUAD-CORE-READY)
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH PROGRAMMING)
================================================================================

GOAL OF PHASE 1B
----------------
Extend the Phase 1A SoC skeleton to introduce the full bus hierarchy:

- KEEP:
  - Hazard3 tile (HART0) as AHB master M0.
  - 4-master-capable AHB interconnect (M0..M3, S0=Boot ROM).
  - Boot ROM @ 0x2000_0000, with bootrom.hex.
  - top_soc.sv structure and DE0-Lite top-level.

- ADD in Phase 1B:
  - AHB→Wishbone bridge (burst-aware, but we can treat it as single-beat for now).
  - Wishbone fabric with address decode for:
    - SDRAM @ 0x8000_0000 (future Phase 1C).
    - UART0 @ 0x1000_0000 (future 1D).
    - I2C0 @ 0x1000_0100 (future 1E).
    - SPI0 @ 0x1000_0200 (future 1F).
    - GPIO @ 0x1000_0300 (future 1G).
    - JTAG-UART @ 0x1000_0500 (future 1H).
  - Stub Wishbone slaves for now (return fixed data, OKAY).

NOTES:
- STILL: We only ever program .sof via JTAG → SRAM. No .pof, no flash. On power-cycle
  the DE0-Lite returns to its factory image.
- This phase is about bus structure, NOT functionality. All peripherals are stubs.

Directory context:

- ~/fpga/h3_phase1_sc/rtl/soc/
    - hazard3_tile.sv              (from 1A)
    - ahb_interconnect_4m.sv       (from 1A)
    - boot_rom.sv                  (from 1A)
    - top_soc.sv                   (UPDATED in 1B)
    - ahb_to_wb_bridge.sv          (NEW)
    - wb_interconnect.sv           (NEW)

================================================================================
STEP 1 — AHB→WISHBONE BRIDGE (SINGLE-BEAT, BURST-CAPABLE STRUCTURE)
================================================================================

We design a simple AHB-Lite slave → Wishbone master bridge:

- AHB slave interface:
  - Responds to reads/writes in the 0x1000_0000–0x8FFF_FFFF region.
- Wishbone master interface:
  - Issues a single Wishbone cycle per AHB transfer (Phase 1B).
- Later we can extend it to actually use HBURST for bursts, but the interface will
  already be correct.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/ahb_to_wb_bridge.sv -------------------

module ahb_to_wb_bridge
(
    input  wire        clk,
    input  wire        rst,

    // AHB-Lite slave interface
    input  wire [31:0] HADDR,
    input  wire [2:0]  HSIZE,
    input  wire [1:0]  HBURST,
    input  wire [1:0]  HTRANS,
    input  wire        HWRITE,
    input  wire [31:0] HWDATA,
    output reg  [31:0] HRDATA,
    output reg         HREADY,
    output reg         HRESP,

    // Wishbone master interface
    output reg  [31:0] wb_adr_o,
    output reg  [31:0] wb_dat_o,
    input  wire [31:0] wb_dat_i,
    output reg         wb_we_o,
    output reg  [3:0]  wb_sel_o,
    output reg         wb_cyc_o,
    output reg         wb_stb_o,
    input  wire        wb_ack_i,
    input  wire        wb_err_i
);

    // Simple FSM: IDLE → WB_CYCLE → DONE
    localparam ST_IDLE  = 2'd0;
    localparam ST_WB    = 2'd1;
    localparam ST_RESP  = 2'd2;

    reg [1:0] state, next_state;

    // Latched AHB request info
    reg [31:0] lat_addr;
    reg [31:0] lat_wdata;
    reg        lat_write;
    reg [3:0]  lat_sel;

    wire ahb_valid = HTRANS[1]; // NONSEQ or SEQ

    // Derive byte enables from HSIZE and address (simplified: assume 32-bit)
    // For now we just treat all accesses as 32-bit word.
    wire [3:0] ahb_sel = 4'b1111;

    // FSM
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= ST_IDLE;
        end else begin
            state <= next_state;
        end
    end

    always @(*) begin
        next_state = state;
        case (state)
            ST_IDLE: begin
                if (ahb_valid) begin
                    next_state = ST_WB;
                end
            end
            ST_WB: begin
                if (wb_ack_i || wb_err_i) begin
                    next_state = ST_RESP;
                end
            end
            ST_RESP: begin
                next_state = ST_IDLE;
            end
        endcase
    end

    // Latch AHB request on first valid transfer
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            lat_addr  <= 32'h0;
            lat_wdata <= 32'h0;
            lat_write <= 1'b0;
            lat_sel   <= 4'b0000;
        end else begin
            if (state == ST_IDLE && ahb_valid) begin
                lat_addr  <= HADDR;
                lat_wdata <= HWDATA;
                lat_write <= HWRITE;
                lat_sel   <= ahb_sel;
            end
        end
    end

    // Drive Wishbone signals
    always @(*) begin
        wb_adr_o = 32'h0;
        wb_dat_o = 32'h0;
        wb_we_o  = 1'b0;
        wb_sel_o = 4'b0000;
        wb_cyc_o = 1'b0;
        wb_stb_o = 1'b0;

        case (state)
            ST_WB: begin
                wb_adr_o = lat_addr;
                wb_dat_o = lat_wdata;
                wb_we_o  = lat_write;
                wb_sel_o = lat_sel;
                wb_cyc_o = 1'b1;
                wb_stb_o = 1'b1;
            end
            default: begin
                // IDLE / RESP → no WB cycle
            end
        endcase
    end

    // AHB response
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            HRDATA <= 32'h0;
            HREADY <= 1'b1;
            HRESP  <= 1'b0;
        end else begin
            case (state)
                ST_IDLE: begin
                    HREADY <= 1'b1; // ready for new transfer
                    HRESP  <= 1'b0;
                end
                ST_WB: begin
                    HREADY <= 1'b0; // wait for WB
                    HRESP  <= 1'b0;
                end
                ST_RESP: begin
                    HREADY <= 1'b1;
                    HRESP  <= wb_err_i ? 1'b1 : 1'b0;
                    HRDATA <= wb_dat_i;
                end
            endcase
        end
    end

endmodule

================================================================================
STEP 2 — WISHBONE INTERCONNECT SHELL (6 SLAVES, ALL STUBS FOR NOW)
================================================================================

We now define a single-master, multi-slave Wishbone interconnect:

- Single master: output of ahb_to_wb_bridge.
- Slaves:
  - s0: SDRAM     @ 0x8000_0000–0x8FFF_FFFF (Phase 1C).
  - s1: UART0     @ 0x1000_0000–0x1000_00FF.
  - s2: I2C0      @ 0x1000_0100–0x1000_01FF.
  - s3: SPI0      @ 0x1000_0200–0x1000_02FF.
  - s4: GPIO      @ 0x1000_0300–0x1000_03FF.
  - s5: JTAG-UART @ 0x1000_0500–0x1000_05FF.

In Phase 1B:
- Each slave is a stub: always ACK, returns fixed data, no error.
- In later phases we replace those stubs with real IP instances.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/wb_interconnect.sv --------------------

module wb_interconnect
(
    input  wire        clk,
    input  wire        rst,

    // Master interface
    input  wire [31:0] m_adr_i,
    input  wire [31:0] m_dat_i,
    output reg  [31:0] m_dat_o,
    input  wire        m_we_i,
    input  wire [3:0]  m_sel_i,
    input  wire        m_cyc_i,
    input  wire        m_stb_i,
    output reg         m_ack_o,
    output reg         m_err_o,

    // Slave 0: SDRAM
    output reg  [31:0] s0_adr_o,
    output reg  [31:0] s0_dat_o,
    input  wire [31:0] s0_dat_i,
    output reg         s0_we_o,
    output reg  [3:0]  s0_sel_o,
    output reg         s0_cyc_o,
    output reg         s0_stb_o,
    input  wire        s0_ack_i,
    input  wire        s0_err_i,

    // Slave 1: UART0
    output reg  [31:0] s1_adr_o,
    output reg  [31:0] s1_dat_o,
    input  wire [31:0] s1_dat_i,
    output reg         s1_we_o,
    output reg  [3:0]  s1_sel_o,
    output reg         s1_cyc_o,
    output reg         s1_stb_o,
    input  wire        s1_ack_i,
    input  wire        s1_err_i,

    // Slave 2: I2C0
    output reg  [31:0] s2_adr_o,
    output reg  [31:0] s2_dat_o,
    input  wire [31:0] s2_dat_i,
    output reg         s2_we_o,
    output reg  [3:0]  s2_sel_o,
    output reg         s2_cyc_o,
    output reg         s2_stb_o,
    input  wire        s2_ack_i,
    input  wire        s2_err_i,

    // Slave 3: SPI0
    output reg  [31:0] s3_adr_o,
    output reg  [31:0] s3_dat_o,
    input  wire [31:0] s3_dat_i,
    output reg         s3_we_o,
    output reg  [3:0]  s3_sel_o,
    output reg         s3_cyc_o,
    output reg         s3_stb_o,
    input  wire        s3_ack_i,
    input  wire        s3_err_i,

    // Slave 4: GPIO
    output reg  [31:0] s4_adr_o,
    output reg  [31:0] s4_dat_o,
    input  wire [31:0] s4_dat_i,
    output reg         s4_we_o,
    output reg  [3:0]  s4_sel_o,
    output reg         s4_cyc_o,
    output reg         s4_stb_o,
    input  wire        s4_ack_i,
    input  wire        s4_err_i,

    // Slave 5: JTAG-UART
    output reg  [31:0] s5_adr_o,
    output reg  [31:0] s5_dat_o,
    input  wire [31:0] s5_dat_i,
    output reg         s5_we_o,
    output reg  [3:0]  s5_sel_o,
    output reg         s5_cyc_o,
    output reg         s5_stb_o,
    input  wire        s5_ack_i,
    input  wire        s5_err_i
);

    // Address decode
    // s0: SDRAM region >= 0x8000_0000
    wire sel_s0 = (m_adr_i[31:28] == 4'h8);

    // s1..s5: peripheral regions
    wire sel_s1 = (m_adr_i[31:8] == 24'h100000); // 0x1000_0000 - 0x1000_00FF
    wire sel_s2 = (m_adr_i[31:8] == 24'h100001); // 0x1000_0100 - 0x1000_01FF
    wire sel_s3 = (m_adr_i[31:8] == 24'h100002); // 0x1000_0200 - 0x1000_02FF
    wire sel_s4 = (m_adr_i[31:8] == 24'h100003); // 0x1000_0300 - 0x1000_03FF
    wire sel_s5 = (m_adr_i[31:8] == 24'h100005); // 0x1000_0500 - 0x1000_05FF

    // default: no slave → error
    wire no_slave = !(sel_s0 | sel_s1 | sel_s2 | sel_s3 | sel_s4 | sel_s5);

    // Drive slaves based on select
    always @(*) begin
        // default all slaves inactive
        s0_adr_o = 32'h0; s0_dat_o = 32'h0; s0_we_o = 1'b0; s0_sel_o = 4'b0000; s0_cyc_o = 1'b0; s0_stb_o = 1'b0;
        s1_adr_o = 32'h0; s1_dat_o = 32'h0; s1_we_o = 1'b0; s1_sel_o = 4'b0000; s1_cyc_o = 1'b0; s1_stb_o = 1'b0;
        s2_adr_o = 32'h0; s2_dat_o = 32'h0; s2_we_o = 1'b0; s2_sel_o = 4'b0000; s2_cyc_o = 1'b0; s2_stb_o = 1'b0;
        s3_adr_o = 32'h0; s3_dat_o = 32'h0; s3_we_o = 1'b0; s3_sel_o = 4'b0000; s3_cyc_o = 1'b0; s3_stb_o = 1'b0;
        s4_adr_o = 32'h0; s4_dat_o = 32'h0; s4_we_o = 1'b0; s4_sel_o = 4'b0000; s4_cyc_o = 1'b0; s4_stb_o = 1'b0;
        s5_adr_o = 32'h0; s5_dat_o = 32'h0; s5_we_o = 1'b0; s5_sel_o = 4'b0000; s5_cyc_o = 1'b0; s5_stb_o = 1'b0;

        if (m_cyc_i && m_stb_i) begin
            if (sel_s0) begin
                s0_adr_o = m_adr_i;
                s0_dat_o = m_dat_i;
                s0_we_o  = m_we_i;
                s0_sel_o = m_sel_i;
                s0_cyc_o = 1'b1;
                s0_stb_o = 1'b1;
            end else if (sel_s1) begin
                s1_adr_o = m_adr_i;
                s1_dat_o = m_dat_i;
                s1_we_o  = m_we_i;
                s1_sel_o = m_sel_i;
                s1_cyc_o = 1'b1;
                s1_stb_o = 1'b1;
            end else if (sel_s2) begin
                s2_adr_o = m_adr_i;
                s2_dat_o = m_dat_i;
                s2_we_o  = m_we_i;
                s2_sel_o = m_sel_i;
                s2_cyc_o = 1'b1;
                s2_stb_o = 1'b1;
            end else if (sel_s3) begin
                s3_adr_o = m_adr_i;
                s3_dat_o = m_dat_i;
                s3_we_o  = m_we_i;
                s3_sel_o = m_sel_i;
                s3_cyc_o = 1'b1;
                s3_stb_o = 1'b1;
            end else if (sel_s4) begin
                s4_adr_o = m_adr_i;
                s4_dat_o = m_dat_i;
                s4_we_o  = m_we_i;
                s4_sel_o = m_sel_i;
                s4_cyc_o = 1'b1;
                s4_stb_o = 1'b1;
            end else if (sel_s5) begin
                s5_adr_o = m_adr_i;
                s5_dat_o = m_dat_i;
                s5_we_o  = m_we_i;
                s5_sel_o = m_sel_i;
                s5_cyc_o = 1'b1;
                s5_stb_o = 1'b1;
            end
        end
    end

    // Return data/ack/err to master
    always @(*) begin
        m_dat_o = 32'h0;
        m_ack_o = 1'b0;
        m_err_o = 1'b0;

        if (m_cyc_i && m_stb_i) begin
            if (sel_s0) begin
                m_dat_o = s0_dat_i;
                m_ack_o = s0_ack_i;
                m_err_o = s0_err_i;
            end else if (sel_s1) begin
                m_dat_o = s1_dat_i;
                m_ack_o = s1_ack_i;
                m_err_o = s1_err_i;
            end else if (sel_s2) begin
                m_dat_o = s2_dat_i;
                m_ack_o = s2_ack_i;
                m_err_o = s2_err_i;
            end else if (sel_s3) begin
                m_dat_o = s3_dat_i;
                m_ack_o = s3_ack_i;
                m_err_o = s3_err_i;
            end else if (sel_s4) begin
                m_dat_o = s4_dat_i;
                m_ack_o = s4_ack_i;
                m_err_o = s4_err_i;
            end else if (sel_s5) begin
                m_dat_o = s5_dat_i;
                m_ack_o = s5_ack_i;
                m_err_o = s5_err_i;
            end else if (no_slave) begin
                m_dat_o = 32'hBAD0_0000;
                m_ack_o = 1'b1;
                m_err_o = 1'b1;
            end
        end
    end

endmodule

================================================================================
STEP 3 — TOP-LEVEL UPDATE: CONNECT AHB→WB BRIDGE + WB INTERCONNECT + STUB SLAVES
================================================================================

Now we update top_soc.sv to:

- Hook up AHB slave 1 (previous dummy) to ahb_to_wb_bridge.
- Hook the bridge’s Wishbone master to wb_interconnect.
- Instantiate stub Wishbone slaves for SDRAM, UART, I2C, SPI, GPIO, JTAG-UART.

NOTE:
- You REPLACE the old dummy S1 logic in top_soc.sv with the new bridge+WB fabric.
- The rest (HART0 tile, AHB interconnect, Boot ROM) remains as in Phase 1A.

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv -------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    //======================
    // AHB master signals from HART0 tile (M0)
    //======================
    wire [31:0] m0_haddr;
    wire [2:0]  m0_hsize;
    wire [1:0]  m0_hburst;
    wire [1:0]  m0_htrans;
    wire        m0_hwrite;
    wire [31:0] m0_hwdata;
    wire [31:0] m0_hrdata;
    wire        m0_hready;
    wire        m0_hresp;

    // M1..M3 unused
    wire [31:0] m1_haddr = 32'h0;
    wire [2:0]  m1_hsize = 3'b010;
    wire [1:0]  m1_hburst = 2'b00;
    wire [1:0]  m1_htrans = 2'b00;
    wire        m1_hwrite = 1'b0;
    wire [31:0] m1_hwdata = 32'h0;
    wire [31:0] m1_hrdata;
    wire        m1_hready;
    wire        m1_hresp;

    wire [31:0] m2_haddr = 32'h0;
    wire [2:0]  m2_hsize = 3'b010;
    wire [1:0]  m2_hburst = 2'b00;
    wire [1:0]  m2_htrans = 2'b00;
    wire        m2_hwrite = 1'b0;
    wire [31:0] m2_hwdata = 32'h0;
    wire [31:0] m2_hrdata;
    wire        m2_hready;
    wire        m2_hresp;

    wire [31:0] m3_haddr = 32'h0;
    wire [2:0]  m3_hsize = 3'b010;
    wire [1:0]  m3_hburst = 2'b00;
    wire [1:0]  m3_htrans = 2'b00;
    wire        m3_hwrite = 1'b0;
    wire [31:0] m3_hwdata = 32'h0;
    wire [31:0] m3_hrdata;
    wire        m3_hready;
    wire        m3_hresp;

    // Slave 0: Boot ROM
    wire [31:0] s0_haddr, s1_haddr;
    wire [2:0]  s0_hsize, s1_hsize;
    wire [1:0]  s0_hburst, s1_hburst;
    wire [1:0]  s0_htrans, s1_htrans;
    wire        s0_hwrite, s1_hwrite;
    wire [31:0] s0_hwdata, s1_hwdata;
    wire [31:0] s0_hrdata, s1_hrdata;
    wire        s0_hready, s1_hready;
    wire        s0_hresp,  s1_hresp;

    // HART0 tile
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m0_haddr),
        .HSIZE  (m0_hsize),
        .HBURST (m0_hburst),
        .HTRANS (m0_htrans),
        .HWRITE (m0_hwrite),
        .HWDATA (m0_hwdata),
        .HRDATA (m0_hrdata),
        .HREADY (m0_hready),
        .HRESP  (m0_hresp)
    );

    // AHB interconnect
    ahb_interconnect_4m u_ahb_ic (
        .clk        (clk),
        .rst        (rst),

        .m0_haddr   (m0_haddr),
        .m0_hsize   (m0_hsize),
        .m0_hburst  (m0_hburst),
        .m0_htrans  (m0_htrans),
        .m0_hwrite  (m0_hwrite),
        .m0_hwdata  (m0_hwdata),
        .m0_hrdata  (m0_hrdata),
        .m0_hready  (m0_hready),
        .m0_hresp   (m0_hresp),

        .m1_haddr   (m1_haddr),
        .m1_hsize   (m1_hsize),
        .m1_hburst  (m1_hburst),
        .m1_htrans  (m1_htrans),
        .m1_hwrite  (m1_hwrite),
        .m1_hwdata  (m1_hwdata),
        .m1_hrdata  (m1_hrdata),
        .m1_hready  (m1_hready),
        .m1_hresp   (m1_hresp),

        .m2_haddr   (m2_haddr),
        .m2_hsize   (m2_hsize),
        .m2_hburst  (m2_hburst),
        .m2_htrans  (m2_htrans),
        .m2_hwrite  (m2_hwrite),
        .m2_hwdata  (m2_hwdata),
        .m2_hrdata  (m2_hrdata),
        .m2_hready  (m2_hready),
        .m2_hresp   (m2_hresp),

        .m3_haddr   (m3_haddr),
        .m3_hsize   (m3_hsize),
        .m3_hburst  (m3_hburst),
        .m3_htrans  (m3_htrans),
        .m3_hwrite  (m3_hwrite),
        .m3_hwdata  (m3_hwdata),
        .m3_hrdata  (m3_hrdata),
        .m3_hready  (m3_hready),
        .m3_hresp   (m3_hresp),

        .s0_haddr   (s0_haddr),
        .s0_hsize   (s0_hsize),
        .s0_hburst  (s0_hburst),
        .s0_htrans  (s0_htrans),
        .s0_hwrite  (s0_hwrite),
        .s0_hwdata  (s0_hwdata),
        .s0_hrdata  (s0_hrdata),
        .s0_hready  (s0_hready),
        .s0_hresp   (s0_hresp),

        .s1_haddr   (s1_haddr),
        .s1_hsize   (s1_hsize),
        .s1_hburst  (s1_hburst),
        .s1_htrans  (s1_htrans),
        .s1_hwrite  (s1_hwrite),
        .s1_hwdata  (s1_hwdata),
        .s1_hrdata  (s1_hrdata),
        .s1_hready  (s1_hready),
        .s1_hresp   (s1_hresp)
    );

    // Boot ROM
    boot_rom u_boot_rom (
        .clk    (clk),
        .rst    (rst),
        .HADDR  (s0_haddr),
        .HSIZE  (s0_hsize),
        .HBURST (s0_hburst),
        .HTRANS (s0_htrans),
        .HWRITE (s0_hwrite),
        .HWDATA (s0_hwdata),
        .HRDATA (s0_hrdata),
        .HREADY (s0_hready),
        .HRESP  (s0_hresp)
    );

    // AHB→Wishbone bridge on slave 1
    wire [31:0] wb_adr_m;
    wire [31:0] wb_dat_o_m;
    wire [31:0] wb_dat_i_m;
    wire        wb_we_m;
    wire [3:0]  wb_sel_m;
    wire        wb_cyc_m;
    wire        wb_stb_m;
    wire        wb_ack_m;
    wire        wb_err_m;

    ahb_to_wb_bridge u_ahb2wb (
        .clk        (clk),
        .rst        (rst),

        .HADDR      (s1_haddr),
        .HSIZE      (s1_hsize),
        .HBURST     (s1_hburst),
        .HTRANS     (s1_htrans),
        .HWRITE     (s1_hwrite),
        .HWDATA     (s1_hwdata),
        .HRDATA     (s1_hrdata),
        .HREADY     (s1_hready),
        .HRESP      (s1_hresp),

        .wb_adr_o   (wb_adr_m),
        .wb_dat_o   (wb_dat_o_m),
        .wb_dat_i   (wb_dat_i_m),
        .wb_we_o    (wb_we_m),
        .wb_sel_o   (wb_sel_m),
        .wb_cyc_o   (wb_cyc_m),
        .wb_stb_o   (wb_stb_m),
        .wb_ack_i   (wb_ack_m),
        .wb_err_i   (wb_err_m)
    );

    // Wishbone interconnect and stub slaves
    wire [31:0] s0_dat_i, s1_dat_i, s2_dat_i, s3_dat_i, s4_dat_i, s5_dat_i;
    wire        s0_ack_i, s1_ack_i, s2_ack_i, s3_ack_i, s4_ack_i, s5_ack_i;
    wire        s0_err_i, s1_err_i, s2_err_i, s3_err_i, s4_err_i, s5_err_i;

    wire [31:0] s0_adr_o, s1_adr_o, s2_adr_o, s3_adr_o, s4_adr_o, s5_adr_o;
    wire [31:0] s0_dat_o, s1_dat_o, s2_dat_o, s3_dat_o, s4_dat_o, s5_dat_o;
    wire        s0_we_o, s1_we_o, s2_we_o, s3_we_o, s4_we_o, s5_we_o;
    wire [3:0]  s0_sel_o, s1_sel_o, s2_sel_o, s3_sel_o, s4_sel_o, s5_sel_o;
    wire        s0_cyc_o, s1_cyc_o, s2_cyc_o, s3_cyc_o, s4_cyc_o, s5_cyc_o;
    wire        s0_stb_o, s1_stb_o, s2_stb_o, s3_stb_o, s4_stb_o, s5_stb_o;

    wb_interconnect u_wb_ic (
        .clk        (clk),
        .rst        (rst),

        .m_adr_i    (wb_adr_m),
        .m_dat_i    (wb_dat_o_m),
        .m_dat_o    (wb_dat_i_m),
        .m_we_i     (wb_we_m),
        .m_sel_i    (wb_sel_m),
        .m_cyc_i    (wb_cyc_m),
        .m_stb_i    (wb_stb_m),
        .m_ack_o    (wb_ack_m),
        .m_err_o    (wb_err_m),

        .s0_adr_o   (s0_adr_o),
        .s0_dat_o   (s0_dat_o),
        .s0_dat_i   (s0_dat_i),
        .s0_we_o    (s0_we_o),
        .s0_sel_o   (s0_sel_o),
        .s0_cyc_o   (s0_cyc_o),
        .s0_stb_o   (s0_stb_o),
        .s0_ack_i   (s0_ack_i),
        .s0_err_i   (s0_err_i),

        .s1_adr_o   (s1_adr_o),
        .s1_dat_o   (s1_dat_o),
        .s1_dat_i   (s1_dat_i),
        .s1_we_o    (s1_we_o),
        .s1_sel_o   (s1_sel_o),
        .s1_cyc_o   (s1_cyc_o),
        .s1_stb_o   (s1_stb_o),
        .s1_ack_i   (s1_ack_i),
        .s1_err_i   (s1_err_i),

        .s2_adr_o   (s2_adr_o),
        .s2_dat_o   (s2_dat_o),
        .s2_dat_i   (s2_dat_i),
        .s2_we_o    (s2_we_o),
        .s2_sel_o   (s2_sel_o),
        .s2_cyc_o   (s2_cyc_o),
        .s2_stb_o   (s2_stb_o),
        .s2_ack_i   (s2_ack_i),
        .s2_err_i   (s2_err_i),

        .s3_adr_o   (s3_adr_o),
        .s3_dat_o   (s3_dat_o),
        .s3_dat_i   (s3_dat_i),
        .s3_we_o    (s3_we_o),
        .s3_sel_o   (s3_sel_o),
        .s3_cyc_o   (s3_cyc_o),
        .s3_stb_o   (s3_stb_o),
        .s3_ack_i   (s3_ack_i),
        .s3_err_i   (s3_err_i),

        .s4_adr_o   (s4_adr_o),
        .s4_dat_o   (s4_dat_o),
        .s4_dat_i   (s4_dat_i),
        .s4_we_o    (s4_we_o),
        .s4_sel_o   (s4_sel_o),
        .s4_cyc_o   (s4_cyc_o),
        .s4_stb_o   (s4_stb_o),
        .s4_ack_i   (s4_ack_i),
        .s4_err_i   (s4_err_i),

        .s5_adr_o   (s5_adr_o),
        .s5_dat_o   (s5_dat_o),
        .s5_dat_i   (s5_dat_i),
        .s5_we_o    (s5_we_o),
        .s5_sel_o   (s5_sel_o),
        .s5_cyc_o   (s5_cyc_o),
        .s5_stb_o   (s5_stb_o),
        .s5_ack_i   (s5_ack_i),
        .s5_err_i   (s5_err_i)
    );

    // Stub slaves for now: always ACK, no error, return distinct constants
    assign s0_dat_i = 32'hSDRA_0000; assign s0_ack_i = s0_cyc_o & s0_stb_o; assign s0_err_i = 1'b0;
    assign s1_dat_i = 32'hUART_0000; assign s1_ack_i = s1_cyc_o & s1_stb_o; assign s1_err_i = 1'b0;
    assign s2_dat_i = 32'hI2C0_000;  assign s2_ack_i = s2_cyc_o & s2_stb_o; assign s2_err_i = 1'b0;
    assign s3_dat_i = 32'hSPI0_000;  assign s3_ack_i = s3_cyc_o & s3_stb_o; assign s3_err_i = 1'b0;
    assign s4_dat_i = 32'hGPIO_000;  assign s4_ack_i = s4_cyc_o & s4_stb_o; assign s4_err_i = 1'b0;
    assign s5_dat_i = 32'hJTAG_000;  assign s5_ack_i = s5_cyc_o & s5_stb_o; assign s5_err_i = 1'b0;

endmodule

================================================================================
STEP 4 — QUARTUS BUILD & PROGRAMMING (STILL SRAM-ONLY, NO FLASH)
================================================================================

1. Ensure files are in place:
   - ~/fpga/h3_phase1_sc/rtl/soc/hazard3_tile.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/ahb_interconnect_4m.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/boot_rom.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/ahb_to_wb_bridge.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/wb_interconnect.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv
   - Hazard3 core RTL under rtl/cores/hazard3/...

2. Boot ROM hex:
   - cd ~/hazard3_fw/bootrom
   - make
   - Copy bootrom.hex into ~/fpga/h3_phase1_sc/quartus (or adjust path in boot_rom.sv).

3. In Quartus:
   - Open h3_phase1_sc project (from Phase 1A).
   - Add the new RTL files (ahb_to_wb_bridge, wb_interconnect, updated top_soc.sv).
   - Re-run Analysis & Synthesis and full Compilation.

4. Program DE0-Lite (SRAM-only):
   - Open Quartus Programmer.
   - Mode: JTAG.
   - File: h3_phase1_sc.sof (output_files/).
   - Check ONLY “Program/Configure”.
   - DO NOT create or program .pof. DO NOT set any configuration device.
   - Click Start.

5. After programming:
   - HART0 still boots from ROM and loops in _start().
   - Any AHB access in 0x1000_0000–0x8FFF_FFFF goes through the AHB→WB bridge
     and WB interconnect to stub slaves, returning known constants.

================================================================================
WHAT PHASE 1B ACHIEVES TOWARD QUAD-CORE GOAL
================================================================================

- You now have a **quad-core-ready bus architecture**:
  - 4-master AHB interconnect (M0 live, M1–M3 reserved).
  - AHB→WB bridge as a unified gateway to all off-core memory & peripherals.
  - Wishbone fabric with stable, final address map for SDRAM and peripherals.

- The next phases can now cleanly:
  - Replace SDRAM stub (s0) with OpenCores SDRAM controller (Phase 1C).
  - Replace UART/I2C/SPI/GPIO/JTAG-UART stubs (s1–s5) with real IP (Phases 1D–1H).
  - Add bootloader, HAL, and firmware on top (1I–1K).
  - Then scale to 2 and 4 cores by hooking up more hazard3_tile instances to M1..M3.

################END PHASE1B#############
================================================================================
PHASE 1C: SDRAM INTEGRATION (OPENCORES CONTROLLER) INTO AHB→WB FABRIC
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 1C
----------------
Replace the SDRAM stub (Wishbone s0) from Phase 1B with a **real** OpenCores-style
SDRAM controller, giving you:

- External SDRAM @ 0x8000_0000 on DE0-Lite.
- SDRAM accessed via:
  Hazard3 → AHB interconnect → AHB→WB bridge → WB SDRAM controller.
- Still: only `.sof` programmed via JTAG into **SRAM**, never flash.
  On power-cycle, the DE0-Lite returns to its factory demo.

ASSUMPTIONS
-----------
- You have the DE0-Lite’s SDRAM chip (IS42S16400 or equivalent 16-bit SDRAM) wired
  to the FPGA using the Terasic reference design.
- You can download an OpenCores SDRAM controller that:
  - Speaks **Wishbone** on the system side.
  - Drives standard SDRAM signals (addr, bank, dq, dqm, ras/cas/we, cke, clk).
- We’ll:
  - Add a WB wrapper/top for the SDRAM controller.
  - Connect it to s0_* ports of wb_interconnect.
  - Expose SDRAM pins from top_soc.
  - Keep all other slaves (UART/I2C/SPI/GPIO/JTAG-UART) as stubs for now.

DIRECTORY CONTEXT
-----------------
We add:

- ~/fpga/h3_phase1_sc/rtl/cores/opencores_sdram/
    - sdram_ctrl.v            (from OpenCores)
    - (other files as needed by that core)
- ~/fpga/h3_phase1_sc/rtl/soc/sdram_wb_wrapper.sv   (NEW)
- Update: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv    (add SDRAM instance + pins)

You still have:

- hazard3_tile.sv
- ahb_interconnect_4m.sv
- ahb_to_wb_bridge.sv
- wb_interconnect.sv
- boot_rom.sv
- bootrom.hex (Phase 1A ROM)

================================================================================
STEP 1 — PLACE THE OPENCORES SDRAM CONTROLLER RTL
================================================================================

1. Create directory for the SDRAM core:

   mkdir -p ~/fpga/h3_phase1_sc/rtl/cores/opencores_sdram

2. Download the OpenCores SDRAM controller sources from opencores.org into that
   directory. The main top-level usually has a name like:

   - sdram_ctrl.v   or
   - sdr_ctrl.v

   It typically exposes:

   - Wishbone system interface:
     - wb_clk_i, wb_rst_i
     - wb_adr_i, wb_dat_i, wb_dat_o, wb_sel_i, wb_cyc_i, wb_stb_i, wb_we_i
     - wb_ack_o, wb_err_o
   - SDRAM signals:
     - sdram_clk, sdram_cke, sdram_cs_n, sdram_ras_n, sdram_cas_n, sdram_we_n
     - sdram_ba, sdram_a
     - sdram_dqm, sdram_dq

   The exact names may differ slightly; adjust the wrapper accordingly.

================================================================================
STEP 2 — WISHBONE SDRAM WRAPPER (ADAPT TO OUR FABRIC)
================================================================================

We wrap the raw SDRAM controller into a module with **exactly** the Wishbone ports
expected by wb_interconnect for s0.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/sdram_wb_wrapper.sv -------------------

module sdram_wb_wrapper
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone slave interface (from wb_interconnect)
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output wire [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output wire        wb_ack_o,
    output wire        wb_err_o,

    // SDRAM physical interface (to DE0-Lite board pins)
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq
);

    // The OpenCores controller often expects:
    // - byte address or word address; we pass wb_adr_i directly / or truncated.
    // - 32-bit data; matches our fabric.
    // - synchronous reset and clock.

    // Adjust these instance/port names to your specific OpenCores SDRAM core.
    // Example instance (placeholder names):

    wire [31:0] sdram_dat_o;
    wire        sdram_ack_o;
    wire        sdram_err_o;

    assign wb_dat_o = sdram_dat_o;
    assign wb_ack_o = sdram_ack_o;
    assign wb_err_o = sdram_err_o;

    sdram_ctrl u_sdram (
        // System
        .wb_clk_i   (clk),
        .wb_rst_i   (rst),

        .wb_adr_i   (wb_adr_i),
        .wb_dat_i   (wb_dat_i),
        .wb_dat_o   (sdram_dat_o),
        .wb_sel_i   (wb_sel_i),
        .wb_cyc_i   (wb_cyc_i),
        .wb_stb_i   (wb_stb_i),
        .wb_we_i    (wb_we_i),
        .wb_ack_o   (sdram_ack_o),
        .wb_err_o   (sdram_err_o),

        // SDRAM
        .sdram_clk  (sdram_clk),
        .sdram_cke  (sdram_cke),
        .sdram_cs_n (sdram_cs_n),
        .sdram_ras_n(sdram_ras_n),
        .sdram_cas_n(sdram_cas_n),
        .sdram_we_n (sdram_we_n),
        .sdram_ba   (sdram_ba),
        .sdram_a    (sdram_a),
        .sdram_dqm  (sdram_dqm),
        .sdram_dq   (sdram_dq)
    );

endmodule

NOTES:
- The exact module name and ports of the OpenCores SDRAM core might differ:
  - You might need to map address width, data width, CAS latency, etc.
  - You may need to parameterize the controller (e.g. bank bits, row/col bits).
- This wrapper’s job is only to match **Wishbone** and expose SDRAM pins.

================================================================================
STEP 3 — UPDATE wb_interconnect TO BE USED WITH REAL SDRAM (LOGIC ALREADY OK)
================================================================================

Our Phase 1B wb_interconnect is already structurally correct for s0 as SDRAM.  
We just need to:

- Connect s0_* ports to sdram_wb_wrapper instead of the s0 stub.

No change required inside wb_interconnect.sv itself.

================================================================================
STEP 4 — UPDATE top_soc.sv TO INSTANTIATE SDRAM WRAPPER + EXPOSE PINS
================================================================================

We now modify top_soc.sv:

- Add SDRAM pins to the module ports.
- Replace SDRAM stub assignments for s0_… with the real wrapper instance.
- Keep stubs for s1–s5 (UART/I2C/SPI/GPIO/JTAG-UART) for now.

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv -------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n,

    // SDRAM pins (to DE0-Lite external SDRAM)
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq

    // Later phases: add UART/I2C/SPI/GPIO pins here
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    //======================
    // AHB masters as in Phase 1B (HART0 + reserved M1..M3)
    //======================
    wire [31:0] m0_haddr;
    wire [2:0]  m0_hsize;
    wire [1:0]  m0_hburst;
    wire [1:0]  m0_htrans;
    wire        m0_hwrite;
    wire [31:0] m0_hwdata;
    wire [31:0] m0_hrdata;
    wire        m0_hready;
    wire        m0_hresp;

    wire [31:0] m1_haddr = 32'h0;
    wire [2:0]  m1_hsize = 3'b010;
    wire [1:0]  m1_hburst = 2'b00;
    wire [1:0]  m1_htrans = 2'b00;
    wire        m1_hwrite = 1'b0;
    wire [31:0] m1_hwdata = 32'h0;
    wire [31:0] m1_hrdata;
    wire        m1_hready;
    wire        m1_hresp;

    wire [31:0] m2_haddr = 32'h0;
    wire [2:0]  m2_hsize = 3'b010;
    wire [1:0]  m2_hburst = 2'b00;
    wire [1:0]  m2_htrans = 2'b00;
    wire        m2_hwrite = 1'b0;
    wire [31:0] m2_hwdata = 32'h0;
    wire [31:0] m2_hrdata;
    wire        m2_hready;
    wire        m2_hresp;

    wire [31:0] m3_haddr = 32'h0;
    wire [2:0]  m3_hsize = 3'b010;
    wire [1:0]  m3_hburst = 2'b00;
    wire [1:0]  m3_htrans = 2'b00;
    wire        m3_hwrite = 1'b0;
    wire [31:0] m3_hwdata = 32'h0;
    wire [31:0] m3_hrdata;
    wire        m3_hready;
    wire        m3_hresp;

    // AHB slaves: s0 = ROM, s1 = AHB→WB
    wire [31:0] s0_haddr, s1_haddr;
    wire [2:0]  s0_hsize, s1_hsize;
    wire [1:0]  s0_hburst, s1_hburst;
    wire [1:0]  s0_htrans, s1_htrans;
    wire        s0_hwrite, s1_hwrite;
    wire [31:0] s0_hwdata, s1_hwdata;
    wire [31:0] s0_hrdata, s1_hrdata;
    wire        s0_hready, s1_hready;
    wire        s0_hresp,  s1_hresp;

    // HART0
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m0_haddr),
        .HSIZE  (m0_hsize),
        .HBURST (m0_hburst),
        .HTRANS (m0_htrans),
        .HWRITE (m0_hwrite),
        .HWDATA (m0_hwdata),
        .HRDATA (m0_hrdata),
        .HREADY (m0_hready),
        .HRESP  (m0_hresp)
    );

    // AHB interconnect
    ahb_interconnect_4m u_ahb_ic (
        .clk        (clk),
        .rst        (rst),

        .m0_haddr   (m0_haddr),
        .m0_hsize   (m0_hsize),
        .m0_hburst  (m0_hburst),
        .m0_htrans  (m0_htrans),
        .m0_hwrite  (m0_hwrite),
        .m0_hwdata  (m0_hwdata),
        .m0_hrdata  (m0_hrdata),
        .m0_hready  (m0_hready),
        .m0_hresp   (m0_hresp),

        .m1_haddr   (m1_haddr),
        .m1_hsize   (m1_hsize),
        .m1_hburst  (m1_hburst),
        .m1_htrans  (m1_htrans),
        .m1_hwrite  (m1_hwrite),
        .m1_hwdata  (m1_hwdata),
        .m1_hrdata  (m1_hrdata),
        .m1_hready  (m1_hready),
        .m1_hresp   (m1_hresp),

        .m2_haddr   (m2_haddr),
        .m2_hsize   (m2_hsize),
        .m2_hburst  (m2_hburst),
        .m2_htrans  (m2_htrans),
        .m2_hwrite  (m2_hwrite),
        .m2_hwdata  (m2_hwdata),
        .m2_hrdata  (m2_hrdata),
        .m2_hready  (m2_hready),
        .m2_hresp   (m2_hresp),

        .m3_haddr   (m3_haddr),
        .m3_hsize   (m3_hsize),
        .m3_hburst  (m3_hburst),
        .m3_htrans  (m3_htrans),
        .m3_hwrite  (m3_hwrite),
        .m3_hwdata  (m3_hwdata),
        .m3_hrdata  (m3_hrdata),
        .m3_hready  (m3_hready),
        .m3_hresp   (m3_hresp),

        .s0_haddr   (s0_haddr),
        .s0_hsize   (s0_hsize),
        .s0_hburst  (s0_hburst),
        .s0_htrans  (s0_htrans),
        .s0_hwrite  (s0_hwrite),
        .s0_hwdata  (s0_hwdata),
        .s0_hrdata  (s0_hrdata),
        .s0_hready  (s0_hready),
        .s0_hresp   (s0_hresp),

        .s1_haddr   (s1_haddr),
        .s1_hsize   (s1_hsize),
        .s1_hburst  (s1_hburst),
        .s1_htrans  (s1_htrans),
        .s1_hwrite  (s1_hwrite),
        .s1_hwdata  (s1_hwdata),
        .s1_hrdata  (s1_hrdata),
        .s1_hready  (s1_hready),
        .s1_hresp   (s1_hresp)
    );

    // Boot ROM @ 0x2000_0000
    boot_rom u_boot_rom (
        .clk    (clk),
        .rst    (rst),
        .HADDR  (s0_haddr),
        .HSIZE  (s0_hsize),
        .HBURST (s0_hburst),
        .HTRANS (s0_htrans),
        .HWRITE (s0_hwrite),
        .HWDATA (s0_hwdata),
        .HRDATA (s0_hrdata),
        .HREADY (s0_hready),
        .HRESP  (s0_hresp)
    );

    // AHB→Wishbone bridge on slave 1 (peripheral/SRAM region)
    wire [31:0] wb_adr_m;
    wire [31:0] wb_dat_o_m;
    wire [31:0] wb_dat_i_m;
    wire        wb_we_m;
    wire [3:0]  wb_sel_m;
    wire        wb_cyc_m;
    wire        wb_stb_m;
    wire        wb_ack_m;
    wire        wb_err_m;

    ahb_to_wb_bridge u_ahb2wb (
        .clk        (clk),
        .rst        (rst),

        .HADDR      (s1_haddr),
        .HSIZE      (s1_hsize),
        .HBURST     (s1_hburst),
        .HTRANS     (s1_htrans),
        .HWRITE     (s1_hwrite),
        .HWDATA     (s1_hwdata),
        .HRDATA     (s1_hrdata),
        .HREADY     (s1_hready),
        .HRESP      (s1_hresp),

        .wb_adr_o   (wb_adr_m),
        .wb_dat_o   (wb_dat_o_m),
        .wb_dat_i   (wb_dat_i_m),
        .wb_we_o    (wb_we_m),
        .wb_sel_o   (wb_sel_m),
        .wb_cyc_o   (wb_cyc_m),
        .wb_stb_o   (wb_stb_m),
        .wb_ack_i   (wb_ack_m),
        .wb_err_i   (wb_err_m)
    );

    // Wishbone interconnect
    wire [31:0] s0_dat_i, s1_dat_i, s2_dat_i, s3_dat_i, s4_dat_i, s5_dat_i;
    wire        s0_ack_i, s1_ack_i, s2_ack_i, s3_ack_i, s4_ack_i, s5_ack_i;
    wire        s0_err_i, s1_err_i, s2_err_i, s3_err_i, s4_err_i, s5_err_i;

    wire [31:0] s0_adr_o, s1_adr_o, s2_adr_o, s3_adr_o, s4_adr_o, s5_adr_o;
    wire [31:0] s0_dat_o, s1_dat_o, s2_dat_o, s3_dat_o, s4_dat_o, s5_dat_o;
    wire        s0_we_o,  s1_we_o,  s2_we_o,  s3_we_o,  s4_we_o,  s5_we_o;
    wire [3:0]  s0_sel_o, s1_sel_o, s2_sel_o, s3_sel_o, s4_sel_o, s5_sel_o;
    wire        s0_cyc_o, s1_cyc_o, s2_cyc_o, s3_cyc_o, s4_cyc_o, s5_cyc_o;
    wire        s0_stb_o, s1_stb_o, s2_stb_o, s3_stb_o, s4_stb_o, s5_stb_o;

    wb_interconnect u_wb_ic (
        .clk        (clk),
        .rst        (rst),

        .m_adr_i    (wb_adr_m),
        .m_dat_i    (wb_dat_o_m),
        .m_dat_o    (wb_dat_i_m),
        .m_we_i     (wb_we_m),
        .m_sel_i    (wb_sel_m),
        .m_cyc_i    (wb_cyc_m),
        .m_stb_i    (wb_stb_m),
        .m_ack_o    (wb_ack_m),
        .m_err_o    (wb_err_m),

        .s0_adr_o   (s0_adr_o),
        .s0_dat_o   (s0_dat_o),
        .s0_dat_i   (s0_dat_i),
        .s0_we_o    (s0_we_o),
        .s0_sel_o   (s0_sel_o),
        .s0_cyc_o   (s0_cyc_o),
        .s0_stb_o   (s0_stb_o),
        .s0_ack_i   (s0_ack_i),
        .s0_err_i   (s0_err_i),

        .s1_adr_o   (s1_adr_o),
        .s1_dat_o   (s1_dat_o),
        .s1_dat_i   (s1_dat_i),
        .s1_we_o    (s1_we_o),
        .s1_sel_o   (s1_sel_o),
        .s1_cyc_o   (s1_cyc_o),
        .s1_stb_o   (s1_stb_o),
        .s1_ack_i   (s1_ack_i),
        .s1_err_i   (s1_err_i),

        .s2_adr_o   (s2_adr_o),
        .s2_dat_o   (s2_dat_o),
        .s2_dat_i   (s2_dat_i),
        .s2_we_o    (s2_we_o),
        .s2_sel_o   (s2_sel_o),
        .s2_cyc_o   (s2_cyc_o),
        .s2_stb_o   (s2_stb_o),
        .s2_ack_i   (s2_ack_i),
        .s2_err_i   (s2_err_i),

        .s3_adr_o   (s3_adr_o),
        .s3_dat_o   (s3_dat_o),
        .s3_dat_i   (s3_dat_i),
        .s3_we_o    (s3_we_o),
        .s3_sel_o   (s3_sel_o),
        .s3_cyc_o   (s3_cyc_o),
        .s3_stb_o   (s3_stb_o),
        .s3_ack_i   (s3_ack_i),
        .s3_err_i   (s3_err_i),

        .s4_adr_o   (s4_adr_o),
        .s4_dat_o   (s4_dat_o),
        .s4_dat_i   (s4_dat_i),
        .s4_we_o    (s4_we_o),
        .s4_sel_o   (s4_sel_o),
        .s4_cyc_o   (s4_cyc_o),
        .s4_stb_o   (s4_stb_o),
        .s4_ack_i   (s4_ack_i),
        .s4_err_i   (s4_err_i),

        .s5_adr_o   (s5_adr_o),
        .s5_dat_o   (s5_dat_o),
        .s5_dat_i   (s5_dat_i),
        .s5_we_o    (s5_we_o),
        .s5_sel_o   (s5_sel_o),
        .s5_cyc_o   (s5_cyc_o),
        .s5_stb_o   (s5_stb_o),
        .s5_ack_i   (s5_ack_i),
        .s5_err_i   (s5_err_i)
    );

    // SDRAM slave (s0): connect to real SDRAM controller
    sdram_wb_wrapper u_sdram_wb (
        .clk        (clk),
        .rst        (rst),

        .wb_adr_i   (s0_adr_o),
        .wb_dat_i   (s0_dat_o),
        .wb_dat_o   (s0_dat_i),
        .wb_we_i    (s0_we_o),
        .wb_sel_i   (s0_sel_o),
        .wb_cyc_i   (s0_cyc_o),
        .wb_stb_i   (s0_stb_o),
        .wb_ack_o   (s0_ack_i),
        .wb_err_o   (s0_err_i),

        .sdram_a    (sdram_a),
        .sdram_ba   (sdram_ba),
        .sdram_clk  (sdram_clk),
        .sdram_cke  (sdram_cke),
        .sdram_cs_n (sdram_cs_n),
        .sdram_ras_n(sdram_ras_n),
        .sdram_cas_n(sdram_cas_n),
        .sdram_we_n (sdram_we_n),
        .sdram_dqm  (sdram_dqm),
        .sdram_dq   (sdram_dq)
    );

    // Stub peripherals for now
    assign s1_dat_i = 32'hUART_0000; assign s1_ack_i = s1_cyc_o & s1_stb_o; assign s1_err_i = 1'b0;
    assign s2_dat_i = 32'hI2C0_000;  assign s2_ack_i = s2_cyc_o & s2_stb_o; assign s2_err_i = 1'b0;
    assign s3_dat_i = 32'hSPI0_000;  assign s3_ack_i = s3_cyc_o & s3_stb_o; assign s3_err_i = 1'b0;
    assign s4_dat_i = 32'hGPIO_000;  assign s4_ack_i = s4_cyc_o & s4_stb_o; assign s4_err_i = 1'b0;
    assign s5_dat_i = 32'hJTAG_000;  assign s5_ack_i = s5_cyc_o & s5_stb_o; assign s5_err_i = 1'b0;

endmodule

================================================================================
STEP 5 — QUARTUS: PINS, BUILD, PROGRAM (SRAM-ONLY)
================================================================================

1. Add SDRAM controller RTL to project:
   - In Quartus → Add/Remove Files:
     - ../rtl/cores/opencores_sdram/*.v
     - ../rtl/soc/sdram_wb_wrapper.sv
     - Updated ../rtl/soc/top_soc.sv

2. Pin assignments for SDRAM:
   - Map sdram_* ports in top_soc to the correct DE0-Lite SDRAM pins according
     to the board’s user manual (Terasic pin-out table).
   - Typically:
     - sdram_clk → dedicated SDRAM clock pin.
     - sdram_a[12:0], sdram_ba[1:0], sdram_dq[15:0], sdram_dqm[1:0],
       sdram_cs_n, sdram_ras_n, sdram_cas_n, sdram_we_n, sdram_cke → as per ref.

3. Boot ROM:
   - Ensure bootrom.hex is in the Quartus project directory, or path in boot_rom.sv
     is adjusted.

4. Compile:
   - Processing → Start Compilation.

5. Program SRAM (never flash):
   - Open Quartus Programmer.
   - Mode: JTAG.
   - File: h3_phase1_sc.sof.
   - Check only “Program/Configure”.
   - Click Start.

6. Behavior:
   - Hazard3 boots from ROM at 0x2000_0000 and runs the Phase 1A stub (infinite WFI).
   - Any subsequent C firmware we create can now place .text/.data in SDRAM at
     0x8000_0000, and the bus path is fully real:
       Core → AHB → Bridge → WB → SDRAM controller → SDRAM pins.
   - On power-cycle, board reverts to factory demo image from flash.

================================================================================
WHAT PHASE 1C GIVES YOU TOWARD THE QUAD-CORE GOAL
================================================================================

- A scalable memory architecture:
  - SDRAM as a first-class WB slave under a single AHB→WB gateway.
  - Address map: 0x8000_0000.. for code/data.
- Fully compatible with adding:
  - More Hazard3 tiles (M1..M3).
  - Peripherals behind the same WB fabric (UART/I2C/SPI/GPIO/JTAG-UART).
  - Bootloader that uploads firmware into SDRAM and jumps to 0x8000_0000.

Next natural step is **Phase 1D**:
- Integrate a real OpenCores UART16550 on s1 (0x1000_0000) with a minimal test
  firmware to prove SDRAM + UART together.

##############END Phase 1C################
================================================================================
PHASE 1D: REAL UART16550 INTEGRATION ON WISHBONE s1 @ 0x1000_0000
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 1D
----------------
Take the SoC from Phase 1C (Hazard3 + AHB→WB + SDRAM) and:

- Replace the UART stub on Wishbone s1 with a **real** OpenCores UART16550.
- Map UART0 at 0x1000_0000 (word-addressed).
- Expose UART RX/TX pins on DE0-Lite Arduino D0/D1 (or equivalent).
- Add a tiny test firmware that:
  - Boots from ROM.
  - Writes to UART0 registers.
  - Sends a “Hello from UART0” message over the external USB‑serial dongle.

NO changes to your ephemeral rule:
- Only `.sof` via JTAG to **SRAM**.
- Never program flash (.pof).
- On power-cycle, DE0‑Lite returns to factory demo.

ASSUMPTIONS
-----------
- You already have:
  - Phase 1A + 1B + 1C implemented and compiling:
    - hazard3_tile.sv
    - ahb_interconnect_4m.sv
    - ahb_to_wb_bridge.sv
    - wb_interconnect.sv
    - boot_rom.sv
    - sdram_wb_wrapper.sv
    - top_soc.sv (with SDRAM pins)
  - Boot ROM stub (bootrom.c) that loops forever.
- You have (or can obtain) OpenCores UART16550 RTL with a Wishbone interface.

DIRECTORY CONTEXT
-----------------
We add:

- ~/fpga/h3_phase1_sc/rtl/cores/opencores_uart16550/
    - uart_top.v (or similar; main 16550 + WB top)
    - other UART core files
- ~/fpga/h3_phase1_sc/rtl/soc/uart16550_wb_wrapper.sv   (NEW)
- Update: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv         (connect UART to s1)
- Update: ~/hazard3_fw/bootrom/bootrom.c                 (minimal UART test)

We maintain:
- Only `.sof` via JTAG.
- Bootrom.hex as ROM content.

================================================================================
STEP 1 — PLACE THE OPENCORES UART16550 SOURCES
================================================================================

1. Create directory for UART core:

   mkdir -p ~/fpga/h3_phase1_sc/rtl/cores/opencores_uart16550

2. Download OpenCores UART16550 from opencores.org (or equivalent mirror):

   - Place its Verilog files in:
     ~/fpga/h3_phase1_sc/rtl/cores/opencores_uart16550/

3. Identify the Wishbone wrapper/top for the UART core:
   - Common names: uart_top.v, uart_wb.v, etc.
   - It typically exposes:
     - Wishbone:
       - wb_clk_i, wb_rst_i
       - wb_adr_i, wb_dat_i, wb_dat_o, wb_sel_i, wb_cyc_i, wb_stb_i, wb_we_i
       - wb_ack_o
     - UART pins:
       - stx_o (TX)
       - srx_i (RX)
     - Optional modem control pins (we can tie unused to constants).

You’ll adjust the wrapper below to the exact module/port names from the core you fetched.

================================================================================
STEP 2 — UART16550 WISHBONE WRAPPER (s1 SLAVE)
================================================================================

We wrap the OpenCores UART16550 into a module with the Wishbone interface that
matches s1_* in wb_interconnect.

Addressing model:
- We’ll use the low address bits [7:2] as register index (word-addressed).
- The core may expect byte addressing; we pass the full wb_adr_i and let it use what it needs.

UART configuration:
- 8N1, FIFOs enabled, 115200 baud from 50 MHz clock.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/uart16550_wb_wrapper.sv ----------------

module uart16550_wb_wrapper
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone slave interface
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output wire [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output wire        wb_ack_o,
    output wire        wb_err_o,

    // UART pins
    input  wire        uart_rx,
    output wire        uart_tx
);

    // For this simple case, we don't use wb_err_o.
    assign wb_err_o = 1'b0;

    // OpenCores UART16550 usually has an 8-bit data bus.
    // We map our 32-bit WB bus to 8 bits by using the low byte and ignoring others.
    // For a more correct implementation, you’d consider wb_sel_i and partial writes.

    wire        uart_ack;
    wire [7:0]  uart_dat_o;

    assign wb_ack_o   = uart_ack;
    assign wb_dat_o   = {24'h0, uart_dat_o};

    // Example instance; adapt module/port names to the actual OpenCores UART top.
    uart_top u_uart (
        .wb_clk_i   (clk),
        .wb_rst_i   (rst),

        .wb_adr_i   (wb_adr_i[4:2]),   // word-aligned 3-bit register index (0..7)
        .wb_dat_i   (wb_dat_i[7:0]),
        .wb_dat_o   (uart_dat_o),
        .wb_we_i    (wb_we_i),
        .wb_sel_i   (wb_sel_i[0]),
        .wb_cyc_i   (wb_cyc_i),
        .wb_stb_i   (wb_stb_i),
        .wb_ack_o   (uart_ack),

        // Modem control (tie off if not used)
        .stx_pad_o  (uart_tx),
        .srx_pad_i  (uart_rx),
        .rts_pad_o  (),
        .cts_pad_i  (1'b0),
        .dtr_pad_o  (),
        .dsr_pad_i  (1'b0),
        .ri_pad_i   (1'b0),
        .dcd_pad_i  (1'b0),

        // Interrupt (unused for now)
        .int_o      ()
    );

endmodule

NOTES:
- You must check the actual OpenCores UART top port list and adjust:
  - Module name (uart_top vs. something else).
  - Address width (wb_adr_i bits).
  - Data bus width (8 vs. 32 bits).
  - Modem control pins.

================================================================================
STEP 3 — UPDATE top_soc.sv TO CONNECT UART0 ON s1 AND EXPOSE UART PINS
================================================================================

We now:

- Add UART pins (uart0_rx, uart0_tx) to top_soc.
- Replace the s1 stub (UART) with the real uart16550_wb_wrapper.

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv --------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n,

    // SDRAM pins
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq,

    // UART0 pins (map to D0/D1 on DE0-Lite Arduino header)
    input  wire        uart0_rx,
    output wire        uart0_tx

    // Later: add I2C/SPI/GPIO pins
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    // (UNCHANGED) AHB masters M0..M3, AHB slaves s0..s1, Hazard3 tile,
    // AHB interconnect, Boot ROM, AHB→WB bridge, WB interconnect, SDRAM integration
    // Keep everything from Phase 1C as-is, except the stub for s1 (UART).

    // ... (same declarations as Phase 1C: m0..m3_*; s0..s1_*; etc.) ...

    // HART0
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 ( /* same as Phase 1C */ );

    // AHB interconnect
    ahb_interconnect_4m u_ahb_ic ( /* same as Phase 1C */ );

    // Boot ROM
    boot_rom u_boot_rom ( /* same as Phase 1C (hooked to s0_*) */ );

    // AHB→Wishbone bridge on s1
    wire [31:0] wb_adr_m;
    wire [31:0] wb_dat_o_m;
    wire [31:0] wb_dat_i_m;
    wire        wb_we_m;
    wire [3:0]  wb_sel_m;
    wire        wb_cyc_m;
    wire        wb_stb_m;
    wire        wb_ack_m;
    wire        wb_err_m;

    ahb_to_wb_bridge u_ahb2wb ( /* same as Phase 1C (hooked to s1_*) */ );

    // Wishbone interconnect
    wire [31:0] s0_dat_i, s1_dat_i, s2_dat_i, s3_dat_i, s4_dat_i, s5_dat_i;
    wire        s0_ack_i, s1_ack_i, s2_ack_i, s3_ack_i, s4_ack_i, s5_ack_i;
    wire        s0_err_i, s1_err_i, s2_err_i, s3_err_i, s4_err_i, s5_err_i;

    wire [31:0] s0_adr_o, s1_adr_o, s2_adr_o, s3_adr_o, s4_adr_o, s5_adr_o;
    wire [31:0] s0_dat_o, s1_dat_o, s2_dat_o, s3_dat_o, s4_dat_o, s5_dat_o;
    wire        s0_we_o, s1_we_o, s2_we_o, s3_we_o, s4_we_o, s5_we_o;
    wire [3:0]  s0_sel_o, s1_sel_o, s2_sel_o, s3_sel_o, s4_sel_o, s5_sel_o;
    wire        s0_cyc_o, s1_cyc_o, s2_cyc_o, s3_cyc_o, s4_cyc_o, s5_cyc_o;
    wire        s0_stb_o, s1_stb_o, s2_stb_o, s3_stb_o, s4_stb_o, s5_stb_o;

    wb_interconnect u_wb_ic ( /* same as Phase 1C */ );

    // SDRAM (s0)
    sdram_wb_wrapper u_sdram_wb (
        .clk        (clk),
        .rst        (rst),

        .wb_adr_i   (s0_adr_o),
        .wb_dat_i   (s0_dat_o),
        .wb_dat_o   (s0_dat_i),
        .wb_we_i    (s0_we_o),
        .wb_sel_i   (s0_sel_o),
        .wb_cyc_i   (s0_cyc_o),
        .wb_stb_i   (s0_stb_o),
        .wb_ack_o   (s0_ack_i),
        .wb_err_o   (s0_err_i),

        .sdram_a    (sdram_a),
        .sdram_ba   (sdram_ba),
        .sdram_clk  (sdram_clk),
        .sdram_cke  (sdram_cke),
        .sdram_cs_n (sdram_cs_n),
        .sdram_ras_n(sdram_ras_n),
        .sdram_cas_n(sdram_cas_n),
        .sdram_we_n (sdram_we_n),
        .sdram_dqm  (sdram_dqm),
        .sdram_dq   (sdram_dq)
    );

    // UART0 (s1): real OpenCores 16550
    uart16550_wb_wrapper u_uart0 (
        .clk        (clk),
        .rst        (rst),

        .wb_adr_i   (s1_adr_o),
        .wb_dat_i   (s1_dat_o),
        .wb_dat_o   (s1_dat_i),
        .wb_we_i    (s1_we_o),
        .wb_sel_i   (s1_sel_o),
        .wb_cyc_i   (s1_cyc_o),
        .wb_stb_i   (s1_stb_o),
        .wb_ack_o   (s1_ack_i),
        .wb_err_o   (s1_err_i),

        .uart_rx    (uart0_rx),
        .uart_tx    (uart0_tx)
    );

    // Still stub peripherals for now
    assign s2_dat_i = 32'hI2C0_000;  assign s2_ack_i = s2_cyc_o & s2_stb_o; assign s2_err_i = 1'b0;
    assign s3_dat_i = 32'hSPI0_000;  assign s3_ack_i = s3_cyc_o & s3_stb_o; assign s3_err_i = 1'b0;
    assign s4_dat_i = 32'hGPIO_000;  assign s4_ack_i = s4_cyc_o & s4_stb_o; assign s4_err_i = 1'b0;
    assign s5_dat_i = 32'hJTAG_000;  assign s5_ack_i = s5_cyc_o & s5_stb_o; assign s5_err_i = 1'b0;

endmodule

NOTE:
- I’ve elided the repeated, unchanged declarations/instantiations from Phase 1C
  with “(same as Phase 1C)” to keep this readable, but in your actual file you’ll
  have the complete code.

================================================================================
STEP 4 — UPDATE BOOT ROM TO EXERCISE UART0
================================================================================

For a first UART test, we can:

- Keep executing from ROM @ 0x2000_0000.
- Directly program UART registers via its memory map at 0x1000_0000.
- Print a short string once.

We’ll assume a 16550-like register layout with byte addressing:

Offset (byte)  Register
0x00           RBR/THR (RX/TX)
0x04           IER
0x08           IIR/FCR
0x0C           LCR
0x10           MCR
0x14           LSR
0x18           MSR
0x1C           SCR
DLAB=1 remaps 0x00/0x04 to DLL/DLM

We’ll use 32-bit accesses but only low byte matters (wrapper maps to 8-bit).

----- UPDATED FILE: ~/hazard3_fw/bootrom/bootrom.c ----------------------------

#include <stdint.h>

#define UART0_BASE   0x10000000u

#define UART_RBR     (*(volatile uint32_t *)(UART0_BASE + 0x00)) // RX (DLAB=0)
#define UART_THR     (*(volatile uint32_t *)(UART0_BASE + 0x00)) // TX (DLAB=0)
#define UART_IER     (*(volatile uint32_t *)(UART0_BASE + 0x04))
#define UART_IIR     (*(volatile uint32_t *)(UART0_BASE + 0x08))
#define UART_FCR     (*(volatile uint32_t *)(UART0_BASE + 0x08))
#define UART_LCR     (*(volatile uint32_t *)(UART0_BASE + 0x0C))
#define UART_MCR     (*(volatile uint32_t *)(UART0_BASE + 0x10))
#define UART_LSR     (*(volatile uint32_t *)(UART0_BASE + 0x14))

#define UART_LSR_DR   (1u << 0)
#define UART_LSR_THRE (1u << 5)

static void uart_init(uint32_t sys_clk_hz, uint32_t baud)
{
    // 16550: divisor = clk / (16 * baud)
    uint32_t divisor = sys_clk_hz / (16u * baud);

    // Enable DLAB to access DLL/DLM
    UART_LCR = 0x80u;
    UART_THR = (divisor & 0xFFu);          // DLL
    UART_IER = ((divisor >> 8) & 0xFFu);   // DLM

    // 8N1, DLAB=0
    UART_LCR = 0x03u;

    // Enable FIFO, clear RX/TX
    UART_FCR = 0x07u;

    // Modem Control: set OUT2 (often needed to enable interrupts), but we won't use IRQs yet
    UART_MCR = 0x08u;
}

static void uart_putc(char c)
{
    while (!(UART_LSR & UART_LSR_THRE)) {
        // wait
    }
    UART_THR = (uint8_t)c;
}

static void uart_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') {
            uart_putc('\r');
        }
        uart_putc(*s++);
    }
}

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;
    uart_init(SYS_CLK_HZ, 115200u);

    uart_puts("Hazard3 Phase 1D: UART16550 test\n");
    uart_puts("If you see this over UART0, the bridge + WB + UART are alive.\n");

    while (1) {
        __asm__ volatile("wfi");
    }
}

Rebuild bootrom.hex:

   cd ~/hazard3_fw/bootrom
   make

Ensure bootrom.hex is visible to Quartus (e.g. copy to project dir).

================================================================================
STEP 5 — QUARTUS: FILES, PINS, BUILD, PROGRAM (SRAM-ONLY)
================================================================================

1. Add UART core RTL:
   - Quartus → Add/Remove Files:
     - ../rtl/cores/opencores_uart16550/*.v
     - ../rtl/soc/uart16550_wb_wrapper.sv
     - Updated ../rtl/soc/top_soc.sv

2. UART0 pin assignment:
   - Map uart0_tx and uart0_rx to DE0-Lite Arduino D1 and D0 respectively
     (check board manual for exact pin names).
   - Connect your 3.3 V USB‑serial dongle:
     - Dongle TX → SoC RX (D0 / uart0_rx).
     - Dongle RX → SoC TX (D1 / uart0_tx).
     - GND → GND.

3. Boot ROM:
   - Ensure the new bootrom.hex (with UART test) is in the location referenced
     by boot_rom.sv.

4. Compile:
   - Processing → Start Compilation.

5. Program SRAM only:
   - Quartus Programmer:
     - Hardware: USB-Blaster.
     - File: h3_phase1_sc.sof.
     - Check only “Program/Configure”.
     - START.
   - Do **not** create/use .pof or program any configuration device.

6. Run-time test:
   - Power on DE0-Lite → factory demo loads from flash by default.
   - Program .sof over JTAG → Hazard3 SoC overlays into SRAM.
   - Open a serial terminal on the host at 115200 8N1 on the USB‑serial port.
   - Reset DE0-Lite (reset_n asserted then released).
   - You should see:

     Hazard3 Phase 1D: UART16550 test
     If you see this over UART0, the bridge + WB + UART are alive.

   - Power-cycle the board:
     - Your SoC disappears.
     - Factory demo reappears, as required.

================================================================================
WHAT PHASE 1D GIVES YOU TOWARD THE QUAD-CORE GOAL
================================================================================

- Real, OpenCores UART16550 integrated into the same WB fabric as SDRAM.
- Cleanly memory-mapped at 0x1000_0000 behind AHB→WB bridge.
- Verified end-to-end path:
  Hazard3 core → AHB → AHB→WB bridge → WB interconnect → UART16550 → pins.
- Preserves:
  - Quad-core-ready AHB fabric (M0..M3).
  - Ephemeral configuration (SRAM-only .sof, factory demo on power-cycle).
################END PHASE1D##############
================================================================================
PHASE 1E: REAL I2C MASTER INTEGRATION ON WISHBONE s2 @ 0x1000_0100
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 1E
----------------
Extend the SoC from Phase 1D (Hazard3 + SDRAM + UART16550) by:

- Replacing the I2C stub on Wishbone s2 with a **real OpenCores I2C master**.
- Mapping I2C0 at 0x1000_0100 (byte/word accessed via WB).
- Exposing SDA/SCL pins (open-drain) on Arduino A4/A5.
- Adding a simple ROM-based test:
  - Configure I2C for 100 kHz.
  - Try a write/read to a known/slave address (e.g. 0x68 or dummy poll).
  - Print status via UART0.

Still:
- Only `.sof` via JTAG to SRAM (no .pof, no flash programming).
- Power-cycle → DE0-Lite factory demo restored automatically.

ASSUMPTIONS
-----------
You already have from earlier phases:

- AHB master (HART0 tile) and 4-master AHB fabric.
- AHB→WB bridge feeding wb_interconnect.
- SDRAM integrated as s0 (OpenCores SDRAM).
- UART16550 integrated as s1 (OpenCores UART) @ 0x1000_0000.
- Stub slaves for s2 (I2C), s3 (SPI), s4 (GPIO), s5 (JTAG-UART).
- Boot ROM that prints over UART0.

We now replace the I2C stub on s2 with a real OpenCores I2C master.

================================================================================
STEP 1 — PLACE THE OPENCORES I2C MASTER SOURCES
================================================================================

1. Create directory for I2C core:

   mkdir -p ~/fpga/h3_phase1_sc/rtl/cores/opencores_i2c

2. Download OpenCores I2C master from opencores.org and place all RTL files in:

   ~/fpga/h3_phase1_sc/rtl/cores/opencores_i2c/

3. Identify the Wishbone top-level, commonly named something like:

   i2c_master_top.v

   It typically has ports like:

   - Wishbone:
     - wb_clk_i, wb_rst_i
     - wb_adr_i[2:0], wb_dat_i[7:0], wb_dat_o[7:0]
     - wb_we_i, wb_stb_i, wb_cyc_i
     - wb_ack_o
   - I2C:
     - scl_pad_i, scl_pad_o, scl_padoen_o
     - sda_pad_i, sda_pad_o, sda_padoen_o

We’ll wrap that into our WB interface and map to top_soc SDA/SCL pins as open-drain.

================================================================================
STEP 2 — I2C WISHBONE WRAPPER (s2 SLAVE)
================================================================================

We wrap i2c_master_top into a module with the s2_* Wishbone interface expected by
wb_interconnect:

- 32-bit WB data but core is 8-bit → we map low byte.
- We use address bits [4:2] or [2:0] depending on the core.
- Provide SDA/SCL as inout, using oe signals from core.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/i2c_wb_wrapper.sv ---------------------

module i2c_wb_wrapper
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone slave interface
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output wire [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output wire        wb_ack_o,
    output wire        wb_err_o,

    // I2C pins (to board)
    inout  wire        sda,
    inout  wire        scl
);

    assign wb_err_o = 1'b0;

    // Low byte used for I2C core
    wire [7:0] i2c_dat_o;

    assign wb_dat_o = {24'h0, i2c_dat_o};

    // Address mapping:
    // The classic OpenCores I2C uses 3-bit register index:
    // 0: PRERlo, 1: PRERhi, 2: CTR, 3: TXR/RXR, 4: CR/SR, others reserved.
    wire [2:0] reg_adr = wb_adr_i[4:2];

    // I2C pads: open-drain behavior
    wire scl_pad_i, scl_pad_o, scl_padoen_o;
    wire sda_pad_i, sda_pad_o, sda_padoen_o;

    assign scl_pad_i = scl;
    assign sda_pad_i = sda;

    assign scl = (scl_padoen_o == 1'b0) ? scl_pad_o : 1'bz;
    assign sda = (sda_padoen_o == 1'b0) ? sda_pad_o : 1'bz;

    i2c_master_top u_i2c (
        .wb_clk_i   (clk),
        .wb_rst_i   (rst),

        .wb_adr_i   (reg_adr),
        .wb_dat_i   (wb_dat_i[7:0]),
        .wb_dat_o   (i2c_dat_o),
        .wb_we_i    (wb_we_i),
        .wb_stb_i   (wb_stb_i),
        .wb_cyc_i   (wb_cyc_i),
        .wb_ack_o   (wb_ack_o),

        // Interrupt (unused for now)
        .wb_inta_o  (),

        // I2C signals
        .scl_pad_i  (scl_pad_i),
        .scl_pad_o  (scl_pad_o),
        .scl_padoen_o (scl_padoen_o),
        .sda_pad_i  (sda_pad_i),
        .sda_pad_o  (sda_pad_o),
        .sda_padoen_o (sda_padoen_o)
    );

endmodule

NOTE:
- Adjust module/port names if your I2C core differs.
- The key is: we present a clean WB slave and drive sda/scl as open-drain IO.

================================================================================
STEP 3 — UPDATE top_soc.sv TO INSTANTIATE I2C (s2) + EXPOSE SDA/SCL PINS
================================================================================

We add:

- I2C pins to top_soc (i2c_sda, i2c_scl).
- Replace the s2 stub with i2c_wb_wrapper instance.

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv --------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n,

    // SDRAM pins
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq,

    // UART0 pins
    input  wire        uart0_rx,
    output wire        uart0_tx,

    // I2C0 pins (map to Arduino A4/A5)
    inout  wire        i2c_sda,
    inout  wire        i2c_scl

    // Later: SPI, GPIO, JTAG-UART
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    // All AHB/wb signals same as Phase 1D; only difference is s2 hookup.

    // ... Hazard3 tile, AHB interconnect, Boot ROM, AHB→WB bridge, WB interconnect
    //     and SDRAM (u_sdram_wb) same as Phase 1D ...

    // UART0 on s1 (unchanged)
    uart16550_wb_wrapper u_uart0 (
        .clk        (clk),
        .rst        (rst),
        .wb_adr_i   (s1_adr_o),
        .wb_dat_i   (s1_dat_o),
        .wb_dat_o   (s1_dat_i),
        .wb_we_i    (s1_we_o),
        .wb_sel_i   (s1_sel_o),
        .wb_cyc_i   (s1_cyc_o),
        .wb_stb_i   (s1_stb_o),
        .wb_ack_o   (s1_ack_i),
        .wb_err_o   (s1_err_i),

        .uart_rx    (uart0_rx),
        .uart_tx    (uart0_tx)
    );

    // I2C0 on s2: real OpenCores I2C master
    i2c_wb_wrapper u_i2c0 (
        .clk        (clk),
        .rst        (rst),

        .wb_adr_i   (s2_adr_o),
        .wb_dat_i   (s2_dat_o),
        .wb_dat_o   (s2_dat_i),
        .wb_we_i    (s2_we_o),
        .wb_sel_i   (s2_sel_o),
        .wb_cyc_i   (s2_cyc_o),
        .wb_stb_i   (s2_stb_o),
        .wb_ack_o   (s2_ack_i),
        .wb_err_o   (s2_err_i),

        .sda        (i2c_sda),
        .scl        (i2c_scl)
    );

    // Keep stubs for others for now
    assign s3_dat_i = 32'hSPI0_000;  assign s3_ack_i = s3_cyc_o & s3_stb_o; assign s3_err_i = 1'b0;
    assign s4_dat_i = 32'hGPIO_000;  assign s4_ack_i = s4_cyc_o & s4_stb_o; assign s4_err_i = 1'b0;
    assign s5_dat_i = 32'hJTAG_000;  assign s5_ack_i = s5_cyc_o & s5_stb_o; assign s5_err_i = 1'b0;

endmodule

(In your actual file, ensure all the AHB/WB signal declarations and other instantiations
from Phase 1C/1D remain intact; only the s2 stub is replaced.)

================================================================================
STEP 4 — BOOT ROM I2C TEST (ROM-BASED, PRINTS STATUS OVER UART)
================================================================================

We’ll extend bootrom.c to:

- Initialize UART (as in 1D).
- Initialize I2C core:
  - Set prescaler for ~100 kHz from 50 MHz.
  - Enable core.
- Attempt a simple transaction:
  - Write to a target address (e.g. 0x68) with a dummy register index.
  - Check for ACK/NACK.
- Print result on UART.

I2C Register Map (OpenCores standard):

Base: 0x1000_0100

Offset  Register
0x00    PRERlo
0x04    PRERhi
0x08    CTR
0x0C    TXR/RXR
0x10    CR/SR

Bits:
- CTR:
  - EN (bit 7) = 1 to enable core
- CR:
  - STA (bit 7) = START
  - STO (bit 6) = STOP
  - RD  (bit 5) = read
  - WR  (bit 4) = write
  - ACK (bit 3) = ACK bit for reads
- SR:
  - RxACK (bit 7) = 0 if ACK received, 1 if NACK
  - TIP  (bit 1) = transfer in progress

----- UPDATED FILE: ~/hazard3_fw/bootrom/bootrom.c ----------------------------

#include <stdint.h>

#define UART0_BASE   0x10000000u
#define UART_RBR     (*(volatile uint32_t *)(UART0_BASE + 0x00))
#define UART_THR     (*(volatile uint32_t *)(UART0_BASE + 0x00))
#define UART_IER     (*(volatile uint32_t *)(UART0_BASE + 0x04))
#define UART_FCR     (*(volatile uint32_t *)(UART0_BASE + 0x08))
#define UART_LCR     (*(volatile uint32_t *)(UART0_BASE + 0x0C))
#define UART_MCR     (*(volatile uint32_t *)(UART0_BASE + 0x10))
#define UART_LSR     (*(volatile uint32_t *)(UART0_BASE + 0x14))

#define UART_LSR_DR   (1u << 0)
#define UART_LSR_THRE (1u << 5)

#define I2C0_BASE    0x10000100u
#define I2C_PRER_LO  (*(volatile uint32_t *)(I2C0_BASE + 0x00))
#define I2C_PRER_HI  (*(volatile uint32_t *)(I2C0_BASE + 0x04))
#define I2C_CTR      (*(volatile uint32_t *)(I2C0_BASE + 0x08))
#define I2C_TXR      (*(volatile uint32_t *)(I2C0_BASE + 0x0C))
#define I2C_RXR      (*(volatile uint32_t *)(I2C0_BASE + 0x0C))
#define I2C_CR       (*(volatile uint32_t *)(I2C0_BASE + 0x10))
#define I2C_SR       (*(volatile uint32_t *)(I2C0_BASE + 0x10))

#define I2C_CTR_EN   (1u << 7)
#define I2C_CR_STA   (1u << 7)
#define I2C_CR_STO   (1u << 6)
#define I2C_CR_RD    (1u << 5)
#define I2C_CR_WR    (1u << 4)
#define I2C_CR_ACK   (1u << 3)

#define I2C_SR_RXACK (1u << 7)
#define I2C_SR_TIP   (1u << 1)

static void uart_init(uint32_t sys_clk_hz, uint32_t baud)
{
    uint32_t divisor = sys_clk_hz / (16u * baud);

    UART_LCR = 0x80u;
    UART_THR = (divisor & 0xFFu);
    UART_IER = ((divisor >> 8) & 0xFFu);
    UART_LCR = 0x03u;
    UART_FCR = 0x07u;
    UART_MCR = 0x08u;
}

static void uart_putc(char c)
{
    while (!(UART_LSR & UART_LSR_THRE)) { }
    UART_THR = (uint8_t)c;
}

static void uart_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') uart_putc('\r');
        uart_putc(*s++);
    }
}

static void i2c_init(uint32_t sys_clk_hz, uint32_t bus_khz)
{
    uint32_t freq = bus_khz * 1000u;
    uint32_t presc = (sys_clk_hz / (5u * freq)) - 1u; // from OC I2C docs

    I2C_PRER_LO = (presc & 0xFFu);
    I2C_PRER_HI = ((presc >> 8) & 0xFFu);
    I2C_CTR     = I2C_CTR_EN;
}

static int i2c_write_byte(uint8_t addr7, uint8_t reg, uint8_t data)
{
    // Send START + address (write)
    I2C_TXR = (uint32_t)((addr7 << 1) | 0u);
    I2C_CR  = I2C_CR_STA | I2C_CR_WR;
    while (I2C_SR & I2C_SR_TIP) { }
    if (I2C_SR & I2C_SR_RXACK) return -1;

    // Send register index
    I2C_TXR = reg;
    I2C_CR  = I2C_CR_WR;
    while (I2C_SR & I2C_SR_TIP) { }
    if (I2C_SR & I2C_SR_RXACK) return -2;

    // Send data + STOP
    I2C_TXR = data;
    I2C_CR  = I2C_CR_WR | I2C_CR_STO;
    while (I2C_SR & I2C_SR_TIP) { }
    if (I2C_SR & I2C_SR_RXACK) return -3;

    return 0;
}

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;

    uart_init(SYS_CLK_HZ, 115200u);
    uart_puts("Hazard3 Phase 1E: I2C master test\n");

    // Initialize I2C at 100 kHz
    i2c_init(SYS_CLK_HZ, 100u);
    uart_puts("I2C initialized at ~100 kHz\n");

    // Example: try writing to an I2C device at address 0x68, register 0x00, value 0x55
    // If no device is present, we will see NACK and print error.
    int rc = i2c_write_byte(0x68, 0x00, 0x55);

    if (rc == 0) {
        uart_puts("I2C write to 0x68 succeeded (ACK)\n");
    } else {
        uart_puts("I2C write to 0x68 failed with code: ");
        char c = '0' + (char)(-rc);
        uart_putc(c);
        uart_putc('\n');
    }

    while (1) {
        __asm__ volatile("wfi");
    }
}

Rebuild bootrom:

   cd ~/hazard3_fw/bootrom
   make

Copy/update bootrom.hex in the Quartus project directory or ensure path in boot_rom.sv is correct.

================================================================================
STEP 5 — QUARTUS: ADD FILES, SET PINS, COMPILE, PROGRAM (SRAM-ONLY)
================================================================================

1. Add I2C core RTL and wrapper:
   - Quartus → Add/Remove Files:
     - ../rtl/cores/opencores_i2c/*.v
     - ../rtl/soc/i2c_wb_wrapper.sv
     - Updated ../rtl/soc/top_soc.sv

2. Assign I2C pins:
   - Map i2c_sda and i2c_scl to the Arduino A4/A5 pins on DE0-Lite according
     to the board manual (they are usually dedicated I2C pins).
   - Ensure external pull-up resistors or on-board pull-ups are present (SDA/SCL
     are open-drain).

3. Boot ROM:
   - Ensure updated bootrom.hex is accessible for boot_rom.sv.

4. Compile:
   - Processing → Start Compilation.

5. Program SRAM only:
   - Quartus Programmer:
     - Hardware: USB-Blaster.
     - File: h3_phase1_sc.sof.
     - Mode: JTAG, “Program/Configure” checked.
     - START.
   - Do NOT create or program .pof. Do NOT program configuration flash.

6. Run test:
   - Connect UART0 to external USB-serial, open terminal at 115200 8N1.
   - Power on DE0-Lite → factory demo.
   - Program .sof over JTAG → Hazard3 SoC overlays in SRAM.
   - Reset board.
   - Observe UART output:
     - “Hazard3 Phase 1E: I2C master test”
     - “I2C initialized at ~100 kHz”
     - Either “I2C write to 0x68 succeeded (ACK)” or an error code.
   - Power-cycle:
     - Hazard3 SoC disappears.
     - Factory demo returns (ephemeral configuration rule satisfied).

================================================================================
WHAT PHASE 1E GIVES YOU TOWARD THE QUAD-CORE GOAL
================================================================================

- Real OpenCores I2C master integrated as a proper WB slave on s2.
- Clean memory-mapped I2C interface at 0x1000_0100 behind the same AHB→WB bridge
  used by SDRAM and UART.
- Verified system path:
  Hazard3 core → AHB fabric → AHB→WB → WB interconnect → I2C master → SDA/SCL.
- The bus + address map remain stable for future:
  - Adding SPI (1F), GPIO (1G), JTAG-UART (1H).
  - Building bootloader (1I) and HAL (1J).
  - Scaling to multiple Hazard3 tiles sharing this same memory/peripheral fabric.
#########END PHASE1F############
================================================================================
PHASE 1G: REAL GPIO BLOCK ON WISHBONE s4 @ 0x1000_0300 (ARDUINO + LEDS)
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 1G
----------------
Extend the SoC from Phase 1F (Hazard3 + SDRAM + UART + I2C + SPI) by:

- Replacing the GPIO stub on Wishbone s4 with a **real GPIO block**.
- Mapping GPIO @ 0x1000_0300.
- Providing proper direction control and input sampling.
- Mapping GPIO bits to:
  - Arduino digital pins (D2–D13).
  - Optionally on-board LEDs (for quick visual blink).
- Adding a ROM-based test that:
  - Configures one GPIO pin as output (e.g., D2).
  - Toggles it in a small loop.
  - Prints status over UART0.

All while preserving:
- Only `.sof` via JTAG to **SRAM** (never flash; ephemeral).
- Board returns to factory demo on power-cycle.

ASSUMPTIONS
-----------
From previous phases you already have:

- Hazard3 tile and 4-master AHB fabric with HART0 on M0.
- Boot ROM @ 0x2000_0000 (bootrom.hex).
- AHB→WB bridge.
- WB interconnect with s0..s5.
- Real OpenCores:
  - SDRAM controller on s0 @ 0x8000_0000.
  - UART16550 on s1 @ 0x1000_0000.
  - I2C master on s2 @ 0x1000_0100.
  - SPI master on s3 @ 0x1000_0200.
- Stubbed GPIO (s4) and JTAG-UART (s5).
- Boot ROM printing over UART and testing I2C+SPI.

We’ll now replace the s4 stub with a real Wishbone GPIO peripheral.

================================================================================
STEP 1 — DEFINE A SIMPLE, COMPLETE GPIO WISHBONE PERIPHERAL (s4)
================================================================================

We’ll implement a small, self-contained GPIO block with:

- Registers (word-aligned, 32-bit):
  - 0x00: DATA_OUT   (RW)  — output data.
  - 0x04: DATA_IN    (RO)  — sampled input data.
  - 0x08: DIR        (RW)  — 1 = output, 0 = input.
  - 0x0C: PULLUP     (RW)  — 1 = enable pull-up (for input pins; logic-only here).
- 20 GPIO bits:
  - gpio[19:0] mapped to Arduino D2–D13, A0–A5 (for example).

We’ll drive outputs and read inputs via an inout bus `gpio_pins[19:0]`.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/gpio_wb.sv ----------------------------

module gpio_wb
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone slave
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output reg         wb_ack_o,
    output wire        wb_err_o,

    // 20 GPIO pins
    inout  wire [19:0] gpio_pins
);

    assign wb_err_o = 1'b0;

    reg [19:0] data_out;
    reg [19:0] dir;
    reg [19:0] pullup;

    wire [19:0] data_in;

    genvar i;
    generate
        for (i = 0; i < 20; i = i + 1) begin : gpio_buf
            assign gpio_pins[i] = dir[i] ? data_out[i] : 1'bz;
            assign data_in[i]   = gpio_pins[i];
        end
    endgenerate

    wire [3:0] reg_sel = wb_adr_i[5:2];

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            data_out <= 20'h00000;
            dir      <= 20'h00000;
            pullup   <= 20'h00000;
            wb_ack_o <= 1'b0;
            wb_dat_o <= 32'h0;
        end else begin
            wb_ack_o <= 1'b0;

            if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin
                wb_ack_o <= 1'b1;

                if (wb_we_i) begin
                    case (reg_sel)
                        4'h0: data_out <= wb_dat_i[19:0];
                        4'h2: dir      <= wb_dat_i[19:0];
                        4'h3: pullup   <= wb_dat_i[19:0];
                        default: ;
                    endcase
                end else begin
                    case (reg_sel)
                        4'h0: wb_dat_o <= {12'h0, data_out};
                        4'h1: wb_dat_o <= {12'h0, data_in};
                        4'h2: wb_dat_o <= {12'h0, dir};
                        4'h3: wb_dat_o <= {12'h0, pullup};
                        default: wb_dat_o <= 32'h0;
                    endcase
                end
            end
        end
    end

endmodule

NOTES:
- This block is simple but complete: it supports reads/writes, direction, and input sampling.
- PULLUP is stored but not physically enforced; external pull-ups are still needed for some uses.

================================================================================
STEP 2 — UPDATE top_soc.sv TO INSTANTIATE GPIO (s4) + EXPOSE GPIO PINS
================================================================================

We’ll:

- Add `gpio_pins[19:0]` to top_soc ports.
- Replace the s4 stub with a gpio_wb instance.
- Map GPIO bits to physical pins (DE0-Lite Arduino header + LEDs) via pin assignments.

Proposed mapping (logical, final mapping via QSF):

- gpio_pins[0]  → Arduino D2
- gpio_pins[1]  → D3
- gpio_pins[2]  → D4
- gpio_pins[3]  → D5
- gpio_pins[4]  → D6
- gpio_pins[5]  → D7
- gpio_pins[6]  → D8
- gpio_pins[7]  → D9
- gpio_pins[8]  → D10 (but watch out: already used as SPI SS0; you may choose not to share)
- gpio_pins[9]  → D11 (SPI MOSI; again be careful about sharing)
- gpio_pins[10] → D12
- gpio_pins[11] → D13
- gpio_pins[12] → A0
- gpio_pins[13] → A1
- gpio_pins[14] → A2
- gpio_pins[15] → A3
- gpio_pins[16] → A4 (shared with I2C SDA; probably not used as generic GPIO)
- gpio_pins[17] → A5 (shared with I2C SCL)
- gpio_pins[18] → LED0
- gpio_pins[19] → LED1

You can fine-tune this mapping later. For now, we just define the bus and use a couple of bits.

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv --------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n,

    // SDRAM pins
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq,

    // UART0 pins
    input  wire        uart0_rx,
    output wire        uart0_tx,

    // I2C0 pins
    inout  wire        i2c_sda,
    inout  wire        i2c_scl,

    // SPI0 pins
    output wire        spi_mosi,
    input  wire        spi_miso,
    output wire        spi_sck,
    output wire        spi_ss0,

    // GPIO pins (to Arduino header + LEDs)
    inout  wire [19:0] gpio_pins
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    // (UNCHANGED) AHB master/slave signals, Hazard3 tile, AHB interconnect,
    // Boot ROM, AHB→WB bridge, WB interconnect, SDRAM, UART, I2C, SPI.

    // ...
    // All previous declarations/instantiations from Phase 1F remain here.
    // Only s4 hookup changes.
    // ...

    // SDRAM (s0): u_sdram_wb
    // UART0 (s1): u_uart0
    // I2C0  (s2): u_i2c0
    // SPI0  (s3): u_spi0

    // GPIO on s4: real WB GPIO
    gpio_wb u_gpio (
        .clk        (clk),
        .rst        (rst),

        .wb_adr_i   (s4_adr_o),
        .wb_dat_i   (s4_dat_o),
        .wb_dat_o   (s4_dat_i),
        .wb_we_i    (s4_we_o),
        .wb_sel_i   (s4_sel_o),
        .wb_cyc_i   (s4_cyc_o),
        .wb_stb_i   (s4_stb_o),
        .wb_ack_o   (s4_ack_i),
        .wb_err_o   (s4_err_i),

        .gpio_pins  (gpio_pins)
    );

    // Keep s5 as JTAG-UART stub for now
    assign s5_dat_i = 32'hJTAG_000;  assign s5_ack_i = s5_cyc_o & s5_stb_o; assign s5_err_i = 1'b0;

endmodule

(Remember to keep all other signals and modules from Phase 1F intact.)

================================================================================
STEP 3 — BOOT ROM GPIO TEST (TOGGLE A GPIO + PRINT STATUS)
================================================================================

We’ll extend bootrom.c again:

- UART init (as before).
- I2C + SPI init (as in Phase 1F, or we can leave them; they do not interfere).
- GPIO test:
  - Set GPIO bit for a chosen pin as output (e.g. gpio_pins[18] → LED).
  - Toggle it a few times with a delay.
  - Print messages over UART.

GPIO register base and offsets:

- Base:  0x1000_0300
- 0x00: DATA_OUT
- 0x04: DATA_IN
- 0x08: DIR
- 0x0C: PULLUP

We’ll use bit 18 as LED0.

----- UPDATED FILE: ~/hazard3_fw/bootrom/bootrom.c ----------------------------

#include <stdint.h>

#define UART0_BASE   0x10000000u
#define UART_RBR     (*(volatile uint32_t *)(UART0_BASE + 0x00))
#define UART_THR     (*(volatile uint32_t *)(UART0_BASE + 0x00))
#define UART_IER     (*(volatile uint32_t *)(UART0_BASE + 0x04))
#define UART_FCR     (*(volatile uint32_t *)(UART0_BASE + 0x08))
#define UART_LCR     (*(volatile uint32_t *)(UART0_BASE + 0x0C))
#define UART_MCR     (*(volatile uint32_t *)(UART0_BASE + 0x10))
#define UART_LSR     (*(volatile uint32_t *)(UART0_BASE + 0x14))

#define UART_LSR_DR   (1u << 0)
#define UART_LSR_THRE (1u << 5)

#define I2C0_BASE    0x10000100u
#define I2C_PRER_LO  (*(volatile uint32_t *)(I2C0_BASE + 0x00))
#define I2C_PRER_HI  (*(volatile uint32_t *)(I2C0_BASE + 0x04))
#define I2C_CTR      (*(volatile uint32_t *)(I2C0_BASE + 0x08))
#define I2C_TXR      (*(volatile uint32_t *)(I2C0_BASE + 0x0C))
#define I2C_RXR      (*(volatile uint32_t *)(I2C0_BASE + 0x0C))
#define I2C_CR       (*(volatile uint32_t *)(I2C0_BASE + 0x10))
#define I2C_SR       (*(volatile uint32_t *)(I2C0_BASE + 0x10))

#define I2C_CTR_EN   (1u << 7)
#define I2C_CR_STA   (1u << 7)
#define I2C_CR_STO   (1u << 6)
#define I2C_CR_RD    (1u << 5)
#define I2C_CR_WR    (1u << 4)
#define I2C_CR_ACK   (1u << 3)

#define I2C_SR_RXACK (1u << 7)
#define I2C_SR_TIP   (1u << 1)

#define SPI0_BASE      0x10000200u
#define SPI_RXTX       (*(volatile uint32_t *)(SPI0_BASE + 0x00))
#define SPI_STATUS     (*(volatile uint32_t *)(SPI0_BASE + 0x04))
#define SPI_CTRL       (*(volatile uint32_t *)(SPI0_BASE + 0x08))
#define SPI_DIVIDER    (*(volatile uint32_t *)(SPI0_BASE + 0x0C))
#define SPI_SS         (*(volatile uint32_t *)(SPI0_BASE + 0x10))

#define SPI_CTRL_GO     (1u << 0)
#define SPI_CTRL_RXNEG  (1u << 1)
#define SPI_CTRL_TXNEG  (1u << 2)
#define SPI_CTRL_LSBF   (1u << 3)
#define SPI_CTRL_IE     (1u << 4)
#define SPI_CTRL_ASS    (1u << 5)

#define GPIO_BASE      0x10000300u
#define GPIO_DATA_OUT  (*(volatile uint32_t *)(GPIO_BASE + 0x00))
#define GPIO_DATA_IN   (*(volatile uint32_t *)(GPIO_BASE + 0x04))
#define GPIO_DIR       (*(volatile uint32_t *)(GPIO_BASE + 0x08))
#define GPIO_PULLUP    (*(volatile uint32_t *)(GPIO_BASE + 0x0C))

static void uart_init(uint32_t sys_clk_hz, uint32_t baud)
{
    uint32_t divisor = sys_clk_hz / (16u * baud);
    UART_LCR = 0x80u;
    UART_THR = (divisor & 0xFFu);
    UART_IER = ((divisor >> 8) & 0xFFu);
    UART_LCR = 0x03u;
    UART_FCR = 0x07u;
    UART_MCR = 0x08u;
}

static void uart_putc(char c)
{
    while (!(UART_LSR & UART_LSR_THRE)) { }
    UART_THR = (uint8_t)c;
}

static void uart_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') uart_putc('\r');
        uart_putc(*s++);
    }
}

static void uart_put_hex8(uint8_t v)
{
    const char hex[] = "0123456789ABCDEF";
    uart_putc(hex[(v >> 4) & 0xF]);
    uart_putc(hex[v & 0xF]);
}

static void i2c_init(uint32_t sys_clk_hz, uint32_t bus_khz)
{
    uint32_t freq = bus_khz * 1000u;
    uint32_t presc = (sys_clk_hz / (5u * freq)) - 1u;
    I2C_PRER_LO = (presc & 0xFFu);
    I2C_PRER_HI = ((presc >> 8) & 0xFFu);
    I2C_CTR     = I2C_CTR_EN;
}

static int i2c_write_byte(uint8_t addr7, uint8_t reg, uint8_t data)
{
    I2C_TXR = (uint32_t)((addr7 << 1) | 0u);
    I2C_CR  = I2C_CR_STA | I2C_CR_WR;
    while (I2C_SR & I2C_SR_TIP) { }
    if (I2C_SR & I2C_SR_RXACK) return -1;

    I2C_TXR = reg;
    I2C_CR  = I2C_CR_WR;
    while (I2C_SR & I2C_SR_TIP) { }
    if (I2C_SR & I2C_SR_RXACK) return -2;

    I2C_TXR = data;
    I2C_CR  = I2C_CR_WR | I2C_CR_STO;
    while (I2C_SR & I2C_SR_TIP) { }
    if (I2C_SR & I2C_SR_RXACK) return -3;

    return 0;
}

static void spi_init(uint32_t sys_clk_hz)
{
    uint32_t div = 4u;
    SPI_DIVIDER = div;
    uint32_t ctrl = 0;
    ctrl |= SPI_CTRL_ASS;
    SPI_CTRL = ctrl;
    SPI_SS   = 1u;
}

static uint8_t spi_transfer(uint8_t data)
{
    SPI_RXTX = data;
    SPI_CTRL = SPI_CTRL | SPI_CTRL_GO;
    while (SPI_CTRL & SPI_CTRL_GO) { }
    return (uint8_t)(SPI_RXTX & 0xFFu);
}

static void delay(volatile uint32_t cycles)
{
    while (cycles--) {
        __asm__ volatile("nop");
    }
}

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;

    uart_init(SYS_CLK_HZ, 115200u);
    uart_puts("Hazard3 Phase 1G: GPIO test\n");

    i2c_init(SYS_CLK_HZ, 100u);
    uart_puts("I2C initialized\n");

    int rc = i2c_write_byte(0x68, 0x00, 0x55);
    if (rc == 0) {
        uart_puts("I2C write to 0x68 succeeded\n");
    } else {
        uart_puts("I2C write to 0x68 failed\n");
    }

    spi_init(SYS_CLK_HZ);
    uart_puts("SPI initialized\n");
    uint8_t resp = spi_transfer(0x9F);
    uart_puts("SPI transfer 0x9F returned 0x");
    uart_put_hex8(resp);
    uart_putc('\n');

    // GPIO test: use bit 18 as LED output
    uart_puts("Configuring GPIO bit 18 as output (LED)\n");
    GPIO_DIR    |= (1u << 18);
    GPIO_PULLUP &= ~(1u << 18);

    for (int i = 0; i < 10; i++) {
        uart_puts("LED ON\n");
        GPIO_DATA_OUT |= (1u << 18);
        delay(5000000u);

        uart_puts("LED OFF\n");
        GPIO_DATA_OUT &= ~(1u << 18);
        delay(5000000u);
    }

    uart_puts("GPIO blink test done\n");

    while (1) {
        __asm__ volatile("wfi");
    }
}

Rebuild bootrom:

   cd ~/hazard3_fw/bootrom
   make

Copy/refresh bootrom.hex into the Quartus project directory (or ensure boot_rom.sv points to this updated file).

================================================================================
STEP 4 — QUARTUS: ADD GPIO MODULE, MAP PINS, COMPILE, PROGRAM (SRAM-ONLY)
================================================================================

1. Add GPIO RTL:
   - In Quartus → Add/Remove Files:
     - ../rtl/soc/gpio_wb.sv
     - Updated ../rtl/soc/top_soc.sv

2. Pin mappings:
   - Map gpio_pins[] bits to physical pins:
     - At minimum map gpio_pins[18] to one of the DE0-Lite LEDs or Arduino pins
       you can see easily (e.g., LED0).
     - Map others according to your desired Arduino layout later.
   - Use the DE0-Lite user manual to assign correct FPGA pins in the .qsf.

3. Boot ROM:
   - Ensure the new bootrom.hex is accessible to boot_rom.sv.

4. Compile:
   - Processing → Start Compilation.

5. Program SRAM only:
   - Quartus Programmer:
     - Hardware: USB-Blaster.
     - File: h3_phase1_sc.sof.
     - Mode: JTAG, “Program/Configure” checked.
     - START.
   - Do NOT generate or program any .pof; do NOT program configuration flash.
   - Power-cycle → board returns to factory demo.

6. Run-time check:
   - Connect UART0 to USB-serial at 115200 8N1 and watch output.
   - Program .sof into SRAM.
   - Reset board.
   - You should see:

     Hazard3 Phase 1G: GPIO test
     I2C initialized
     I2C write to 0x68 ...
     SPI initialized
     SPI transfer 0x9F returned 0xXX
     Configuring GPIO bit 18 as output (LED)
     LED ON
     LED OFF
     ... (repeats 10 times)
     GPIO blink test done

   - And the mapped LED should visibly blink.

================================================================================
WHAT PHASE 1G GIVES YOU TOWARD THE QUAD-CORE GOAL
================================================================================

- A real, memory-mapped GPIO peripheral behind the same WB fabric as SDRAM/UART/I2C/SPI.
- Clean Arduino/LED-level control via registers at 0x1000_0300.
- Verified that the SoC now exercises:
  - Instruction fetch in ROM.
  - Peripheral access over AHB→WB to SDRAM, UART, I2C, SPI, GPIO.
- The architecture remains:
  - Quad-core-ready at the AHB level (M0..M3).
  - Ephemeral configuration (SRAM-only, revert to factory on power-cycle).

Next, we can:
- 1H: integrate JTAG-UART as a WB slave on s5.
- 1I: introduce a dual-path bootloader (UART0 + JTAG-UART) loading firmware into SDRAM.
- 1J: build a HAL using these peripherals.
- 1K: move to SDRAM-resident user firmware and then start multi-core work

##############End Phase 1G########

================================================================================
PHASE 1H: JTAG-UART INTEGRATION ON WISHBONE s5 @ 0x1000_0500
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 1H
----------------
Extend the SoC from Phase 1G (Hazard3 + SDRAM + UART + I2C + SPI + GPIO) by:

- Replacing the JTAG-UART stub on Wishbone s5 with a **real JTAG-UART** block.
- Mapping JTAG-UART @ 0x1000_0500.
- Using the Intel JTAG UART IP, wrapped in a simple Wishbone shim.
- Adding ROM-based test code that:
  - Prints over UART0 (external USB-serial).
  - Prints over JTAG-UART (seen via nios2-terminal).

Constraints preserved:
- Only `.sof` via JTAG to **SRAM**, NEVER flash.
- Power-cycle → DE0-Lite factory demo restored.

HIGH-LEVEL STRATEGY
-------------------
The Intel JTAG UART IP is Avalon-MM, not Wishbone. We’ll:

- Instantiate Intel JTAG UART in Quartus (IP Catalog).
- Wrap it in a small Avalon-MM→Wishbone shim in RTL.
- Expose a minimal register interface at 0x1000_0500:

  - 0x00: DATA (read/write)
  - 0x04: CONTROL/STATUS

Implementations vary, but the default Nios-style mapping is:

- DATA:
  - write: send char if TX space available.
  - read: get char if RX data available.
- CONTROL:
  - upper bits: RX count
  - lower bits: TX space

We’ll mirror that behavior logically in the HAL/boot code.

================================================================================
STEP 1 — CREATE AVALON-MM JTAG UART VIA QUARTUS IP
================================================================================

1. In Quartus, open your h3_phase1_sc project.

2. IP Catalog → “JTAG UART”:
   - Create “JTAG UART” IP.
   - Interface: Avalon-MM slave.
   - Data width: 32 bits.
   - Address width: 2 (giving 0x0 and 0x4 registers).
   - Name the instance e.g.: jtag_uart_0
   - Generate HDL files into:

     ~/fpga/h3_phase1_sc/rtl/cores/intel_jtag_uart/

   This will produce:
   - jtag_uart_0.v (or .sv)
   - jtag_uart_0.qip
   - Supporting files.

3. Add the .qip file to your project:
   - Project → Add/Remove Files in Project.
   - Add `../rtl/cores/intel_jtag_uart/jtag_uart_0.qip`.

We do NOT modify this Intel IP; we only wrap it.

================================================================================
STEP 2 — WISHBONE WRAPPER AROUND AVALON JTAG UART (s5 SLAVE)
================================================================================

We now build a small Wishbone wrapper exposing:

- 0x00: DATA
- 0x04: CONTROL

The wrapper:

- Translates WB cycles to Avalon reads/writes.
- Implements simple “wait until ready” semantics for ROM test (no IRQs).

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/jtag_uart_wb_wrapper.sv --------------

module jtag_uart_wb_wrapper
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone slave interface
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output reg         wb_ack_o,
    output wire        wb_err_o,

    // JTAG UART Avalon-MM signals
    // (match the generated jtag_uart_0 module ports)
    output wire [1:0]  av_address,
    output wire        av_read_n,
    input  wire [31:0] av_readdata,
    output wire        av_write_n,
    output wire [31:0] av_writedata,
    input  wire        av_waitrequest,
    input  wire        av_irq
);

    assign wb_err_o = 1'b0;

    // We decode only word addresses 0x00 and 0x04 relative to 0x1000_0500.
    wire [1:0] reg_adr = wb_adr_i[3:2];

    // Avalon expects active-low read/write strobes.
    reg        read_req;
    reg        write_req;

    assign av_address   = reg_adr;
    assign av_read_n    = ~read_req;
    assign av_write_n   = ~write_req;
    assign av_writedata = wb_dat_i;

    // Simple FSM: IDLE -> ACCESS -> DONE
    localparam ST_IDLE  = 2'd0;
    localparam ST_WAIT  = 2'd1;
    localparam ST_DONE  = 2'd2;

    reg [1:0] state, next_state;

    always @(posedge clk or posedge rst) begin
        if (rst) state <= ST_IDLE;
        else     state <= next_state;
    end

    always @(*) begin
        next_state = state;
        case (state)
            ST_IDLE: begin
                if (wb_cyc_i && wb_stb_i) begin
                    next_state = ST_WAIT;
                end
            end
            ST_WAIT: begin
                if (!av_waitrequest) begin
                    next_state = ST_DONE;
                end
            end
            ST_DONE: begin
                next_state = ST_IDLE;
            end
        endcase
    end

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            read_req  <= 1'b0;
            write_req <= 1'b0;
            wb_ack_o  <= 1'b0;
            wb_dat_o  <= 32'h0;
        end else begin
            wb_ack_o  <= 1'b0;
            read_req  <= 1'b0;
            write_req <= 1'b0;

            case (state)
                ST_IDLE: begin
                    if (wb_cyc_i && wb_stb_i) begin
                        if (wb_we_i)
                            write_req <= 1'b1;
                        else
                            read_req <= 1'b1;
                    end
                end
                ST_WAIT: begin
                    // hold read_req/write_req from previous cycle if needed
                    if (wb_we_i)
                        write_req <= 1'b1;
                    else
                        read_req <= 1'b1;
                end
                ST_DONE: begin
                    wb_ack_o <= 1'b1;
                    if (!wb_we_i)
                        wb_dat_o <= av_readdata;
                end
            endcase
        end
    end

endmodule

NOTES:
- You may need to tweak exactly how av_waitrequest is used depending on the JTAG UART IP behavior.
- If the IP has no waitrequest, tie it to 0 and simplify FSM.

================================================================================
STEP 3 — INSTANTIATE THE INTEL JTAG UART + WRAPPER IN top_soc.sv (s5)
================================================================================

We now:

- Add Avalon signals for JTAG UART instance in top_soc.
- Instantiate `jtag_uart_0` (from Intel IP).
- Wrap it with `jtag_uart_wb_wrapper` connected to s5_*.

No new external pins: JTAG UART uses the JTAG interface already present (USB-Blaster).

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv --------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n,

    // SDRAM pins
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq,

    // UART0 pins
    input  wire        uart0_rx,
    output wire        uart0_tx,

    // I2C0 pins
    inout  wire        i2c_sda,
    inout  wire        i2c_scl,

    // SPI0 pins
    output wire        spi_mosi,
    input  wire        spi_miso,
    output wire        spi_sck,
    output wire        spi_ss0,

    // GPIO pins
    inout  wire [19:0] gpio_pins
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    // *** All AHB/WB signals and modules from Phase 1G remain the same ***
    // hazard3_tile, ahb_interconnect_4m, boot_rom, ahb_to_wb_bridge,
    // wb_interconnect, sdram_wb_wrapper (s0), uart16550_wb_wrapper (s1),
    // i2c_wb_wrapper (s2), spi_wb_wrapper (s3), gpio_wb (s4).

    // We only replace the s5 stub with real JTAG UART.

    // ...
    // [existing declarations and instances for m0..m3, s0..s5, wb, etc.]
    // ...

    // JTAG UART Avalon signals
    wire [1:0]  ju_av_address;
    wire        ju_av_read_n;
    wire [31:0] ju_av_readdata;
    wire        ju_av_write_n;
    wire [31:0] ju_av_writedata;
    wire        ju_av_waitrequest;
    wire        ju_av_irq;

    // Intel JTAG UART instance (from IP)
    jtag_uart_0 u_jtag_uart (
        .clk           (clk),
        .rst_n         (~rst),

        .av_address    (ju_av_address),
        .av_read_n     (ju_av_read_n),
        .av_readdata   (ju_av_readdata),
        .av_write_n    (ju_av_write_n),
        .av_writedata  (ju_av_writedata),
        .av_waitrequest(ju_av_waitrequest),
        .av_irq        (ju_av_irq)

        // plus any other ports the IP might have; tie off as needed
    );

    // Wishbone wrapper on s5
    jtag_uart_wb_wrapper u_jtag_wb (
        .clk        (clk),
        .rst        (rst),

        .wb_adr_i   (s5_adr_o),
        .wb_dat_i   (s5_dat_o),
        .wb_dat_o   (s5_dat_i),
        .wb_we_i    (s5_we_o),
        .wb_sel_i   (s5_sel_o),
        .wb_cyc_i   (s5_cyc_o),
        .wb_stb_i   (s5_stb_o),
        .wb_ack_o   (s5_ack_i),
        .wb_err_o   (s5_err_i),

        .av_address     (ju_av_address),
        .av_read_n      (ju_av_read_n),
        .av_readdata    (ju_av_readdata),
        .av_write_n     (ju_av_write_n),
        .av_writedata   (ju_av_writedata),
        .av_waitrequest (ju_av_waitrequest),
        .av_irq         (ju_av_irq)
    );

endmodule

(Ensure all previously defined s5_* signals from the WB fabric remain connected.)

================================================================================
STEP 4 — BOOT ROM JTAG UART TEST (PRINT VIA UART0 + JTAG-UART)
================================================================================

We now extend bootrom.c to include simple JTAG UART access:

- Base: 0x1000_0500
  - DATA:   +0x00
  - CONTROL:+0x04
- CONTROL bits:
  - [31:16] = RX data available count.
  - [15:0]  = TX space available.

We’ll:

- Add JTAG UART write/read routines.
- Print a banner on both UART0 and JTAG-UART.

----- UPDATED FILE: ~/hazard3_fw/bootrom/bootrom.c ----------------------------

#include <stdint.h>

#define UART0_BASE   0x10000000u
#define UART_RBR     (*(volatile uint32_t *)(UART0_BASE + 0x00))
#define UART_THR     (*(volatile uint32_t *)(UART0_BASE + 0x00))
#define UART_IER     (*(volatile uint32_t *)(UART0_BASE + 0x04))
#define UART_FCR     (*(volatile uint32_t *)(UART0_BASE + 0x08))
#define UART_LCR     (*(volatile uint32_t *)(UART0_BASE + 0x0C))
#define UART_MCR     (*(volatile uint32_t *)(UART0_BASE + 0x10))
#define UART_LSR     (*(volatile uint32_t *)(UART0_BASE + 0x14))

#define UART_LSR_DR   (1u << 0)
#define UART_LSR_THRE (1u << 5)

#define I2C0_BASE    0x10000100u
#define I2C_PRER_LO  (*(volatile uint32_t *)(I2C0_BASE + 0x00))
#define I2C_PRER_HI  (*(volatile uint32_t *)(I2C0_BASE + 0x04))
#define I2C_CTR      (*(volatile uint32_t *)(I2C0_BASE + 0x08))
#define I2C_TXR      (*(volatile uint32_t *)(I2C0_BASE + 0x0C))
#define I2C_RXR      (*(volatile uint32_t *)(I2C0_BASE + 0x0C))
#define I2C_CR       (*(volatile uint32_t *)(I2C0_BASE + 0x10))
#define I2C_SR       (*(volatile uint32_t *)(I2C0_BASE + 0x10))

#define I2C_CTR_EN   (1u << 7)
#define I2C_CR_STA   (1u << 7)
#define I2C_CR_STO   (1u << 6)
#define I2C_CR_RD    (1u << 5)
#define I2C_CR_WR    (1u << 4)
#define I2C_CR_ACK   (1u << 3)

#define I2C_SR_RXACK (1u << 7)
#define I2C_SR_TIP   (1u << 1)

#define SPI0_BASE      0x10000200u
#define SPI_RXTX       (*(volatile uint32_t *)(SPI0_BASE + 0x00))
#define SPI_STATUS     (*(volatile uint32_t *)(SPI0_BASE + 0x04))
#define SPI_CTRL       (*(volatile uint32_t *)(SPI0_BASE + 0x08))
#define SPI_DIVIDER    (*(volatile uint32_t *)(SPI0_BASE + 0x0C))
#define SPI_SS         (*(volatile uint32_t *)(SPI0_BASE + 0x10))

#define SPI_CTRL_GO     (1u << 0)
#define SPI_CTRL_RXNEG  (1u << 1)
#define SPI_CTRL_TXNEG  (1u << 2)
#define SPI_CTRL_LSBF   (1u << 3)
#define SPI_CTRL_IE     (1u << 4)
#define SPI_CTRL_ASS    (1u << 5)

#define GPIO_BASE      0x10000300u
#define GPIO_DATA_OUT  (*(volatile uint32_t *)(GPIO_BASE + 0x00))
#define GPIO_DATA_IN   (*(volatile uint32_t *)(GPIO_BASE + 0x04))
#define GPIO_DIR       (*(volatile uint32_t *)(GPIO_BASE + 0x08))
#define GPIO_PULLUP    (*(volatile uint32_t *)(GPIO_BASE + 0x0C))

#define JU_BASE        0x10000500u
#define JU_DATA        (*(volatile uint32_t *)(JU_BASE + 0x00))
#define JU_CTRL        (*(volatile uint32_t *)(JU_BASE + 0x04))

static void uart_init(uint32_t sys_clk_hz, uint32_t baud)
{
    uint32_t divisor = sys_clk_hz / (16u * baud);
    UART_LCR = 0x80u;
    UART_THR = (divisor & 0xFFu);
    UART_IER = ((divisor >> 8) & 0xFFu);
    UART_LCR = 0x03u;
    UART_FCR = 0x07u;
    UART_MCR = 0x08u;
}

static void uart_putc(char c)
{
    while (!(UART_LSR & UART_LSR_THRE)) { }
    UART_THR = (uint8_t)c;
}

static void uart_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') uart_putc('\r');
        uart_putc(*s++);
    }
}

static void uart_put_hex8(uint8_t v)
{
    const char hex[] = "0123456789ABCDEF";
    uart_putc(hex[(v >> 4) & 0xF]);
    uart_putc(hex[v & 0xF]);
}

static void i2c_init(uint32_t sys_clk_hz, uint32_t bus_khz)
{
    uint32_t freq = bus_khz * 1000u;
    uint32_t presc = (sys_clk_hz / (5u * freq)) - 1u;
    I2C_PRER_LO = (presc & 0xFFu);
    I2C_PRER_HI = ((presc >> 8) & 0xFFu);
    I2C_CTR     = I2C_CTR_EN;
}

static int i2c_write_byte(uint8_t addr7, uint8_t reg, uint8_t data)
{
    I2C_TXR = (uint32_t)((addr7 << 1) | 0u);
    I2C_CR  = I2C_CR_STA | I2C_CR_WR;
    while (I2C_SR & I2C_SR_TIP) { }
    if (I2C_SR & I2C_SR_RXACK) return -1;

    I2C_TXR = reg;
    I2C_CR  = I2C_CR_WR;
    while (I2C_SR & I2C_SR_TIP) { }
    if (I2C_SR & I2C_SR_RXACK) return -2;

    I2C_TXR = data;
    I2C_CR  = I2C_CR_WR | I2C_CR_STO;
    while (I2C_SR & I2C_SR_TIP) { }
    if (I2C_SR & I2C_SR_RXACK) return -3;

    return 0;
}

static void spi_init(uint32_t sys_clk_hz)
{
    uint32_t div = 4u;
    SPI_DIVIDER = div;
    uint32_t ctrl = 0;
    ctrl |= SPI_CTRL_ASS;
    SPI_CTRL = ctrl;
    SPI_SS   = 1u;
}

static uint8_t spi_transfer(uint8_t data)
{
    SPI_RXTX = data;
    SPI_CTRL = SPI_CTRL | SPI_CTRL_GO;
    while (SPI_CTRL & SPI_CTRL_GO) { }
    return (uint8_t)(SPI_RXTX & 0xFFu);
}

static void delay(volatile uint32_t cycles)
{
    while (cycles--) {
        __asm__ volatile("nop");
    }
}

// JTAG UART helpers
static int jtag_uart_tx_space(void)
{
    uint32_t ctrl = JU_CTRL;
    return (int)(ctrl & 0xFFFFu);
}

static int jtag_uart_rx_count(void)
{
    uint32_t ctrl = JU_CTRL;
    return (int)(ctrl >> 16);
}

static void jtag_uart_putc(char c)
{
    while (jtag_uart_tx_space() == 0) { }
    JU_DATA = (uint32_t)(uint8_t)c;
}

static void jtag_uart_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') jtag_uart_putc('\r');
        jtag_uart_putc(*s++);
    }
}

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;

    uart_init(SYS_CLK_HZ, 115200u);

    uart_puts("Hazard3 Phase 1H: JTAG-UART test\n");
    jtag_uart_puts("Hazard3 Phase 1H: JTAG-UART test\n");

    i2c_init(SYS_CLK_HZ, 100u);
    uart_puts("I2C initialized\n");
    jtag_uart_puts("I2C initialized\n");

    int rc = i2c_write_byte(0x68, 0x00, 0x55);
    if (rc == 0) {
        uart_puts("I2C write to 0x68 succeeded\n");
        jtag_uart_puts("I2C write to 0x68 succeeded\n");
    } else {
        uart_puts("I2C write to 0x68 failed\n");
        jtag_uart_puts("I2C write to 0x68 failed\n");
    }

    spi_init(SYS_CLK_HZ);
    uart_puts("SPI initialized\n");
    jtag_uart_puts("SPI initialized\n");

    uint8_t resp = spi_transfer(0x9F);
    uart_puts("SPI transfer 0x9F returned 0x");
    uart_put_hex8(resp);
    uart_putc('\n');

    jtag_uart_puts("SPI transfer 0x9F returned 0x");
    jtag_uart_putc("0123456789ABCDEF"[(resp >> 4) & 0xF]);
    jtag_uart_putc("0123456789ABCDEF"[resp & 0xF]);
    jtag_uart_putc('\n');

    // Optional: blink GPIO LED as before
    GPIO_DIR    |= (1u << 18);
    GPIO_PULLUP &= ~(1u << 18);

    for (int i = 0; i < 5; i++) {
        GPIO_DATA_OUT |= (1u << 18);
        delay(5000000u);
        GPIO_DATA_OUT &= ~(1u << 18);
        delay(5000000u);
    }

    uart_puts("Phase 1H test done\n");
    jtag_uart_puts("Phase 1H test done\n");

    while (1) {
        __asm__ volatile("wfi");
    }
}

Rebuild bootrom:

   cd ~/hazard3_fw/bootrom
   make

Place/refresh bootrom.hex as before.

================================================================================
STEP 5 — QUARTUS: ADD WRAPPER, KEEP IP, COMPILE, PROGRAM (SRAM-ONLY)
================================================================================

1. Ensure Intel JTAG UART IP is already generated and `.qip` added (Step 1).

2. Add wrapper RTL:
   - Project → Add/Remove Files:
     - ../rtl/soc/jtag_uart_wb_wrapper.sv
     - Updated ../rtl/soc/top_soc.sv

3. Boot ROM:
   - Ensure updated bootrom.hex is seen by boot_rom.sv.

4. Compile:
   - Processing → Start Compilation.

5. Program SRAM-only:
   - Quartus Programmer:
     - Hardware: USB-Blaster.
     - Mode: JTAG.
     - File: h3_phase1_sc.sof.
     - Check “Program/Configure” only.
     - START.
   - Do NOT generate/program .pof; do NOT program configuration flash.
   - Power-cycle → factory demo returns.

6. Run-time verification:
   - Connect UART0 via USB-serial (115200 8N1).
   - In a terminal, run:

     nios2-terminal

     (or the equivalent JTAG UART console depending on your Quartus version.)

   - Power on DE0-Lite → factory demo.
   - Program .sof → Hazard3 SoC overlays in SRAM.
   - Reset board.
   - You should see identical messages in:
     - Your UART0 terminal.
     - JTAG UART terminal (nios2-terminal).

================================================================================
WHAT PHASE 1H GIVES YOU TOWARD THE QUAD-CORE GOAL
================================================================================

- A complete, bus-consistent peripheral set behind AHB→WB:
  - SDRAM (s0), UART (s1), I2C (s2), SPI (s3), GPIO (s4), JTAG-UART (s5).
- Two independent debug I/O channels:
  - UART0 (physical).
  - JTAG-UART (over USB-Blaster, no extra wiring).
- Fully functional base SoC, still:
  - Quad-core-ready at the AHB level.
  - Ephemeral-only configuration (.sof in SRAM, factory demo on power-cycle).

Next steps (Phase 1I onward) are where it gets really interesting:

- 1I: Bootloader in ROM (dual-path: UART0 + JTAG-UART) that loads firmware into SDRAM.
- 1J: HAL (C) for all these peripherals.
- 1K: SDRAM-resident user firmware, then multi-core.
########END PHASE 1H########
================================================================================
PHASE 1I: BOOTLOADER IN ROM (UART0 + JTAG-UART → SDRAM @ 0x8000_0000)
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 1I
----------------
Transform the current ROM stub (Phase 1H) into a **real bootloader** that:

- Lives entirely in Boot ROM at 0x2000_0000.
- Uses **either**:
  - UART0 (0x1000_0000), or
  - JTAG-UART (0x1000_0500)
  as a host link.
- Receives a firmware image (raw binary) from the host.
- Writes it into SDRAM starting at 0x8000_0000.
- Jumps to 0x8000_0000 to execute the loaded firmware.

Still:
- FPGA config is **ephemeral**: only `.sof` via JTAG → SRAM.
- Power-cycle returns to factory demo image in flash.

We’ll define:

1. A simple “Hazard3 Boot Transfer” protocol (H3BT).
2. A new `bootrom.c` implementing:
   - Low-level UART0 + JTAG-UART I/O.
   - H3BT receive logic.
   - SDRAM check + memory write.
   - Jump to firmware entry.
3. A minimal host-side expectation (what you send over serial/JTAG-UART).
4. Keep all hardware unchanged from Phase 1H.

================================================================================
H3BT PROTOCOL (HOST ↔ BOOTLOADER)
================================================================================

We define a **very simple binary protocol**, little-endian, over UART0 or JTAG-UART.

All values are 32-bit, little-endian.

1. Host sends 4-byte magic:
   - "H3BT" = 0x48 0x33 0x42 0x54

2. Host sends 4-byte load address:
   - For now, always 0x80000000 (SDRAM base).
   - Bootloader checks that it is in SDRAM range.

3. Host sends 4-byte length:
   - Number of data bytes to follow.

4. Host sends 4-byte checksum:
   - Sum of all data bytes modulo 2^32 (simple additive checksum).

5. Host sends `length` data bytes:
   - Raw firmware image (e.g., your main program).

Bootloader behavior:

- Wait for magic.
- Read address, length, checksum.
- Receive data into SDRAM, computing sum in parallel.
- Compare checksums.
- If OK:
  - Print success on UART0 + JTAG-UART.
  - Jump to given address (assume RV32I code).
- If fail:
  - Print error, stay in bootloader loop.

================================================================================
STEP 1 — NEW BOOT ROM CODE: bootrom.c (BOOTLOADER)
================================================================================

We replace the old ROM test code with the new bootloader implementation.

Memory map (from previous phases):

- ROM:          0x2000_0000 (bootloader lives here; execute-only).
- SRAM/SDRAM:   0x8000_0000 (firmware load target).
- UART0:        0x1000_0000.
- I2C0:         0x1000_0100.
- SPI0:         0x1000_0200.
- GPIO:         0x1000_0300.
- JTAG-UART:    0x1000_0500.

----- UPDATED FILE: ~/hazard3_fw/bootrom/bootrom.c ----------------------------

#include <stdint.h>

#define UART0_BASE   0x10000000u
#define UART_RBR     (*(volatile uint32_t *)(UART0_BASE + 0x00))
#define UART_THR     (*(volatile uint32_t *)(UART0_BASE + 0x00))
#define UART_IER     (*(volatile uint32_t *)(UART0_BASE + 0x04))
#define UART_FCR     (*(volatile uint32_t *)(UART0_BASE + 0x08))
#define UART_LCR     (*(volatile uint32_t *)(UART0_BASE + 0x0C))
#define UART_MCR     (*(volatile uint32_t *)(UART0_BASE + 0x10))
#define UART_LSR     (*(volatile uint32_t *)(UART0_BASE + 0x14))

#define UART_LSR_DR   (1u << 0)
#define UART_LSR_THRE (1u << 5)

#define JU_BASE       0x10000500u
#define JU_DATA       (*(volatile uint32_t *)(JU_BASE + 0x00))
#define JU_CTRL       (*(volatile uint32_t *)(JU_BASE + 0x04))

#define SDRAM_BASE    0x80000000u

// H3BT protocol constants
#define H3BT_MAGIC_0  0x48u  // 'H'
#define H3BT_MAGIC_1  0x33u  // '3'
#define H3BT_MAGIC_2  0x42u  // 'B'
#define H3BT_MAGIC_3  0x54u  // 'T'

// UART0 helpers
static void uart_init(uint32_t sys_clk_hz, uint32_t baud)
{
    uint32_t divisor = sys_clk_hz / (16u * baud);
    UART_LCR = 0x80u;
    UART_THR = (divisor & 0xFFu);
    UART_IER = ((divisor >> 8) & 0xFFu);
    UART_LCR = 0x03u;
    UART_FCR = 0x07u;
    UART_MCR = 0x08u;
}

static void uart_putc(char c)
{
    while (!(UART_LSR & UART_LSR_THRE)) { }
    UART_THR = (uint8_t)c;
}

static int uart_getc_nonblock(char *out)
{
    if (UART_LSR & UART_LSR_DR) {
        *out = (char)(UART_RBR & 0xFFu);
        return 1;
    }
    return 0;
}

static char uart_getc_blocking(void)
{
    char c;
    while (!uart_getc_nonblock(&c)) { }
    return c;
}

static void uart_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') uart_putc('\r');
        uart_putc(*s++);
    }
}

// JTAG-UART helpers
static int ju_tx_space(void)
{
    uint32_t ctrl = JU_CTRL;
    return (int)(ctrl & 0xFFFFu);
}

static int ju_rx_count(void)
{
    uint32_t ctrl = JU_CTRL;
    return (int)(ctrl >> 16);
}

static void ju_putc(char c)
{
    while (ju_tx_space() == 0) { }
    JU_DATA = (uint32_t)(uint8_t)c;
}

static int ju_getc_nonblock(char *out)
{
    if (ju_rx_count() > 0) {
        uint32_t v = JU_DATA;
        *out = (char)(v & 0xFFu);
        return 1;
    }
    return 0;
}

static char ju_getc_blocking(void)
{
    char c;
    while (!ju_getc_nonblock(&c)) { }
    return c;
}

static void ju_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') ju_putc('\r');
        ju_putc(*s++);
    }
}

// Combined console abstraction: we allow host to choose UART0 or JTAG-UART.
typedef enum {
    CONSOLE_UART = 0,
    CONSOLE_JTAG = 1
} console_t;

static console_t active_console = CONSOLE_UART;

static void con_putc(char c)
{
    if (active_console == CONSOLE_UART) uart_putc(c);
    else                                ju_putc(c);
}

static char con_getc_blocking(void)
{
    if (active_console == CONSOLE_UART) return uart_getc_blocking();
    else                                return ju_getc_blocking();
}

static void con_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') con_putc('\r');
        con_putc(*s++);
    }
}

// Utility: read 32-bit little-endian from console
static uint32_t con_read_u32(void)
{
    uint32_t v = 0;
    for (int i = 0; i < 4; i++) {
        uint8_t b = (uint8_t)con_getc_blocking();
        v |= ((uint32_t)b) << (8u * i);
    }
    return v;
}

// Bootloader: receive firmware via active console using H3BT
static void bootloader_loop(void)
{
    for (;;) {
        con_puts("\n[H3BT] Waiting for magic H3BT...\n");

        // Detect magic sequence
        char m0 = con_getc_blocking();
        char m1 = con_getc_blocking();
        char m2 = con_getc_blocking();
        char m3 = con_getc_blocking();

        if ((uint8_t)m0 != H3BT_MAGIC_0 ||
            (uint8_t)m1 != H3BT_MAGIC_1 ||
            (uint8_t)m2 != H3BT_MAGIC_2 ||
            (uint8_t)m3 != H3BT_MAGIC_3) {
            con_puts("[H3BT] Invalid magic, ignoring.\n");
            continue;
        }

        con_puts("[H3BT] Magic OK.\n");

        uint32_t load_addr = con_read_u32();
        uint32_t length    = con_read_u32();
        uint32_t checksum  = con_read_u32();

        con_puts("[H3BT] Header: addr=0x");
        // small inline hex print, just 8 chars
        const char hex[] = "0123456789ABCDEF";
        for (int i = 7; i >= 0; i--) {
            con_putc(hex[(load_addr >> (4 * i)) & 0xF]);
        }
        con_puts(", len=0x");
        for (int i = 7; i >= 0; i--) {
            con_putc(hex[(length >> (4 * i)) & 0xF]);
        }
        con_puts("\n");

        // Basic sanity: must be in SDRAM and within some max
        if (load_addr < SDRAM_BASE) {
            con_puts("[H3BT] ERROR: load_addr below SDRAM base.\n");
            continue;
        }
        if (length == 0 || length > (16u * 1024u * 1024u)) {
            con_puts("[H3BT] ERROR: suspicious length.\n");
            continue;
        }

        con_puts("[H3BT] Receiving data...\n");

        uint8_t *dst = (uint8_t *)load_addr;
        uint32_t sum = 0;

        for (uint32_t i = 0; i < length; i++) {
            uint8_t b = (uint8_t)con_getc_blocking();
            dst[i] = b;
            sum += (uint32_t)b;
        }

        con_puts("[H3BT] Data received. Verifying checksum...\n");

        if (sum != checksum) {
            con_puts("[H3BT] ERROR: checksum mismatch.\n");
            continue;
        }

        con_puts("[H3BT] Checksum OK. Jumping to firmware.\n");

        // Jump to loaded code
        void (*entry)(void) = (void (*)(void))load_addr;
        entry();

        // If firmware returns, loop again.
        con_puts("[H3BT] WARNING: firmware returned, back to bootloader.\n");
    }
}

// Choose console: check if JTAG-UART is present / used by host.
//
// Simple heuristic: wait briefly; if JTAG-UART receives 'J' as the
// first char, use JTAG; otherwise default to UART.
static void select_console(void)
{
    active_console = CONSOLE_UART; // default

    // Small window to see if JTAG terminal sends a 'J' greeting, etc.
    for (volatile uint32_t i = 0; i < 2000000u; i++) {
        char c;
        if (ju_getc_nonblock(&c)) {
            // any char from JTAG → prefer JTAG
            active_console = CONSOLE_JTAG;
            break;
        }
    }
}

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;

    uart_init(SYS_CLK_HZ, 115200u);

    select_console();

    con_puts("\nHazard3 Phase 1I Bootloader (H3BT)\n");
    con_puts("Console: ");
    if (active_console == CONSOLE_UART)
        con_puts("UART0\n");
    else
        con_puts("JTAG-UART\n");

    con_puts("Protocol: magic 'H3BT', addr, len, checksum, data.\n");
    con_puts("Ready.\n");

    bootloader_loop();
}

================================================================================
STEP 2 — LINKER & MAKEFILE (UNCHANGED OR MINOR)
================================================================================

Your existing `linker.ld` for the ROM is already valid:

- ORIGIN = 0x20000000
- LENGTH = 16K
- Entry = _start

You can reuse it as-is. The Makefile from Phase 1A/1D is also valid.

Ensure it still looks roughly like:

----- FILE: ~/hazard3_fw/bootrom/linker.ld (for reference) ---------------------

ENTRY(_start)

MEMORY
{
  ROM (rx) : ORIGIN = 0x20000000, LENGTH = 16K
}

SECTIONS
{
  .text :
  {
    *(.text.entry)
    *(.text*)
    *(.rodata*)
  } > ROM

  .data :
  {
    *(.data*)
  } > ROM

  .bss :
  {
    *(.bss*)
    *(COMMON)
  } > ROM
}

----- FILE: ~/hazard3_fw/bootrom/Makefile (for reference) ----------------------

RISCV_PREFIX = riscv64-unknown-elf-
CC      = $(RISCV_PREFIX)gcc
OBJCOPY = $(RISCV_PREFIX)objcopy

CFLAGS  = -march=rv32imc -mabi=ilp32 -Os -nostdlib -ffreestanding -Wall -Wextra
LDFLAGS = -T linker.ld -nostartfiles -nostdlib

all: bootrom.hex

bootrom.elf: bootrom.c linker.ld
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ bootrom.c

bootrom.hex: bootrom.elf
	$(OBJCOPY) -O verilog $< $@

clean:
	rm -f bootrom.elf bootrom.hex

Rebuild ROM:

   cd ~/hazard3_fw/bootrom
   make

Copy/make sure `bootrom.hex` is in the path referenced by `boot_rom.sv`.

================================================================================
STEP 3 — HARDWARE (RTL) CHANGES
================================================================================

None required beyond what you already have up to Phase 1H.

- Hazard3 tile, AHB interconnect, Boot ROM, SDRAM, UART0, I2C, SPI, GPIO,
  JTAG-UART are already integrated.
- `boot_rom.sv` still reads `bootrom.hex` and serves AHB reads from ROM.

You only need to:

- Ensure `boot_rom.sv` points to the updated `bootrom.hex`.
- Recompile the Quartus project.

================================================================================
STEP 4 — QUARTUS: BUILD & PROGRAM (SRAM-ONLY)
================================================================================

1. Ensure RTL / IP unchanged from Phase 1H.
2. Update ROM contents:
   - Make sure the new `bootrom.hex` is in the correct directory.
3. Compile:
   - Processing → Start Compilation.
4. Program:
   - Quartus Programmer:
     - Hardware: USB-Blaster.
     - Mode: JTAG.
     - File: h3_phase1_sc.sof.
     - Check only “Program/Configure”.
     - START.
   - Never generate/program `.pof`. Flash remains untouched.
   - Power-cycle → factory demo returns.

================================================================================
STEP 5 — HOST-SIDE: USING H3BT TO LOAD FIRMWARE
================================================================================

You now have a ROM-resident bootloader. To load firmware:

1. Build your firmware ELF for SDRAM start (e.g., `0x80000000`):
   - Separate project with its own linker script mapping `.text` to 0x80000000.

2. Convert firmware to a raw binary:
   - `riscv64-unknown-elf-objcopy -O binary firmware.elf firmware.bin`

3. Compute checksum:
   - Sum of all bytes modulo 2^32.

4. Send H3BT stream over chosen console:

   For UART0:
   - Open serial at 115200 8N1.
   - Send:
     - "H3BT"
     - 4 bytes: 0x00 0x00 0x00 0x80 (0x80000000 LE)
     - 4 bytes: `<length in bytes, LE>`
     - 4 bytes: `<checksum, LE>`
     - `length` bytes of firmware.bin

   For JTAG-UART:
   - Use a small helper program using `nios2-terminal` pipe or a custom JTAG-UART host if available.
   - The byte stream is identical.

5. Bootloader:
   - Receives magic + header.
   - Loads firmware into SDRAM.
   - Jumps to 0x80000000.
   - Your firmware now runs on the same SoC.

================================================================================
WHAT PHASE 1I GIVES YOU TOWARD THE QUAD-CORE GOAL
================================================================================

- A real, ROM-resident bootloader:
  - No more fixed demo code; you can load arbitrary firmware into SDRAM.
  - Dual-path input: UART0 or JTAG-UART, chosen automatically.
- Clean separation:
  - ROM = stable bootloader.
  - SDRAM = loadable, replaceable firmware.
- Fully compatible with:
  - Later HAL (Phase 1J) and user firmware (Phase 1K).
  - Future multi-core: other harts can be started by firmware after boot.

#######END PHASE1I########
================================================================================
PHASE 1J: C HAL FOR UART0, JTAG-UART, I2C, SPI, GPIO (FOR SDRAM FIRMWARE)
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 1J
----------------
Build a **Hardware Abstraction Layer (HAL)** so SDRAM-resident firmware can:

- Use UART0, JTAG-UART, I2C, SPI, GPIO through clean C APIs.
- Ignore raw register addresses and bit twiddling in application code.
- Rely on a single header and one C file for all low-level peripherals.
- Integrate cleanly with your Phase 1I bootloader (H3BT → SDRAM @ 0x8000_0000).

We will:

1. Define the memory map constants consistently with all previous phases.
2. Create:
   - `h3_soc.h`  — SoC-wide definitions + HAL API.
   - `h3_soc.c`  — HAL implementation.
3. Sketch a minimal SDRAM firmware `main.c` that uses the HAL (for Phase 1K).

Nothing here touches FPGA flash:
- You still only load `.sof` into SRAM.
- Bootloader is in ROM, firmware is in SDRAM.
- Power-cycle → factory demo.

================================================================================
DIRECTORY STRUCTURE FOR HAL + FIRMWARE
================================================================================

Keep bootloader separate. For SDRAM firmware (Phase 1K), use:

  ~/hazard3_fw/app/
    - h3_soc.h      (NEW — HAL header)
    - h3_soc.c      (NEW — HAL implementation)
    - main.c        (Phase 1K will flesh this out)
    - linker_app.ld (for SDRAM @ 0x80000000, later)
    - Makefile      (for firmware, later)

Phase 1J focuses just on:

- `h3_soc.h`
- `h3_soc.c`

================================================================================
STEP 1 — HAL HEADER: h3_soc.h
================================================================================

Defines:

- Memory map constants.
- Peripheral register structures.
- HAL function prototypes.
- Simple error codes and types.

----- FILE: ~/hazard3_fw/app/h3_soc.h -----------------------------------------

#ifndef H3_SOC_H
#define H3_SOC_H

#include <stdint.h>

/* ============================================================================
 * Memory map
 * ============================================================================
 */
#define H3_SDRAM_BASE       0x80000000u

#define H3_UART0_BASE       0x10000000u
#define H3_I2C0_BASE        0x10000100u
#define H3_SPI0_BASE        0x10000200u
#define H3_GPIO_BASE        0x10000300u
#define H3_JTAG_UART_BASE   0x10000500u

/* ============================================================================
 * UART0 (16550) register layout (32-bit accesses, low 8 bits used)
 * ============================================================================
 */
typedef struct {
    volatile uint32_t RBR_THR_DLL;   // 0x00: RBR (RO), THR (WO), DLL (DLAB=1)
    volatile uint32_t IER_DLM;       // 0x04: IER / DLM (DLAB=1)
    volatile uint32_t IIR_FCR;       // 0x08: IIR (RO) / FCR (WO)
    volatile uint32_t LCR;           // 0x0C
    volatile uint32_t MCR;           // 0x10
    volatile uint32_t LSR;           // 0x14
    volatile uint32_t MSR;           // 0x18
    volatile uint32_t SCR;           // 0x1C
} h3_uart_t;

#define H3_UART0   ((h3_uart_t *)H3_UART0_BASE)

#define H3_UART_LSR_DR    (1u << 0)
#define H3_UART_LSR_THRE  (1u << 5)
#define H3_UART_LCR_DLAB  (1u << 7)

/* ============================================================================
 * I2C master (OpenCores) register layout
 * Base + 0x00: PRERlo
 * Base + 0x04: PRERhi
 * Base + 0x08: CTR
 * Base + 0x0C: TXR/RXR
 * Base + 0x10: CR/SR
 * ============================================================================
 */
typedef struct {
    volatile uint32_t PRER_LO;   // 0x00
    volatile uint32_t PRER_HI;   // 0x04
    volatile uint32_t CTR;       // 0x08
    volatile uint32_t TXR_RXR;   // 0x0C
    volatile uint32_t CR_SR;     // 0x10
} h3_i2c_t;

#define H3_I2C0   ((h3_i2c_t *)H3_I2C0_BASE)

#define H3_I2C_CTR_EN    (1u << 7)
#define H3_I2C_CR_STA    (1u << 7)
#define H3_I2C_CR_STO    (1u << 6)
#define H3_I2C_CR_RD     (1u << 5)
#define H3_I2C_CR_WR     (1u << 4)
#define H3_I2C_CR_ACK    (1u << 3)

#define H3_I2C_SR_RXACK  (1u << 7)
#define H3_I2C_SR_TIP    (1u << 1)

/* ============================================================================
 * SPI master (OpenCores-like) register layout
 * Base + 0x00: RX/TX
 * Base + 0x04: STATUS
 * Base + 0x08: CTRL
 * Base + 0x0C: DIVIDER
 * Base + 0x10: SS
 * ============================================================================
 */
typedef struct {
    volatile uint32_t RXTX;      // 0x00
    volatile uint32_t STATUS;    // 0x04
    volatile uint32_t CTRL;      // 0x08
    volatile uint32_t DIVIDER;   // 0x0C
    volatile uint32_t SS;        // 0x10
} h3_spi_t;

#define H3_SPI0   ((h3_spi_t *)H3_SPI0_BASE)

/* Bits used (adjust to actual core if needed) */
#define H3_SPI_CTRL_GO     (1u << 0)
#define H3_SPI_CTRL_RXNEG  (1u << 1)
#define H3_SPI_CTRL_TXNEG  (1u << 2)
#define H3_SPI_CTRL_LSBF   (1u << 3)
#define H3_SPI_CTRL_IE     (1u << 4)
#define H3_SPI_CTRL_ASS    (1u << 5)

/* ============================================================================
 * GPIO register layout (our custom WB GPIO)
 * Base + 0x00: DATA_OUT
 * Base + 0x04: DATA_IN
 * Base + 0x08: DIR
 * Base + 0x0C: PULLUP
 * ============================================================================
 */
typedef struct {
    volatile uint32_t DATA_OUT;  // 0x00
    volatile uint32_t DATA_IN;   // 0x04
    volatile uint32_t DIR;       // 0x08
    volatile uint32_t PULLUP;    // 0x0C
} h3_gpio_t;

#define H3_GPIO   ((h3_gpio_t *)H3_GPIO_BASE)

/* ============================================================================
 * JTAG UART register layout
 * Base + 0x00: DATA
 * Base + 0x04: CTRL
 * CTRL: upper 16 bits = RX count, lower 16 bits = TX space
 * ============================================================================
 */
typedef struct {
    volatile uint32_t DATA;      // 0x00
    volatile uint32_t CTRL;      // 0x04
} h3_jtag_uart_t;

#define H3_JU    ((h3_jtag_uart_t *)H3_JTAG_UART_BASE)

/* ============================================================================
 * HAL types & error codes
 * ============================================================================
 */
typedef enum {
    H3_CONSOLE_UART = 0,
    H3_CONSOLE_JTAG = 1
} h3_console_t;

typedef enum {
    H3_OK            = 0,
    H3_ERR_I2C_NACK  = -1,
    H3_ERR_I2C_RANGE = -2,
    H3_ERR_SPI       = -3
} h3_status_t;

/* ============================================================================
 * HAL API
 * ============================================================================
 */

/* UART0 */
void        h3_uart_init(uint32_t sys_clk_hz, uint32_t baud);
void        h3_uart_putc(char c);
char        h3_uart_getc_blocking(void);
int         h3_uart_getc_nonblock(char *out);
void        h3_uart_puts(const char *s);
void        h3_uart_put_hex8(uint8_t v);
void        h3_uart_put_hex32(uint32_t v);

/* JTAG UART */
int         h3_ju_tx_space(void);
int         h3_ju_rx_count(void);
void        h3_ju_putc(char c);
int         h3_ju_getc_nonblock(char *out);
char        h3_ju_getc_blocking(void);
void        h3_ju_puts(const char *s);

/* Combined console */
void        h3_console_select(h3_console_t which);
h3_console_t h3_console_get(void);
void        h3_con_putc(char c);
char        h3_con_getc_blocking(void);
int         h3_con_getc_nonblock(char *out);
void        h3_con_puts(const char *s);

/* I2C */
h3_status_t h3_i2c_init(uint32_t sys_clk_hz, uint32_t bus_khz);
h3_status_t h3_i2c_write_byte(uint8_t addr7, uint8_t reg, uint8_t data);
h3_status_t h3_i2c_read_byte(uint8_t addr7, uint8_t reg, uint8_t *data_out);

/* SPI */
void        h3_spi_init(uint32_t sys_clk_hz, uint32_t clk_div);
uint8_t     h3_spi_transfer(uint8_t data);

/* GPIO */
void        h3_gpio_set_dir(uint32_t mask, uint32_t value);
void        h3_gpio_write(uint32_t mask, uint32_t value);
uint32_t    h3_gpio_read(void);

/* Utility */
void        h3_delay_cycles(volatile uint32_t cycles);

#endif /* H3_SOC_H */

================================================================================
STEP 2 — HAL IMPLEMENTATION: h3_soc.c
================================================================================

Implements all declared functions. This is the single low-level place where
you touch registers.

----- FILE: ~/hazard3_fw/app/h3_soc.c -----------------------------------------

#include "h3_soc.h"

/* ============================================================================
 * UART0
 * ============================================================================
 */

void h3_uart_init(uint32_t sys_clk_hz, uint32_t baud)
{
    uint32_t divisor = sys_clk_hz / (16u * baud);

    /* Enable DLAB to write DLL/DLM */
    H3_UART0->LCR = H3_UART_LCR_DLAB;
    H3_UART0->RBR_THR_DLL = (divisor & 0xFFu);           /* DLL */
    H3_UART0->IER_DLM      = ((divisor >> 8) & 0xFFu);   /* DLM */

    /* 8N1, DLAB=0 */
    H3_UART0->LCR = 0x03u;

    /* Enable FIFO, clear RX/TX */
    H3_UART0->IIR_FCR = 0x07u;

    /* Modem Control: OUT2 set (often enables interrupts), but we don't use IRQ yet */
    H3_UART0->MCR = 0x08u;
}

void h3_uart_putc(char c)
{
    while (!(H3_UART0->LSR & H3_UART_LSR_THRE)) { }
    H3_UART0->RBR_THR_DLL = (uint8_t)c;
}

char h3_uart_getc_blocking(void)
{
    while (!(H3_UART0->LSR & H3_UART_LSR_DR)) { }
    return (char)(H3_UART0->RBR_THR_DLL & 0xFFu);
}

int h3_uart_getc_nonblock(char *out)
{
    if (H3_UART0->LSR & H3_UART_LSR_DR) {
        *out = (char)(H3_UART0->RBR_THR_DLL & 0xFFu);
        return 1;
    }
    return 0;
}

void h3_uart_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') h3_uart_putc('\r');
        h3_uart_putc(*s++);
    }
}

void h3_uart_put_hex8(uint8_t v)
{
    static const char hex[] = "0123456789ABCDEF";
    h3_uart_putc(hex[(v >> 4) & 0xF]);
    h3_uart_putc(hex[v & 0xF]);
}

void h3_uart_put_hex32(uint32_t v)
{
    for (int i = 7; i >= 0; i--) {
        h3_uart_putc("0123456789ABCDEF"[(v >> (4 * i)) & 0xF]);
    }
}

/* ============================================================================
 * JTAG UART
 * ============================================================================
 */

int h3_ju_tx_space(void)
{
    uint32_t ctrl = H3_JU->CTRL;
    return (int)(ctrl & 0xFFFFu);
}

int h3_ju_rx_count(void)
{
    uint32_t ctrl = H3_JU->CTRL;
    return (int)(ctrl >> 16);
}

void h3_ju_putc(char c)
{
    while (h3_ju_tx_space() == 0) { }
    H3_JU->DATA = (uint32_t)(uint8_t)c;
}

int h3_ju_getc_nonblock(char *out)
{
    if (h3_ju_rx_count() > 0) {
        uint32_t v = H3_JU->DATA;
        *out = (char)(v & 0xFFu);
        return 1;
    }
    return 0;
}

char h3_ju_getc_blocking(void)
{
    char c;
    while (!h3_ju_getc_nonblock(&c)) { }
    return c;
}

void h3_ju_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') h3_ju_putc('\r');
        h3_ju_putc(*s++);
    }
}

/* ============================================================================
 * Combined console
 * ============================================================================
 */

static h3_console_t g_console = H3_CONSOLE_UART;

void h3_console_select(h3_console_t which)
{
    g_console = which;
}

h3_console_t h3_console_get(void)
{
    return g_console;
}

void h3_con_putc(char c)
{
    if (g_console == H3_CONSOLE_UART) {
        h3_uart_putc(c);
    } else {
        h3_ju_putc(c);
    }
}

char h3_con_getc_blocking(void)
{
    if (g_console == H3_CONSOLE_UART) {
        return h3_uart_getc_blocking();
    } else {
        return h3_ju_getc_blocking();
    }
}

int h3_con_getc_nonblock(char *out)
{
    if (g_console == H3_CONSOLE_UART) {
        return h3_uart_getc_nonblock(out);
    } else {
        return h3_ju_getc_nonblock(out);
    }
}

void h3_con_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') h3_con_putc('\r');
        h3_con_putc(*s++);
    }
}

/* ============================================================================
 * I2C
 * ============================================================================
 */

h3_status_t h3_i2c_init(uint32_t sys_clk_hz, uint32_t bus_khz)
{
    uint32_t freq = bus_khz * 1000u;
    if (freq == 0u) return H3_ERR_I2C_RANGE;

    uint32_t presc = (sys_clk_hz / (5u * freq)) - 1u;
    H3_I2C0->PRER_LO = (presc & 0xFFu);
    H3_I2C0->PRER_HI = ((presc >> 8) & 0xFFu);
    H3_I2C0->CTR     = H3_I2C_CTR_EN;

    return H3_OK;
}

static h3_status_t h3_i2c_wait_tip_clear(void)
{
    while (H3_I2C0->CR_SR & H3_I2C_SR_TIP) { }
    return H3_OK;
}

h3_status_t h3_i2c_write_byte(uint8_t addr7, uint8_t reg, uint8_t data)
{
    /* Address (write) */
    H3_I2C0->TXR_RXR = (uint32_t)((addr7 << 1) | 0u);
    H3_I2C0->CR_SR   = H3_I2C_CR_STA | H3_I2C_CR_WR;
    h3_i2c_wait_tip_clear();
    if (H3_I2C0->CR_SR & H3_I2C_SR_RXACK) return H3_ERR_I2C_NACK;

    /* Register index */
    H3_I2C0->TXR_RXR = reg;
    H3_I2C0->CR_SR   = H3_I2C_CR_WR;
    h3_i2c_wait_tip_clear();
    if (H3_I2C0->CR_SR & H3_I2C_SR_RXACK) return H3_ERR_I2C_NACK;

    /* Data + STOP */
    H3_I2C0->TXR_RXR = data;
    H3_I2C0->CR_SR   = H3_I2C_CR_WR | H3_I2C_CR_STO;
    h3_i2c_wait_tip_clear();
    if (H3_I2C0->CR_SR & H3_I2C_SR_RXACK) return H3_ERR_I2C_NACK;

    return H3_OK;
}

h3_status_t h3_i2c_read_byte(uint8_t addr7, uint8_t reg, uint8_t *data_out)
{
    if (!data_out) return H3_ERR_I2C_RANGE;

    /* Address (write) */
    H3_I2C0->TXR_RXR = (uint32_t)((addr7 << 1) | 0u);
    H3_I2C0->CR_SR   = H3_I2C_CR_STA | H3_I2C_CR_WR;
    h3_i2c_wait_tip_clear();
    if (H3_I2C0->CR_SR & H3_I2C_SR_RXACK) return H3_ERR_I2C_NACK;

    /* Register index */
    H3_I2C0->TXR_RXR = reg;
    H3_I2C0->CR_SR   = H3_I2C_CR_WR;
    h3_i2c_wait_tip_clear();
    if (H3_I2C0->CR_SR & H3_I2C_SR_RXACK) return H3_ERR_I2C_NACK;

    /* Repeated START + address (read) */
    H3_I2C0->TXR_RXR = (uint32_t)((addr7 << 1) | 1u);
    H3_I2C0->CR_SR   = H3_I2C_CR_STA | H3_I2C_CR_WR;
    h3_i2c_wait_tip_clear();
    if (H3_I2C0->CR_SR & H3_I2C_SR_RXACK) return H3_ERR_I2C_NACK;

    /* Read data with NACK + STOP */
    H3_I2C0->CR_SR = H3_I2C_CR_RD | H3_I2C_CR_ACK | H3_I2C_CR_STO;
    h3_i2c_wait_tip_clear();

    *data_out = (uint8_t)(H3_I2C0->TXR_RXR & 0xFFu);
    return H3_OK;
}

/* ============================================================================
 * SPI
 * ============================================================================
 */

void h3_spi_init(uint32_t sys_clk_hz, uint32_t clk_div)
{
    (void)sys_clk_hz; /* Not strictly needed if clk_div is given directly. */

    H3_SPI0->DIVIDER = clk_div;

    uint32_t ctrl = 0;
    ctrl |= H3_SPI_CTRL_ASS;  /* auto slave select */
    /* Mode 0: CPOL=0, CPHA=0, so RXNEG=0, TXNEG=0 by default */
    H3_SPI0->CTRL = ctrl;

    /* Select SS0 (bit0) */
    H3_SPI0->SS = 1u;
}

uint8_t h3_spi_transfer(uint8_t data)
{
    H3_SPI0->RXTX = data;
    H3_SPI0->CTRL = H3_SPI0->CTRL | H3_SPI_CTRL_GO;

    while (H3_SPI0->CTRL & H3_SPI_CTRL_GO) { }

    return (uint8_t)(H3_SPI0->RXTX & 0xFFu);
}

/* ============================================================================
 * GPIO
 * ============================================================================
 */

void h3_gpio_set_dir(uint32_t mask, uint32_t value)
{
    uint32_t d = H3_GPIO->DIR;
    d &= ~mask;
    d |= (value & mask);
    H3_GPIO->DIR = d;
}

void h3_gpio_write(uint32_t mask, uint32_t value)
{
    uint32_t d = H3_GPIO->DATA_OUT;
    d &= ~mask;
    d |= (value & mask);
    H3_GPIO->DATA_OUT = d;
}

uint32_t h3_gpio_read(void)
{
    return H3_GPIO->DATA_IN;
}

/* ============================================================================
 * Utility
 * ============================================================================
 */

void h3_delay_cycles(volatile uint32_t cycles)
{
    while (cycles--) {
        __asm__ volatile("nop");
    }
}

================================================================================
STEP 3 — HOW THIS CONNECTS TO THE BOOTLOADER & PHASE 1K
================================================================================

At this point:

- Bootloader (Phase 1I) is in ROM @ 0x2000_0000, written separately.
- HAL (Phase 1J) is just a library for SDRAM-resident firmware.
- Next (Phase 1K), you will:
  - Create an SDRAM firmware project using `h3_soc.h` / `h3_soc.c`.
  - Link it to run at 0x80000000.
  - Use the H3BT protocol via bootloader to load that firmware and run it.

You do NOT need to touch Quartus RTL for Phase 1J.
Just compile the HAL into your future application ELF.

================================================================================
STEP 4 — QUICK MENTAL TEST OF THE HAL
================================================================================

Once you have a `main.c` (Phase 1K), you’ll be able to do things like:

- `h3_uart_init(50000000u, 115200u);`
- `h3_uart_puts("Hello from SDRAM firmware\n");`
- `h3_i2c_init(50000000u, 100u);`
- `h3_i2c_write_byte(0x68, 0x00, 0x55);`
- `h3_spi_init(50000000u, 4u);`
- `h3_spi_transfer(0x9Fu);`
- `h3_gpio_set_dir(1u << 18, 1u << 18);`
- `h3_gpio_write(1u << 18, 1u << 18);`

All without touching any raw addresses in the application.

================================================================================
WHAT PHASE 1J GIVES YOU TOWARD THE QUAD-CORE GOAL
================================================================================

- A clean, reusable HAL that abstracts:
  - UART0
  - JTAG-UART
  - I2C0
  - SPI0
  - GPIO
- A consistent memory map and register model for all future firmware.
- A sharp separation of responsibilities:
  - ROM bootloader (Phase 1I) → H3BT + SDRAM load.
  - HAL (Phase 1J) → peripheral access.
  - SDRAM firmware (Phase 1K) → your actual applications.

########END PHASE 1J ########

================================================================================
PHASE 1K: SDRAM-RESIDENT FIRMWARE TEMPLATE USING HAL + H3BT BOOTLOADER
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 1K
----------------
Build a **first real firmware** that:

- Lives in **SDRAM @ 0x80000000**, not ROM.
- Uses the Phase 1J HAL: UART0, JTAG-UART, I2C, SPI, GPIO.
- Is loaded by the Phase 1I bootloader via H3BT (UART0 or JTAG-UART).
- Demonstrates:
  - Console output.
  - I2C write.
  - SPI transfer.
  - GPIO LED blink.

We will create:

- `linker_app.ld` — firmware linker script (ROM=bootloader, THIS=fetched into SDRAM).
- `Makefile`      — build firmware.elf and firmware.bin.
- `main.c`        — example SDRAM firmware using `h3_soc.h` / `h3_soc.c`.

No hardware / Quartus changes. FPGA is still:

- Configured via `.sof` into **SRAM only**.
- Boot ROM is bootloader.
- Power-cycle → DE0-Lite factory demo.

================================================================================
DIRECTORY STRUCTURE FOR APP FIRMWARE
================================================================================

Use:

  ~/hazard3_fw/app/
    - h3_soc.h      (from Phase 1J)
    - h3_soc.c      (from Phase 1J)
    - linker_app.ld (NEW)
    - main.c        (NEW)
    - Makefile      (NEW)

Bootloader stays in:

  ~/hazard3_fw/bootrom/

================================================================================
STEP 1 — LINKER SCRIPT FOR SDRAM FIRMWARE: linker_app.ld
================================================================================

Place firmware `.text` at 0x80000000 so the bootloader can jump there.

----- FILE: ~/hazard3_fw/app/linker_app.ld ------------------------------------

ENTRY(_start)

MEMORY
{
  SDRAM (rwx) : ORIGIN = 0x80000000, LENGTH = 64M
}

SECTIONS
{
  .text :
  {
    _start = .;
    *(.text.entry)
    *(.text*)
    *(.rodata*)
  } > SDRAM

  .data :
  {
    *(.data*)
  } > SDRAM

  .bss :
  {
    _bss_start = .;
    *(.bss*)
    *(COMMON)
    _bss_end = .;
  } > SDRAM
}

================================================================================
STEP 2 — MAKEFILE FOR SDRAM FIRMWARE: Makefile
================================================================================

Builds:

- `firmware.elf` — linked at 0x80000000.
- `firmware.bin` — raw binary for H3BT.
- Also prints checksum for convenience.

----- FILE: ~/hazard3_fw/app/Makefile -----------------------------------------

RISCV_PREFIX = riscv64-unknown-elf-
CC      = $(RISCV_PREFIX)gcc
OBJCOPY = $(RISCV_PREFIX)objcopy
OBJDUMP = $(RISCV_PREFIX)objdump

CFLAGS  = -march=rv32imc -mabi=ilp32 -Os -nostdlib -ffreestanding -Wall -Wextra
LDFLAGS = -T linker_app.ld -nostartfiles -nostdlib

SRCS = main.c h3_soc.c

all: firmware.bin checksum

firmware.elf: $(SRCS) linker_app.ld h3_soc.h
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(SRCS)

firmware.bin: firmware.elf
	$(OBJCOPY) -O binary $< $@

disasm: firmware.elf
	$(OBJDUMP) -d $< > firmware.disasm

checksum: firmware.bin
	@python3 - << 'EOF'
import sys
data = open("firmware.bin","rb").read()
cs = sum(data) & 0xFFFFFFFF
print(f"Length: {len(data)} bytes")
print(f"Checksum: 0x{cs:08X}")
EOF

clean:
	rm -f firmware.elf firmware.bin firmware.disasm

================================================================================
STEP 3 — SDRAM FIRMWARE MAIN: main.c
================================================================================

Demonstrates:

- Use HAL to select console (default UART, with optional JTAG).
- Print boot banner.
- Initialize I2C and SPI.
- Talk to an I2C device (0x68).
- Send one SPI command (0x9F).
- Blink GPIO LED (bit 18).

----- FILE: ~/hazard3_fw/app/main.c -------------------------------------------

#include "h3_soc.h"

static void select_console_startup(void)
{
    /* Default to UART; if JTAG-UART has data early, switch to JTAG. */
    h3_console_select(H3_CONSOLE_UART);

    for (volatile uint32_t i = 0; i < 2000000u; i++) {
        char c;
        if (h3_ju_getc_nonblock(&c)) {
            (void)c;
            h3_console_select(H3_CONSOLE_JTAG);
            break;
        }
    }
}

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;

    /* Initialize UART0 for possible console use */
    h3_uart_init(SYS_CLK_HZ, 115200u);

    /* Decide console (UART0 vs JTAG-UART) */
    select_console_startup();

    h3_con_puts("\nHazard3 SDRAM Firmware (Phase 1K)\n");
    h3_con_puts("Console selected: ");
    if (h3_console_get() == H3_CONSOLE_UART)
        h3_con_puts("UART0\n");
    else
        h3_con_puts("JTAG-UART\n");

    /* I2C init */
    if (h3_i2c_init(SYS_CLK_HZ, 100u) != H3_OK) {
        h3_con_puts("I2C init failed\n");
    } else {
        h3_con_puts("I2C init OK (100 kHz)\n");
    }

    /* Try I2C write to device 0x68 */
    h3_status_t r = h3_i2c_write_byte(0x68, 0x00, 0x55);
    if (r == H3_OK) {
        h3_con_puts("I2C write to 0x68 OK\n");
    } else {
        h3_con_puts("I2C write to 0x68 failed\n");
    }

    /* SPI init (divider=4 → ~SYS_CLK/8 depending on core) */
    h3_spi_init(SYS_CLK_HZ, 4u);
    h3_con_puts("SPI init OK\n");

    /* SPI transfer 0x9F */
    uint8_t spi_resp = h3_spi_transfer(0x9F);
    h3_con_puts("SPI 0x9F -> 0x");
    h3_uart_put_hex8(spi_resp); /* use UART hex helper; console is still consistent */
    h3_con_puts("\n");

    /* GPIO: configure bit 18 as output (LED) */
    uint32_t led_mask = (1u << 18);
    h3_gpio_set_dir(led_mask, led_mask);

    h3_con_puts("Blinking LED on GPIO bit 18...\n");

    for (int i = 0; i < 10; i++) {
        h3_con_puts("LED ON\n");
        h3_gpio_write(led_mask, led_mask);
        h3_delay_cycles(5000000u);

        h3_con_puts("LED OFF\n");
        h3_gpio_write(led_mask, 0u);
        h3_delay_cycles(5000000u);
    }

    h3_con_puts("Done. Looping.\n");

    while (1) {
        __asm__ volatile("wfi");
    }
}

================================================================================
STEP 4 — BUILDING THE SDRAM FIRMWARE
================================================================================

1. Ensure `h3_soc.h` and `h3_soc.c` from Phase 1J are present in:
   ~/hazard3_fw/app/

2. Create the three files above:
   - linker_app.ld
   - Makefile
   - main.c

3. Build:

   cd ~/hazard3_fw/app
   make

   You get:
   - firmware.elf
   - firmware.bin
   - Length + checksum (printed by `make checksum`).

Note:
- Only the *firmware* uses this linker/app setup.
- The bootloader in ROM stays as Phase 1I (different directory, different Makefile).

================================================================================
STEP 5 — USING H3BT BOOTLOADER TO LOAD FIRMWARE INTO SDRAM
================================================================================

Protocol (Phase 1I):

1. Bootloader waits for magic "H3BT":
   - bytes: 0x48 0x33 0x42 0x54

2. Then:
   - 4 bytes: load address (LE) → use 0x80000000 = 00 00 00 80
   - 4 bytes: length in bytes (LE) → length of firmware.bin
   - 4 bytes: checksum (LE) → sum of firmware.bin bytes (mod 2^32)
   - Then: firmware.bin payload

The bootloader:

- Receives all bytes.
- Writes them to SDRAM at load address.
- Verifies checksum.
- Jumps to 0x80000000.

### UART0 path (simplest)

1. Connect UART0 to USB-serial (115200 8N1).
2. On host:

   - Note `Length` and `Checksum` printed by `make checksum`.

3. Use a small Python helper, e.g.:

   (You can sketch this later; conceptually it writes exactly the H3BT stream.)

4. Reset board (bootloader runs), then send the H3BT stream over the UART.

### JTAG-UART path

- Same byte protocol, but sent via JTAG-UART instead of UART0.
- Bootloader will likely auto-select JTAG if you type or send something early.

================================================================================
STEP 6 — RUN SEQUENCE (END-TO-END)
================================================================================

1. **FPGA config (once per power cycle):**
   - Program `h3_phase1_sc.sof` via JTAG into SRAM:
     - Quartus Programmer → JTAG → .sof → Program/Configure.
   - Do NOT touch flash. On next power-cycle, board = factory demo.

2. **Bootloader in ROM (Phase 1I) starts on reset.**
   - It prints its banner on whichever console it selects.

3. **Host sends H3BT stream (UART or JTAG-UART).**
   - Using `firmware.bin`, length, checksum.

4. **Bootloader loads to SDRAM & jumps to 0x80000000.**
   - Your `main.c` now runs.
   - You see:

     - “Hazard3 SDRAM Firmware (Phase 1K)”
     - I2C/SPI status.
     - LED blink logs.

5. **Power-cycle behavior:**
   - FPGA loses `.sof` → reloads factory demo from flash (as required).
   - No permanent state; everything was ephemeral in SRAM and SDRAM.

================================================================================
WHAT PHASE 1K GIVES YOU TOWARD THE QUAD-CORE GOAL
================================================================================

- A **full single-hart development loop**:
  - ROM bootloader (Phase 1I).
  - HAL (Phase 1J).
  - SDRAM firmware (Phase 1K) loaded over UART/JTAG (H3BT).
- Hardware is stable, ephemeral, and quad-core-ready:
  - AHB fabric (4 masters).
  - AHB→WB bridge.
  - SDRAM, UART, I2C, SPI, GPIO, JTAG-UART all integrated.
- You can now iterate on firmware **without touching RTL**.

===