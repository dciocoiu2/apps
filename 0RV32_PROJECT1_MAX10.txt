================================================================================
PHASE 1A: QUAD-CORE-READY SINGLE-HART HAZARD3 SoC SKELETON ON DE0-LITE
(core tile + 4-master-capable AHB interconnect + Boot ROM + top-level)
ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX
================================================================================

GOAL OF PHASE 1A
----------------
Build the minimal but structurally “correct” SoC skeleton that:

- Instantiates ONE Hazard3 core *via a tile wrapper* with HART_ID = 0.
- Uses an AHB interconnect that is architected for up to FOUR masters (M0..M3), but
  currently only connects M0.
- Has a Boot ROM at 0x2000_0000, implemented in BRAM, with contents from bootrom.hex.
- Has a top-level for DE0-Lite that wires clock/reset and exposes *no SDRAM, no UART*
  yet (we’ll add those in later sub-phases).
- Is synthesizable, programmable, and “alive” (core runs and loops in ROM).

From here, all later phases add:
- AHB→WB bridge
- SDRAM, UART, I2C, SPI, GPIO, JTAG-UART
- Bootloader, HAL, firmware
- Extra cores (for dual / quad)

Directory layout for Phase 1A:
- ~/fpga/h3_phase1_sc/
    - rtl/
        - cores/
            - hazard3/           (git clone)
        - soc/
            - hazard3_tile.sv
            - ahb_interconnect_4m.sv
            - boot_rom.sv
            - top_soc.sv
    - quartus/
        - h3_phase1_sc.qpf / .qsf / etc.
- ~/hazard3_fw/
    - bootrom/
        - bootrom.c
        - linker.ld
        - Makefile

================================================================================
STEP 1 — BASIC SETUP (DIRECTORIES + HAZARD3 REPO)
================================================================================

1. Create directories:

   mkdir -p ~/fpga/h3_phase1_sc/rtl/cores
   mkdir -p ~/fpga/h3_phase1_sc/rtl/soc
   mkdir -p ~/fpga/h3_phase1_sc/quartus
   mkdir -p ~/hazard3_fw/bootrom

2. Clone official Hazard3:

   cd ~/fpga/h3_phase1_sc/rtl/cores
   git clone https://github.com/Wren6991/hazard3.git

   You will use the AHB-based core from this repo; the exact module name might differ
   (e.g. hazard3_core, hazard3_cpu, etc.). In hazard3_tile.sv below, adapt instance
   names/ports to match the actual RTL after inspecting the repo.

================================================================================
STEP 2 — BOOT ROM C CODE + LINKER + HEX (PHASE 1A MINIMAL)
================================================================================

We’ll use a very simple ROM program that:
- Defines _start at 0x2000_0000.
- Executes an infinite loop (heartbeat).
- No peripherals yet.

----- FILE: ~/hazard3_fw/bootrom/linker.ld ------------------------------------

ENTRY(_start)

MEMORY
{
  ROM (rx) : ORIGIN = 0x20000000, LENGTH = 16K
}

SECTIONS
{
  .text :
  {
    *(.text.entry)
    *(.text*)
    *(.rodata*)
  } > ROM

  .data :
  {
    *(.data*)
  } > ROM

  .bss :
  {
    *(.bss*)
    *(COMMON)
  } > ROM
}

----- FILE: ~/hazard3_fw/bootrom/bootrom.c ------------------------------------

#include <stdint.h>

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    // Minimal ROM stub for Phase 1A:
    // Just loop forever to prove the core is fetching and executing.
    while (1) {
        __asm__ volatile("wfi");
    }
}

----- FILE: ~/hazard3_fw/bootrom/Makefile -------------------------------------

RISCV_PREFIX = riscv64-unknown-elf-
CC      = $(RISCV_PREFIX)gcc
OBJCOPY = $(RISCV_PREFIX)objcopy

CFLAGS  = -march=rv32imc -mabi=ilp32 -Os -nostdlib -ffreestanding -Wall -Wextra
LDFLAGS = -T linker.ld -nostartfiles -nostdlib

all: bootrom.hex

bootrom.elf: bootrom.c linker.ld
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ bootrom.c

bootrom.hex: bootrom.elf
	$(OBJCOPY) -O verilog $< $@

clean:
	rm -f bootrom.elf bootrom.hex

Build the ROM hex:

   cd ~/hazard3_fw/bootrom
   make

This produces bootrom.hex; you’ll point boot_rom.sv to this file.

================================================================================
STEP 3 — BOOT_ROM RTL (AHB-LITE SLAVE @ 0x2000_0000)
================================================================================

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/boot_rom.sv ---------------------------

module boot_rom
(
    input  wire        clk,
    input  wire        rst,

    // AHB-Lite slave interface (read-only)
    input  wire [31:0] HADDR,
    input  wire [2:0]  HSIZE,
    input  wire [1:0]  HBURST,
    input  wire [1:0]  HTRANS,
    input  wire        HWRITE,
    input  wire [31:0] HWDATA,
    output reg  [31:0] HRDATA,
    output wire        HREADY,
    output wire        HRESP
);

    // 16 KB ROM = 4K words of 32 bits
    localparam ADDR_WIDTH = 12;        // 2^12 = 4096 words
    localparam MEM_DEPTH  = 1 << ADDR_WIDTH;

    reg [31:0] rom [0:MEM_DEPTH-1];

    initial begin
        // expects bootrom.hex in simulation/synthesis directory
        $readmemh("bootrom.hex", rom);
    end

    assign HREADY = 1'b1; // zero-wait read
    assign HRESP  = 1'b0; // OKAY

    // Word-aligned address; ignore HSIZE for now (32-bit accesses)
    wire [ADDR_WIDTH-1:0] word_addr = HADDR[ADDR_WIDTH+1:2];

    always @(posedge clk) begin
        if (HTRANS[1] && !HWRITE) begin
            HRDATA <= rom[word_addr];
        end
    end

endmodule

================================================================================
STEP 4 — HAZARD3 TILE WRAPPER (HART TILE, AHB MASTER)
================================================================================

We wrap a Hazard3 core into a “tile” with:

- HART_ID parameter.
- AHB-Lite master port.
- Separate clk, rst.

You MUST adapt the internal instance to match the actual Hazard3 core’s module
name and ports from the cloned repo (hazard3/rtl/core/…).

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/hazard3_tile.sv -----------------------

module hazard3_tile #(
    parameter integer HART_ID = 0
)(
    input  wire        clk,
    input  wire        rst,

    // AHB-Lite master interface
    output wire [31:0] HADDR,
    output wire [2:0]  HSIZE,
    output wire [1:0]  HBURST,
    output wire [1:0]  HTRANS,
    output wire        HWRITE,
    output wire [31:0] HWDATA,
    input  wire [31:0] HRDATA,
    input  wire        HREADY,
    input  wire        HRESP

    // later: interrupts, debug, etc.
);

    // TODO: adapt this to the actual Hazard3 AHB core module and ports.
    // The following is a schematic example:

    hazard3_core_ahb #(
        .HART_ID(HART_ID)
    ) u_core (
        .clk_i     (clk),
        .rst_i     (rst),

        // AHB master out
        .haddr_o   (HADDR),
        .hsize_o   (HSIZE),
        .hburst_o  (HBURST),
        .htrans_o  (HTRANS),
        .hwrite_o  (HWRITE),
        .hwdata_o  (HWDATA),

        // AHB master in
        .hrdata_i  (HRDATA),
        .hready_i  (HREADY),
        .hresp_i   (HRESP)

        // interrupts, etc. → tie off or connect later
    );

endmodule

NOTE:
- After cloning Hazard3, inspect the source to find the AHB-enabled core wrapper.
- Replace hazard3_core_ahb and the signal names above with the actual ones.

================================================================================
STEP 5 — AHB INTERCONNECT, 4-MASTER CAPABLE (PHASE 1 USES ONLY M0)
================================================================================

We design an AHB-Lite interconnect structured to support up to 4 masters (M0..M3)
and N slaves. For Phase 1A:

- Only M0 is actually driven (from hazard3_tile HART0).
- Only S0 is used (Boot ROM).
- S1..Sx are left to future phases (AHB→WB bridge, etc.).

We’ll implement:
- Simple fixed-priority arbitration M0 > M1 > M2 > M3.
- Single shared bus; slaves see a single “arbiter output” view.
- For now, one slave region: ROM at 0x2000_0000; everything else unmapped.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/ahb_interconnect_4m.sv ----------------

module ahb_interconnect_4m
(
    input  wire        clk,
    input  wire        rst,

    //=====================
    // MASTER PORTS (4x)
    //=====================

    // Master 0
    input  wire [31:0] m0_haddr,
    input  wire [2:0]  m0_hsize,
    input  wire [1:0]  m0_hburst,
    input  wire [1:0]  m0_htrans,
    input  wire        m0_hwrite,
    input  wire [31:0] m0_hwdata,
    output reg  [31:0] m0_hrdata,
    output reg         m0_hready,
    output reg         m0_hresp,

    // Master 1 (unused in Phase 1A)
    input  wire [31:0] m1_haddr,
    input  wire [2:0]  m1_hsize,
    input  wire [1:0]  m1_hburst,
    input  wire [1:0]  m1_htrans,
    input  wire        m1_hwrite,
    input  wire [31:0] m1_hwdata,
    output reg  [31:0] m1_hrdata,
    output reg         m1_hready,
    output reg         m1_hresp,

    // Master 2
    input  wire [31:0] m2_haddr,
    input  wire [2:0]  m2_hsize,
    input  wire [1:0]  m2_hburst,
    input  wire [1:0]  m2_htrans,
    input  wire        m2_hwrite,
    input  wire [31:0] m2_hwdata,
    output reg  [31:0] m2_hrdata,
    output reg         m2_hready,
    output reg         m2_hresp,

    // Master 3
    input  wire [31:0] m3_haddr,
    input  wire [2:0]  m3_hsize,
    input  wire [1:0]  m3_hburst,
    input  wire [1:0]  m3_htrans,
    input  wire        m3_hwrite,
    input  wire [31:0] m3_hwdata,
    output reg  [31:0] m3_hrdata,
    output reg         m3_hready,
    output reg         m3_hresp,

    //=====================
    // SLAVE PORTS (here: 2, but only s0 is used)
    //=====================

    // Slave 0 (Boot ROM at 0x2000_0000)
    output reg  [31:0] s0_haddr,
    output reg  [2:0]  s0_hsize,
    output reg  [1:0]  s0_hburst,
    output reg  [1:0]  s0_htrans,
    output reg         s0_hwrite,
    output reg  [31:0] s0_hwdata,
    input  wire [31:0] s0_hrdata,
    input  wire        s0_hready,
    input  wire        s0_hresp,

    // Slave 1 (future: AHB→WB bridge for SDRAM+periph)
    output reg  [31:0] s1_haddr,
    output reg  [2:0]  s1_hsize,
    output reg  [1:0]  s1_hburst,
    output reg  [1:0]  s1_htrans,
    output reg         s1_hwrite,
    output reg  [31:0] s1_hwdata,
    input  wire [31:0] s1_hrdata,
    input  wire        s1_hready,
    input  wire        s1_hresp
);

    // -------------------------------------------------------------------------
    // ARBITRATION
    // -------------------------------------------------------------------------
    // Simple fixed priority: M0 > M1 > M2 > M3
    // "Request" = HTRANS[1] (NONSEQ or SEQ)
    wire m0_req = m0_htrans[1];
    wire m1_req = m1_htrans[1];
    wire m2_req = m2_htrans[1];
    wire m3_req = m3_htrans[1];

    reg [1:0] grant; // 0..3 = which master is granted

    always @(*) begin
        if (m0_req)      grant = 2'd0;
        else if (m1_req) grant = 2'd1;
        else if (m2_req) grant = 2'd2;
        else if (m3_req) grant = 2'd3;
        else             grant = 2'd0; // default to 0 if idle
    end

    // -------------------------------------------------------------------------
    // MUX MASTER → SHARED BUS VIEW
    // -------------------------------------------------------------------------
    reg [31:0] HADDR_bus;
    reg [2:0]  HSIZE_bus;
    reg [1:0]  HBURST_bus;
    reg [1:0]  HTRANS_bus;
    reg        HWRITE_bus;
    reg [31:0] HWDATA_bus;

    always @(*) begin
        case (grant)
            2'd0: begin
                HADDR_bus  = m0_haddr;
                HSIZE_bus  = m0_hsize;
                HBURST_bus = m0_hburst;
                HTRANS_bus = m0_htrans;
                HWRITE_bus = m0_hwrite;
                HWDATA_bus = m0_hwdata;
            end
            2'd1: begin
                HADDR_bus  = m1_haddr;
                HSIZE_bus  = m1_hsize;
                HBURST_bus = m1_hburst;
                HTRANS_bus = m1_htrans;
                HWRITE_bus = m1_hwrite;
                HWDATA_bus = m1_hwdata;
            end
            2'd2: begin
                HADDR_bus  = m2_haddr;
                HSIZE_bus  = m2_hsize;
                HBURST_bus = m2_hburst;
                HTRANS_bus = m2_htrans;
                HWRITE_bus = m2_hwrite;
                HWDATA_bus = m2_hwdata;
            end
            2'd3: begin
                HADDR_bus  = m3_haddr;
                HSIZE_bus  = m3_hsize;
                HBURST_bus = m3_hburst;
                HTRANS_bus = m3_htrans;
                HWRITE_bus = m3_hwrite;
                HWDATA_bus = m3_hwdata;
            end
            default: begin
                HADDR_bus  = 32'h0000_0000;
                HSIZE_bus  = 3'b010;
                HBURST_bus = 2'b00;
                HTRANS_bus = 2'b00;
                HWRITE_bus = 1'b0;
                HWDATA_bus = 32'h0000_0000;
            end
        endcase
    end

    // -------------------------------------------------------------------------
    // ADDRESS DECODE (ROM vs future-periph)
    // -------------------------------------------------------------------------
    // ROM at 0x2000_0000 (e.g. match upper nibble 0x2)
    wire sel_s0 = (HADDR_bus[31:28] == 4'h2);
    wire sel_s1 = !sel_s0; // everything else to slave 1 for now

    always @(*) begin
        // defaults
        s0_haddr  = 32'h0;
        s0_hsize  = 3'b010;
        s0_hburst = 2'b00;
        s0_htrans = 2'b00;
        s0_hwrite = 1'b0;
        s0_hwdata = 32'h0;

        s1_haddr  = 32'h0;
        s1_hsize  = 3'b010;
        s1_hburst = 2'b00;
        s1_htrans = 2'b00;
        s1_hwrite = 1'b0;
        s1_hwdata = 32'h0;

        if (sel_s0) begin
            s0_haddr  = HADDR_bus;
            s0_hsize  = HSIZE_bus;
            s0_hburst = HBURST_bus;
            s0_htrans = HTRANS_bus;
            s0_hwrite = HWRITE_bus;
            s0_hwdata = HWDATA_bus;
        end else begin
            s1_haddr  = HADDR_bus;
            s1_hsize  = HSIZE_bus;
            s1_hburst = HBURST_bus;
            s1_htrans = HTRANS_bus;
            s1_hwrite = HWRITE_bus;
            s1_hwdata = HWDATA_bus;
        end
    end

    // -------------------------------------------------------------------------
    // RETURN DATA/READY/RESP TO THE GRANTED MASTER
    // -------------------------------------------------------------------------
    wire [31:0] HRDATA_bus = sel_s0 ? s0_hrdata : s1_hrdata;
    wire        HREADY_bus = sel_s0 ? s0_hready : s1_hready;
    wire        HRESP_bus  = sel_s0 ? s0_hresp  : s1_hresp;

    always @(*) begin
        // default all masters to idle OKAY
        m0_hrdata = 32'h0;
        m0_hready = 1'b1;
        m0_hresp  = 1'b0;

        m1_hrdata = 32'h0;
        m1_hready = 1'b1;
        m1_hresp  = 1'b0;

        m2_hrdata = 32'h0;
        m2_hready = 1'b1;
        m2_hresp  = 1'b0;

        m3_hrdata = 32'h0;
        m3_hready = 1'b1;
        m3_hresp  = 1'b0;

        case (grant)
            2'd0: begin
                m0_hrdata = HRDATA_bus;
                m0_hready = HREADY_bus;
                m0_hresp  = HRESP_bus;
            end
            2'd1: begin
                m1_hrdata = HRDATA_bus;
                m1_hready = HREADY_bus;
                m1_hresp  = HRESP_bus;
            end
            2'd2: begin
                m2_hrdata = HRDATA_bus;
                m2_hready = HREADY_bus;
                m2_hresp  = HRESP_bus;
            end
            2'd3: begin
                m3_hrdata = HRDATA_bus;
                m3_hready = HREADY_bus;
                m3_hresp  = HRESP_bus;
            end
        endcase
    end

endmodule

NOTES:
- In Phase 1A, we will:
  - Connect only M0 to hazard3_tile HART0.
  - Leave M1..M3 unconnected or tied off.
  - Connect S0 to boot_rom.
  - Tie S1 to a dummy “error slave” that returns error or zero (simple stub).

================================================================================
STEP 6 — TOP-LEVEL FOR DE0-LITE (MINIMAL, NO PERIPHERALS YET)
================================================================================

We now define a minimal top-level that:

- Instantiates one hazard3_tile with HART_ID=0.
- Instantiates ahb_interconnect_4m.
- Instantiates boot_rom.
- Exposes only clock and reset pins for now (we’ll add IO in later phases).

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv ----------------------------

module top_soc
(
    input  wire clk_50,   // 50 MHz clock from DE0-Lite
    input  wire reset_n   // active-low reset (pushbutton)
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    //======================
    // AHB master signals from HART0 tile (M0)
    //======================
    wire [31:0] m0_haddr;
    wire [2:0]  m0_hsize;
    wire [1:0]  m0_hburst;
    wire [1:0]  m0_htrans;
    wire        m0_hwrite;
    wire [31:0] m0_hwdata;
    wire [31:0] m0_hrdata;
    wire        m0_hready;
    wire        m0_hresp;

    // M1..M3 unconnected in Phase 1A
    wire [31:0] m1_haddr = 32'h0;
    wire [2:0]  m1_hsize = 3'b010;
    wire [1:0]  m1_hburst = 2'b00;
    wire [1:0]  m1_htrans = 2'b00;
    wire        m1_hwrite = 1'b0;
    wire [31:0] m1_hwdata = 32'h0;
    wire [31:0] m1_hrdata;
    wire        m1_hready;
    wire        m1_hresp;

    wire [31:0] m2_haddr = 32'h0;
    wire [2:0]  m2_hsize = 3'b010;
    wire [1:0]  m2_hburst = 2'b00;
    wire [1:0]  m2_htrans = 2'b00;
    wire        m2_hwrite = 1'b0;
    wire [31:0] m2_hwdata = 32'h0;
    wire [31:0] m2_hrdata;
    wire        m2_hready;
    wire        m2_hresp;

    wire [31:0] m3_haddr = 32'h0;
    wire [2:0]  m3_hsize = 3'b010;
    wire [1:0]  m3_hburst = 2'b00;
    wire [1:0]  m3_htrans = 2'b00;
    wire        m3_hwrite = 1'b0;
    wire [31:0] m3_hwdata = 32'h0;
    wire [31:0] m3_hrdata;
    wire        m3_hready;
    wire        m3_hresp;

    //======================
    // Slave 0 = boot ROM
    // Slave 1 = dummy error slave (for Phase 1A)
    //======================
    wire [31:0] s0_haddr, s1_haddr;
    wire [2:0]  s0_hsize, s1_hsize;
    wire [1:0]  s0_hburst, s1_hburst;
    wire [1:0]  s0_htrans, s1_htrans;
    wire        s0_hwrite, s1_hwrite;
    wire [31:0] s0_hwdata, s1_hwdata;
    wire [31:0] s0_hrdata, s1_hrdata;
    wire        s0_hready, s1_hready;
    wire        s0_hresp,  s1_hresp;

    // HART0 tile
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m0_haddr),
        .HSIZE  (m0_hsize),
        .HBURST (m0_hburst),
        .HTRANS (m0_htrans),
        .HWRITE (m0_hwrite),
        .HWDATA (m0_hwdata),
        .HRDATA (m0_hrdata),
        .HREADY (m0_hready),
        .HRESP  (m0_hresp)
    );

    // AHB interconnect, 4 masters, 2 slaves
    ahb_interconnect_4m u_ahb_ic (
        .clk        (clk),
        .rst        (rst),

        // M0
        .m0_haddr   (m0_haddr),
        .m0_hsize   (m0_hsize),
        .m0_hburst  (m0_hburst),
        .m0_htrans  (m0_htrans),
        .m0_hwrite  (m0_hwrite),
        .m0_hwdata  (m0_hwdata),
        .m0_hrdata  (m0_hrdata),
        .m0_hready  (m0_hready),
        .m0_hresp   (m0_hresp),

        // M1..M3 (unused)
        .m1_haddr   (m1_haddr),
        .m1_hsize   (m1_hsize),
        .m1_hburst  (m1_hburst),
        .m1_htrans  (m1_htrans),
        .m1_hwrite  (m1_hwrite),
        .m1_hwdata  (m1_hwdata),
        .m1_hrdata  (m1_hrdata),
        .m1_hready  (m1_hready),
        .m1_hresp   (m1_hresp),

        .m2_haddr   (m2_haddr),
        .m2_hsize   (m2_hsize),
        .m2_hburst  (m2_hburst),
        .m2_htrans  (m2_htrans),
        .m2_hwrite  (m2_hwrite),
        .m2_hwdata  (m2_hwdata),
        .m2_hrdata  (m2_hrdata),
        .m2_hready  (m2_hready),
        .m2_hresp   (m2_hresp),

        .m3_haddr   (m3_haddr),
        .m3_hsize   (m3_hsize),
        .m3_hburst  (m3_hburst),
        .m3_htrans  (m3_htrans),
        .m3_hwrite  (m3_hwrite),
        .m3_hwdata  (m3_hwdata),
        .m3_hrdata  (m3_hrdata),
        .m3_hready  (m3_hready),
        .m3_hresp   (m3_hresp),

        // Slave 0 = ROM
        .s0_haddr   (s0_haddr),
        .s0_hsize   (s0_hsize),
        .s0_hburst  (s0_hburst),
        .s0_htrans  (s0_htrans),
        .s0_hwrite  (s0_hwrite),
        .s0_hwdata  (s0_hwdata),
        .s0_hrdata  (s0_hrdata),
        .s0_hready  (s0_hready),
        .s0_hresp   (s0_hresp),

        // Slave 1 = dummy
        .s1_haddr   (s1_haddr),
        .s1_hsize   (s1_hsize),
        .s1_hburst  (s1_hburst),
        .s1_htrans  (s1_htrans),
        .s1_hwrite  (s1_hwrite),
        .s1_hwdata  (s1_hwdata),
        .s1_hrdata  (s1_hrdata),
        .s1_hready  (s1_hready),
        .s1_hresp   (s1_hresp)
    );

    // Boot ROM at 0x2000_0000
    boot_rom u_boot_rom (
        .clk    (clk),
        .rst    (rst),
        .HADDR  (s0_haddr),
        .HSIZE  (s0_hsize),
        .HBURST (s0_hburst),
        .HTRANS (s0_htrans),
        .HWRITE (s0_hwrite),
        .HWDATA (s0_hwdata),
        .HRDATA (s0_hrdata),
        .HREADY (s0_hready),
        .HRESP  (s0_hresp)
    );

    // Dummy slave 1: always ready, returns 0, OKAY
    assign s1_hrdata = 32'hDEAD_DEAD;
    assign s1_hready = 1'b1;
    assign s1_hresp  = 1'b0;

endmodule

================================================================================
STEP 7 — QUARTUS PROJECT (PHASE 1A) AND BRING-UP
================================================================================

1. Create Quartus project:

   cd ~/fpga/h3_phase1_sc/quartus
   quartus &

   - New Project Wizard:
     - Directory: ~/fpga/h3_phase1_sc/quartus
     - Name: h3_phase1_sc
     - Top-level entity: top_soc
   - Device: MAX 10 → 10M50DAF484C7G (DE0-Lite)

2. Add RTL files:
   - Project → Add/Remove Files in Project:
     - ../rtl/soc/top_soc.sv
     - ../rtl/soc/hazard3_tile.sv
     - ../rtl/soc/ahb_interconnect_4m.sv
     - ../rtl/soc/boot_rom.sv
     - All relevant Hazard3 core files from ../rtl/cores/hazard3/rtl/...
   - Make sure SystemVerilog (.sv) is enabled where needed.

3. Boot ROM hex:
   - Copy bootrom.hex into the Quartus project directory (or adjust relative
     path in boot_rom.sv to point to ../../hazard3_fw/bootrom/bootrom.hex).
   - Quartus must see bootrom.hex at compile time.

4. Pin assignments (minimal for Phase 1A):
   - clk_50: assign to the DE0-Lite 50 MHz pin (per board manual).
   - reset_n: assign to a pushbutton (e.g. KEY0).
   - No other pins needed yet.

5. Compile:
   - Processing → Start Compilation.
   - If there are missing module names/ports:
     - Fix hazard3_tile.sv to match the actual Hazard3 core wrapper.
     - Ensure all Hazard3 RTL files are included.

6. Program DE0-Lite:
   - Open Quartus Programmer (quartus_pgmw).
   - Hardware Setup → select USB-Blaster.
   - Add h3_phase1_sc.sof from output_files/.
   - Check “Program/Configure”.
   - Click Start.

7. After programming:
   - The Hazard3 core (HART0) begins executing at 0x2000_0000 (Boot ROM).
   - It runs _start(), which loops and executes WFI.
   - From the outside, nothing visible happens yet — but the SoC is structurally
     correct, and the CPU is alive and fetching from ROM.

================================================================================
WHAT PHASE 1A HAS ACHIEVED (QUAD-CORE FUTURE IN MIND)
================================================================================

- You now have a **single-hart Hazard3 SoC skeleton** with:
  - A HART tile abstraction (`hazard3_tile`) with HART_ID.
  - A **4-master-capable** AHB interconnect (`ahb_interconnect_4m`) that will
    easily scale to dual/quad core by adding more tiles and connecting M1..M3.
  - A Boot ROM subsystem at 0x2000_0000 using bootrom.hex.
  - A minimal top-level for DE0-Lite that compiles and runs.

- This is a **clean base** for:
  - Phase 1B: AHB→Wishbone bridge + Wishbone interconnect.
  - Phase 1C+: SDRAM, UART, I2C, SPI, GPIO, JTAG-UART, bootloader, HAL.
  - Phase 2: dual-core bring-up.
  - Phase 3: quad-core with core control and hart coordination.
№############END PHASE1_A################

================================================================================
PHASE 1B: AHB→WISHBONE BRIDGE + WISHBONE FABRIC SHELL (QUAD-CORE-READY)
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH PROGRAMMING)
================================================================================

GOAL OF PHASE 1B
----------------
Extend the Phase 1A SoC skeleton to introduce the full bus hierarchy:

- KEEP:
  - Hazard3 tile (HART0) as AHB master M0.
  - 4-master-capable AHB interconnect (M0..M3, S0=Boot ROM).
  - Boot ROM @ 0x2000_0000, with bootrom.hex.
  - top_soc.sv structure and DE0-Lite top-level.

- ADD in Phase 1B:
  - AHB→Wishbone bridge (burst-aware, but we can treat it as single-beat for now).
  - Wishbone fabric with address decode for:
    - SDRAM @ 0x8000_0000 (future Phase 1C).
    - UART0 @ 0x1000_0000 (future 1D).
    - I2C0 @ 0x1000_0100 (future 1E).
    - SPI0 @ 0x1000_0200 (future 1F).
    - GPIO @ 0x1000_0300 (future 1G).
    - JTAG-UART @ 0x1000_0500 (future 1H).
  - Stub Wishbone slaves for now (return fixed data, OKAY).

NOTES:
- STILL: We only ever program .sof via JTAG → SRAM. No .pof, no flash. On power-cycle
  the DE0-Lite returns to its factory image.
- This phase is about bus structure, NOT functionality. All peripherals are stubs.

Directory context:

- ~/fpga/h3_phase1_sc/rtl/soc/
    - hazard3_tile.sv              (from 1A)
    - ahb_interconnect_4m.sv       (from 1A)
    - boot_rom.sv                  (from 1A)
    - top_soc.sv                   (UPDATED in 1B)
    - ahb_to_wb_bridge.sv          (NEW)
    - wb_interconnect.sv           (NEW)

================================================================================
STEP 1 — AHB→WISHBONE BRIDGE (SINGLE-BEAT, BURST-CAPABLE STRUCTURE)
================================================================================

We design a simple AHB-Lite slave → Wishbone master bridge:

- AHB slave interface:
  - Responds to reads/writes in the 0x1000_0000–0x8FFF_FFFF region.
- Wishbone master interface:
  - Issues a single Wishbone cycle per AHB transfer (Phase 1B).
- Later we can extend it to actually use HBURST for bursts, but the interface will
  already be correct.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/ahb_to_wb_bridge.sv -------------------

module ahb_to_wb_bridge
(
    input  wire        clk,
    input  wire        rst,

    // AHB-Lite slave interface
    input  wire [31:0] HADDR,
    input  wire [2:0]  HSIZE,
    input  wire [1:0]  HBURST,
    input  wire [1:0]  HTRANS,
    input  wire        HWRITE,
    input  wire [31:0] HWDATA,
    output reg  [31:0] HRDATA,
    output reg         HREADY,
    output reg         HRESP,

    // Wishbone master interface
    output reg  [31:0] wb_adr_o,
    output reg  [31:0] wb_dat_o,
    input  wire [31:0] wb_dat_i,
    output reg         wb_we_o,
    output reg  [3:0]  wb_sel_o,
    output reg         wb_cyc_o,
    output reg         wb_stb_o,
    input  wire        wb_ack_i,
    input  wire        wb_err_i
);

    // Simple FSM: IDLE → WB_CYCLE → DONE
    localparam ST_IDLE  = 2'd0;
    localparam ST_WB    = 2'd1;
    localparam ST_RESP  = 2'd2;

    reg [1:0] state, next_state;

    // Latched AHB request info
    reg [31:0] lat_addr;
    reg [31:0] lat_wdata;
    reg        lat_write;
    reg [3:0]  lat_sel;

    wire ahb_valid = HTRANS[1]; // NONSEQ or SEQ

    // Derive byte enables from HSIZE and address (simplified: assume 32-bit)
    // For now we just treat all accesses as 32-bit word.
    wire [3:0] ahb_sel = 4'b1111;

    // FSM
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= ST_IDLE;
        end else begin
            state <= next_state;
        end
    end

    always @(*) begin
        next_state = state;
        case (state)
            ST_IDLE: begin
                if (ahb_valid) begin
                    next_state = ST_WB;
                end
            end
            ST_WB: begin
                if (wb_ack_i || wb_err_i) begin
                    next_state = ST_RESP;
                end
            end
            ST_RESP: begin
                next_state = ST_IDLE;
            end
        endcase
    end

    // Latch AHB request on first valid transfer
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            lat_addr  <= 32'h0;
            lat_wdata <= 32'h0;
            lat_write <= 1'b0;
            lat_sel   <= 4'b0000;
        end else begin
            if (state == ST_IDLE && ahb_valid) begin
                lat_addr  <= HADDR;
                lat_wdata <= HWDATA;
                lat_write <= HWRITE;
                lat_sel   <= ahb_sel;
            end
        end
    end

    // Drive Wishbone signals
    always @(*) begin
        wb_adr_o = 32'h0;
        wb_dat_o = 32'h0;
        wb_we_o  = 1'b0;
        wb_sel_o = 4'b0000;
        wb_cyc_o = 1'b0;
        wb_stb_o = 1'b0;

        case (state)
            ST_WB: begin
                wb_adr_o = lat_addr;
                wb_dat_o = lat_wdata;
                wb_we_o  = lat_write;
                wb_sel_o = lat_sel;
                wb_cyc_o = 1'b1;
                wb_stb_o = 1'b1;
            end
            default: begin
                // IDLE / RESP → no WB cycle
            end
        endcase
    end

    // AHB response
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            HRDATA <= 32'h0;
            HREADY <= 1'b1;
            HRESP  <= 1'b0;
        end else begin
            case (state)
                ST_IDLE: begin
                    HREADY <= 1'b1; // ready for new transfer
                    HRESP  <= 1'b0;
                end
                ST_WB: begin
                    HREADY <= 1'b0; // wait for WB
                    HRESP  <= 1'b0;
                end
                ST_RESP: begin
                    HREADY <= 1'b1;
                    HRESP  <= wb_err_i ? 1'b1 : 1'b0;
                    HRDATA <= wb_dat_i;
                end
            endcase
        end
    end

endmodule

================================================================================
STEP 2 — WISHBONE INTERCONNECT SHELL (6 SLAVES, ALL STUBS FOR NOW)
================================================================================

We now define a single-master, multi-slave Wishbone interconnect:

- Single master: output of ahb_to_wb_bridge.
- Slaves:
  - s0: SDRAM     @ 0x8000_0000–0x8FFF_FFFF (Phase 1C).
  - s1: UART0     @ 0x1000_0000–0x1000_00FF.
  - s2: I2C0      @ 0x1000_0100–0x1000_01FF.
  - s3: SPI0      @ 0x1000_0200–0x1000_02FF.
  - s4: GPIO      @ 0x1000_0300–0x1000_03FF.
  - s5: JTAG-UART @ 0x1000_0500–0x1000_05FF.

In Phase 1B:
- Each slave is a stub: always ACK, returns fixed data, no error.
- In later phases we replace those stubs with real IP instances.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/wb_interconnect.sv --------------------

module wb_interconnect
(
    input  wire        clk,
    input  wire        rst,

    // Master interface
    input  wire [31:0] m_adr_i,
    input  wire [31:0] m_dat_i,
    output reg  [31:0] m_dat_o,
    input  wire        m_we_i,
    input  wire [3:0]  m_sel_i,
    input  wire        m_cyc_i,
    input  wire        m_stb_i,
    output reg         m_ack_o,
    output reg         m_err_o,

    // Slave 0: SDRAM
    output reg  [31:0] s0_adr_o,
    output reg  [31:0] s0_dat_o,
    input  wire [31:0] s0_dat_i,
    output reg         s0_we_o,
    output reg  [3:0]  s0_sel_o,
    output reg         s0_cyc_o,
    output reg         s0_stb_o,
    input  wire        s0_ack_i,
    input  wire        s0_err_i,

    // Slave 1: UART0
    output reg  [31:0] s1_adr_o,
    output reg  [31:0] s1_dat_o,
    input  wire [31:0] s1_dat_i,
    output reg         s1_we_o,
    output reg  [3:0]  s1_sel_o,
    output reg         s1_cyc_o,
    output reg         s1_stb_o,
    input  wire        s1_ack_i,
    input  wire        s1_err_i,

    // Slave 2: I2C0
    output reg  [31:0] s2_adr_o,
    output reg  [31:0] s2_dat_o,
    input  wire [31:0] s2_dat_i,
    output reg         s2_we_o,
    output reg  [3:0]  s2_sel_o,
    output reg         s2_cyc_o,
    output reg         s2_stb_o,
    input  wire        s2_ack_i,
    input  wire        s2_err_i,

    // Slave 3: SPI0
    output reg  [31:0] s3_adr_o,
    output reg  [31:0] s3_dat_o,
    input  wire [31:0] s3_dat_i,
    output reg         s3_we_o,
    output reg  [3:0]  s3_sel_o,
    output reg         s3_cyc_o,
    output reg         s3_stb_o,
    input  wire        s3_ack_i,
    input  wire        s3_err_i,

    // Slave 4: GPIO
    output reg  [31:0] s4_adr_o,
    output reg  [31:0] s4_dat_o,
    input  wire [31:0] s4_dat_i,
    output reg         s4_we_o,
    output reg  [3:0]  s4_sel_o,
    output reg         s4_cyc_o,
    output reg         s4_stb_o,
    input  wire        s4_ack_i,
    input  wire        s4_err_i,

    // Slave 5: JTAG-UART
    output reg  [31:0] s5_adr_o,
    output reg  [31:0] s5_dat_o,
    input  wire [31:0] s5_dat_i,
    output reg         s5_we_o,
    output reg  [3:0]  s5_sel_o,
    output reg         s5_cyc_o,
    output reg         s5_stb_o,
    input  wire        s5_ack_i,
    input  wire        s5_err_i
);

    // Address decode
    // s0: SDRAM region >= 0x8000_0000
    wire sel_s0 = (m_adr_i[31:28] == 4'h8);

    // s1..s5: peripheral regions
    wire sel_s1 = (m_adr_i[31:8] == 24'h100000); // 0x1000_0000 - 0x1000_00FF
    wire sel_s2 = (m_adr_i[31:8] == 24'h100001); // 0x1000_0100 - 0x1000_01FF
    wire sel_s3 = (m_adr_i[31:8] == 24'h100002); // 0x1000_0200 - 0x1000_02FF
    wire sel_s4 = (m_adr_i[31:8] == 24'h100003); // 0x1000_0300 - 0x1000_03FF
    wire sel_s5 = (m_adr_i[31:8] == 24'h100005); // 0x1000_0500 - 0x1000_05FF

    // default: no slave → error
    wire no_slave = !(sel_s0 | sel_s1 | sel_s2 | sel_s3 | sel_s4 | sel_s5);

    // Drive slaves based on select
    always @(*) begin
        // default all slaves inactive
        s0_adr_o = 32'h0; s0_dat_o = 32'h0; s0_we_o = 1'b0; s0_sel_o = 4'b0000; s0_cyc_o = 1'b0; s0_stb_o = 1'b0;
        s1_adr_o = 32'h0; s1_dat_o = 32'h0; s1_we_o = 1'b0; s1_sel_o = 4'b0000; s1_cyc_o = 1'b0; s1_stb_o = 1'b0;
        s2_adr_o = 32'h0; s2_dat_o = 32'h0; s2_we_o = 1'b0; s2_sel_o = 4'b0000; s2_cyc_o = 1'b0; s2_stb_o = 1'b0;
        s3_adr_o = 32'h0; s3_dat_o = 32'h0; s3_we_o = 1'b0; s3_sel_o = 4'b0000; s3_cyc_o = 1'b0; s3_stb_o = 1'b0;
        s4_adr_o = 32'h0; s4_dat_o = 32'h0; s4_we_o = 1'b0; s4_sel_o = 4'b0000; s4_cyc_o = 1'b0; s4_stb_o = 1'b0;
        s5_adr_o = 32'h0; s5_dat_o = 32'h0; s5_we_o = 1'b0; s5_sel_o = 4'b0000; s5_cyc_o = 1'b0; s5_stb_o = 1'b0;

        if (m_cyc_i && m_stb_i) begin
            if (sel_s0) begin
                s0_adr_o = m_adr_i;
                s0_dat_o = m_dat_i;
                s0_we_o  = m_we_i;
                s0_sel_o = m_sel_i;
                s0_cyc_o = 1'b1;
                s0_stb_o = 1'b1;
            end else if (sel_s1) begin
                s1_adr_o = m_adr_i;
                s1_dat_o = m_dat_i;
                s1_we_o  = m_we_i;
                s1_sel_o = m_sel_i;
                s1_cyc_o = 1'b1;
                s1_stb_o = 1'b1;
            end else if (sel_s2) begin
                s2_adr_o = m_adr_i;
                s2_dat_o = m_dat_i;
                s2_we_o  = m_we_i;
                s2_sel_o = m_sel_i;
                s2_cyc_o = 1'b1;
                s2_stb_o = 1'b1;
            end else if (sel_s3) begin
                s3_adr_o = m_adr_i;
                s3_dat_o = m_dat_i;
                s3_we_o  = m_we_i;
                s3_sel_o = m_sel_i;
                s3_cyc_o = 1'b1;
                s3_stb_o = 1'b1;
            end else if (sel_s4) begin
                s4_adr_o = m_adr_i;
                s4_dat_o = m_dat_i;
                s4_we_o  = m_we_i;
                s4_sel_o = m_sel_i;
                s4_cyc_o = 1'b1;
                s4_stb_o = 1'b1;
            end else if (sel_s5) begin
                s5_adr_o = m_adr_i;
                s5_dat_o = m_dat_i;
                s5_we_o  = m_we_i;
                s5_sel_o = m_sel_i;
                s5_cyc_o = 1'b1;
                s5_stb_o = 1'b1;
            end
        end
    end

    // Return data/ack/err to master
    always @(*) begin
        m_dat_o = 32'h0;
        m_ack_o = 1'b0;
        m_err_o = 1'b0;

        if (m_cyc_i && m_stb_i) begin
            if (sel_s0) begin
                m_dat_o = s0_dat_i;
                m_ack_o = s0_ack_i;
                m_err_o = s0_err_i;
            end else if (sel_s1) begin
                m_dat_o = s1_dat_i;
                m_ack_o = s1_ack_i;
                m_err_o = s1_err_i;
            end else if (sel_s2) begin
                m_dat_o = s2_dat_i;
                m_ack_o = s2_ack_i;
                m_err_o = s2_err_i;
            end else if (sel_s3) begin
                m_dat_o = s3_dat_i;
                m_ack_o = s3_ack_i;
                m_err_o = s3_err_i;
            end else if (sel_s4) begin
                m_dat_o = s4_dat_i;
                m_ack_o = s4_ack_i;
                m_err_o = s4_err_i;
            end else if (sel_s5) begin
                m_dat_o = s5_dat_i;
                m_ack_o = s5_ack_i;
                m_err_o = s5_err_i;
            end else if (no_slave) begin
                m_dat_o = 32'hBAD0_0000;
                m_ack_o = 1'b1;
                m_err_o = 1'b1;
            end
        end
    end

endmodule

================================================================================
STEP 3 — TOP-LEVEL UPDATE: CONNECT AHB→WB BRIDGE + WB INTERCONNECT + STUB SLAVES
================================================================================

Now we update top_soc.sv to:

- Hook up AHB slave 1 (previous dummy) to ahb_to_wb_bridge.
- Hook the bridge’s Wishbone master to wb_interconnect.
- Instantiate stub Wishbone slaves for SDRAM, UART, I2C, SPI, GPIO, JTAG-UART.

NOTE:
- You REPLACE the old dummy S1 logic in top_soc.sv with the new bridge+WB fabric.
- The rest (HART0 tile, AHB interconnect, Boot ROM) remains as in Phase 1A.

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv -------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    //======================
    // AHB master signals from HART0 tile (M0)
    //======================
    wire [31:0] m0_haddr;
    wire [2:0]  m0_hsize;
    wire [1:0]  m0_hburst;
    wire [1:0]  m0_htrans;
    wire        m0_hwrite;
    wire [31:0] m0_hwdata;
    wire [31:0] m0_hrdata;
    wire        m0_hready;
    wire        m0_hresp;

    // M1..M3 unused
    wire [31:0] m1_haddr = 32'h0;
    wire [2:0]  m1_hsize = 3'b010;
    wire [1:0]  m1_hburst = 2'b00;
    wire [1:0]  m1_htrans = 2'b00;
    wire        m1_hwrite = 1'b0;
    wire [31:0] m1_hwdata = 32'h0;
    wire [31:0] m1_hrdata;
    wire        m1_hready;
    wire        m1_hresp;

    wire [31:0] m2_haddr = 32'h0;
    wire [2:0]  m2_hsize = 3'b010;
    wire [1:0]  m2_hburst = 2'b00;
    wire [1:0]  m2_htrans = 2'b00;
    wire        m2_hwrite = 1'b0;
    wire [31:0] m2_hwdata = 32'h0;
    wire [31:0] m2_hrdata;
    wire        m2_hready;
    wire        m2_hresp;

    wire [31:0] m3_haddr = 32'h0;
    wire [2:0]  m3_hsize = 3'b010;
    wire [1:0]  m3_hburst = 2'b00;
    wire [1:0]  m3_htrans = 2'b00;
    wire        m3_hwrite = 1'b0;
    wire [31:0] m3_hwdata = 32'h0;
    wire [31:0] m3_hrdata;
    wire        m3_hready;
    wire        m3_hresp;

    // Slave 0: Boot ROM
    wire [31:0] s0_haddr, s1_haddr;
    wire [2:0]  s0_hsize, s1_hsize;
    wire [1:0]  s0_hburst, s1_hburst;
    wire [1:0]  s0_htrans, s1_htrans;
    wire        s0_hwrite, s1_hwrite;
    wire [31:0] s0_hwdata, s1_hwdata;
    wire [31:0] s0_hrdata, s1_hrdata;
    wire        s0_hready, s1_hready;
    wire        s0_hresp,  s1_hresp;

    // HART0 tile
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m0_haddr),
        .HSIZE  (m0_hsize),
        .HBURST (m0_hburst),
        .HTRANS (m0_htrans),
        .HWRITE (m0_hwrite),
        .HWDATA (m0_hwdata),
        .HRDATA (m0_hrdata),
        .HREADY (m0_hready),
        .HRESP  (m0_hresp)
    );

    // AHB interconnect
    ahb_interconnect_4m u_ahb_ic (
        .clk        (clk),
        .rst        (rst),

        .m0_haddr   (m0_haddr),
        .m0_hsize   (m0_hsize),
        .m0_hburst  (m0_hburst),
        .m0_htrans  (m0_htrans),
        .m0_hwrite  (m0_hwrite),
        .m0_hwdata  (m0_hwdata),
        .m0_hrdata  (m0_hrdata),
        .m0_hready  (m0_hready),
        .m0_hresp   (m0_hresp),

        .m1_haddr   (m1_haddr),
        .m1_hsize   (m1_hsize),
        .m1_hburst  (m1_hburst),
        .m1_htrans  (m1_htrans),
        .m1_hwrite  (m1_hwrite),
        .m1_hwdata  (m1_hwdata),
        .m1_hrdata  (m1_hrdata),
        .m1_hready  (m1_hready),
        .m1_hresp   (m1_hresp),

        .m2_haddr   (m2_haddr),
        .m2_hsize   (m2_hsize),
        .m2_hburst  (m2_hburst),
        .m2_htrans  (m2_htrans),
        .m2_hwrite  (m2_hwrite),
        .m2_hwdata  (m2_hwdata),
        .m2_hrdata  (m2_hrdata),
        .m2_hready  (m2_hready),
        .m2_hresp   (m2_hresp),

        .m3_haddr   (m3_haddr),
        .m3_hsize   (m3_hsize),
        .m3_hburst  (m3_hburst),
        .m3_htrans  (m3_htrans),
        .m3_hwrite  (m3_hwrite),
        .m3_hwdata  (m3_hwdata),
        .m3_hrdata  (m3_hrdata),
        .m3_hready  (m3_hready),
        .m3_hresp   (m3_hresp),

        .s0_haddr   (s0_haddr),
        .s0_hsize   (s0_hsize),
        .s0_hburst  (s0_hburst),
        .s0_htrans  (s0_htrans),
        .s0_hwrite  (s0_hwrite),
        .s0_hwdata  (s0_hwdata),
        .s0_hrdata  (s0_hrdata),
        .s0_hready  (s0_hready),
        .s0_hresp   (s0_hresp),

        .s1_haddr   (s1_haddr),
        .s1_hsize   (s1_hsize),
        .s1_hburst  (s1_hburst),
        .s1_htrans  (s1_htrans),
        .s1_hwrite  (s1_hwrite),
        .s1_hwdata  (s1_hwdata),
        .s1_hrdata  (s1_hrdata),
        .s1_hready  (s1_hready),
        .s1_hresp   (s1_hresp)
    );

    // Boot ROM
    boot_rom u_boot_rom (
        .clk    (clk),
        .rst    (rst),
        .HADDR  (s0_haddr),
        .HSIZE  (s0_hsize),
        .HBURST (s0_hburst),
        .HTRANS (s0_htrans),
        .HWRITE (s0_hwrite),
        .HWDATA (s0_hwdata),
        .HRDATA (s0_hrdata),
        .HREADY (s0_hready),
        .HRESP  (s0_hresp)
    );

    // AHB→Wishbone bridge on slave 1
    wire [31:0] wb_adr_m;
    wire [31:0] wb_dat_o_m;
    wire [31:0] wb_dat_i_m;
    wire        wb_we_m;
    wire [3:0]  wb_sel_m;
    wire        wb_cyc_m;
    wire        wb_stb_m;
    wire        wb_ack_m;
    wire        wb_err_m;

    ahb_to_wb_bridge u_ahb2wb (
        .clk        (clk),
        .rst        (rst),

        .HADDR      (s1_haddr),
        .HSIZE      (s1_hsize),
        .HBURST     (s1_hburst),
        .HTRANS     (s1_htrans),
        .HWRITE     (s1_hwrite),
        .HWDATA     (s1_hwdata),
        .HRDATA     (s1_hrdata),
        .HREADY     (s1_hready),
        .HRESP      (s1_hresp),

        .wb_adr_o   (wb_adr_m),
        .wb_dat_o   (wb_dat_o_m),
        .wb_dat_i   (wb_dat_i_m),
        .wb_we_o    (wb_we_m),
        .wb_sel_o   (wb_sel_m),
        .wb_cyc_o   (wb_cyc_m),
        .wb_stb_o   (wb_stb_m),
        .wb_ack_i   (wb_ack_m),
        .wb_err_i   (wb_err_m)
    );

    // Wishbone interconnect and stub slaves
    wire [31:0] s0_dat_i, s1_dat_i, s2_dat_i, s3_dat_i, s4_dat_i, s5_dat_i;
    wire        s0_ack_i, s1_ack_i, s2_ack_i, s3_ack_i, s4_ack_i, s5_ack_i;
    wire        s0_err_i, s1_err_i, s2_err_i, s3_err_i, s4_err_i, s5_err_i;

    wire [31:0] s0_adr_o, s1_adr_o, s2_adr_o, s3_adr_o, s4_adr_o, s5_adr_o;
    wire [31:0] s0_dat_o, s1_dat_o, s2_dat_o, s3_dat_o, s4_dat_o, s5_dat_o;
    wire        s0_we_o, s1_we_o, s2_we_o, s3_we_o, s4_we_o, s5_we_o;
    wire [3:0]  s0_sel_o, s1_sel_o, s2_sel_o, s3_sel_o, s4_sel_o, s5_sel_o;
    wire        s0_cyc_o, s1_cyc_o, s2_cyc_o, s3_cyc_o, s4_cyc_o, s5_cyc_o;
    wire        s0_stb_o, s1_stb_o, s2_stb_o, s3_stb_o, s4_stb_o, s5_stb_o;

    wb_interconnect u_wb_ic (
        .clk        (clk),
        .rst        (rst),

        .m_adr_i    (wb_adr_m),
        .m_dat_i    (wb_dat_o_m),
        .m_dat_o    (wb_dat_i_m),
        .m_we_i     (wb_we_m),
        .m_sel_i    (wb_sel_m),
        .m_cyc_i    (wb_cyc_m),
        .m_stb_i    (wb_stb_m),
        .m_ack_o    (wb_ack_m),
        .m_err_o    (wb_err_m),

        .s0_adr_o   (s0_adr_o),
        .s0_dat_o   (s0_dat_o),
        .s0_dat_i   (s0_dat_i),
        .s0_we_o    (s0_we_o),
        .s0_sel_o   (s0_sel_o),
        .s0_cyc_o   (s0_cyc_o),
        .s0_stb_o   (s0_stb_o),
        .s0_ack_i   (s0_ack_i),
        .s0_err_i   (s0_err_i),

        .s1_adr_o   (s1_adr_o),
        .s1_dat_o   (s1_dat_o),
        .s1_dat_i   (s1_dat_i),
        .s1_we_o    (s1_we_o),
        .s1_sel_o   (s1_sel_o),
        .s1_cyc_o   (s1_cyc_o),
        .s1_stb_o   (s1_stb_o),
        .s1_ack_i   (s1_ack_i),
        .s1_err_i   (s1_err_i),

        .s2_adr_o   (s2_adr_o),
        .s2_dat_o   (s2_dat_o),
        .s2_dat_i   (s2_dat_i),
        .s2_we_o    (s2_we_o),
        .s2_sel_o   (s2_sel_o),
        .s2_cyc_o   (s2_cyc_o),
        .s2_stb_o   (s2_stb_o),
        .s2_ack_i   (s2_ack_i),
        .s2_err_i   (s2_err_i),

        .s3_adr_o   (s3_adr_o),
        .s3_dat_o   (s3_dat_o),
        .s3_dat_i   (s3_dat_i),
        .s3_we_o    (s3_we_o),
        .s3_sel_o   (s3_sel_o),
        .s3_cyc_o   (s3_cyc_o),
        .s3_stb_o   (s3_stb_o),
        .s3_ack_i   (s3_ack_i),
        .s3_err_i   (s3_err_i),

        .s4_adr_o   (s4_adr_o),
        .s4_dat_o   (s4_dat_o),
        .s4_dat_i   (s4_dat_i),
        .s4_we_o    (s4_we_o),
        .s4_sel_o   (s4_sel_o),
        .s4_cyc_o   (s4_cyc_o),
        .s4_stb_o   (s4_stb_o),
        .s4_ack_i   (s4_ack_i),
        .s4_err_i   (s4_err_i),

        .s5_adr_o   (s5_adr_o),
        .s5_dat_o   (s5_dat_o),
        .s5_dat_i   (s5_dat_i),
        .s5_we_o    (s5_we_o),
        .s5_sel_o   (s5_sel_o),
        .s5_cyc_o   (s5_cyc_o),
        .s5_stb_o   (s5_stb_o),
        .s5_ack_i   (s5_ack_i),
        .s5_err_i   (s5_err_i)
    );

    // Stub slaves for now: always ACK, no error, return distinct constants
    assign s0_dat_i = 32'hSDRA_0000; assign s0_ack_i = s0_cyc_o & s0_stb_o; assign s0_err_i = 1'b0;
    assign s1_dat_i = 32'hUART_0000; assign s1_ack_i = s1_cyc_o & s1_stb_o; assign s1_err_i = 1'b0;
    assign s2_dat_i = 32'hI2C0_000;  assign s2_ack_i = s2_cyc_o & s2_stb_o; assign s2_err_i = 1'b0;
    assign s3_dat_i = 32'hSPI0_000;  assign s3_ack_i = s3_cyc_o & s3_stb_o; assign s3_err_i = 1'b0;
    assign s4_dat_i = 32'hGPIO_000;  assign s4_ack_i = s4_cyc_o & s4_stb_o; assign s4_err_i = 1'b0;
    assign s5_dat_i = 32'hJTAG_000;  assign s5_ack_i = s5_cyc_o & s5_stb_o; assign s5_err_i = 1'b0;

endmodule

================================================================================
STEP 4 — QUARTUS BUILD & PROGRAMMING (STILL SRAM-ONLY, NO FLASH)
================================================================================

1. Ensure files are in place:
   - ~/fpga/h3_phase1_sc/rtl/soc/hazard3_tile.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/ahb_interconnect_4m.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/boot_rom.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/ahb_to_wb_bridge.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/wb_interconnect.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv
   - Hazard3 core RTL under rtl/cores/hazard3/...

2. Boot ROM hex:
   - cd ~/hazard3_fw/bootrom
   - make
   - Copy bootrom.hex into ~/fpga/h3_phase1_sc/quartus (or adjust path in boot_rom.sv).

3. In Quartus:
   - Open h3_phase1_sc project (from Phase 1A).
   - Add the new RTL files (ahb_to_wb_bridge, wb_interconnect, updated top_soc.sv).
   - Re-run Analysis & Synthesis and full Compilation.

4. Program DE0-Lite (SRAM-only):
   - Open Quartus Programmer.
   - Mode: JTAG.
   - File: h3_phase1_sc.sof (output_files/).
   - Check ONLY “Program/Configure”.
   - DO NOT create or program .pof. DO NOT set any configuration device.
   - Click Start.

5. After programming:
   - HART0 still boots from ROM and loops in _start().
   - Any AHB access in 0x1000_0000–0x8FFF_FFFF goes through the AHB→WB bridge
     and WB interconnect to stub slaves, returning known constants.

================================================================================
WHAT PHASE 1B ACHIEVES TOWARD QUAD-CORE GOAL
================================================================================

- You now have a **quad-core-ready bus architecture**:
  - 4-master AHB interconnect (M0 live, M1–M3 reserved).
  - AHB→WB bridge as a unified gateway to all off-core memory & peripherals.
  - Wishbone fabric with stable, final address map for SDRAM and peripherals.

- The next phases can now cleanly:
  - Replace SDRAM stub (s0) with OpenCores SDRAM controller (Phase 1C).
  - Replace UART/I2C/SPI/GPIO/JTAG-UART stubs (s1–s5) with real IP (Phases 1D–1H).
  - Add bootloader, HAL, and firmware on top (1I–1K).
  - Then scale to 2 and 4 cores by hooking up more hazard3_tile instances to M1..M3.

################END PHASE1B#############
================================================================================
PHASE 1C: SDRAM INTEGRATION (OPENCORES CONTROLLER) INTO AHB→WB FABRIC
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 1C
----------------
Replace the SDRAM stub (Wishbone s0) from Phase 1B with a **real** OpenCores-style
SDRAM controller, giving you:

- External SDRAM @ 0x8000_0000 on DE0-Lite.
- SDRAM accessed via:
  Hazard3 → AHB interconnect → AHB→WB bridge → WB SDRAM controller.
- Still: only `.sof` programmed via JTAG into **SRAM**, never flash.
  On power-cycle, the DE0-Lite returns to its factory demo.

ASSUMPTIONS
-----------
- You have the DE0-Lite’s SDRAM chip (IS42S16400 or equivalent 16-bit SDRAM) wired
  to the FPGA using the Terasic reference design.
- You can download an OpenCores SDRAM controller that:
  - Speaks **Wishbone** on the system side.
  - Drives standard SDRAM signals (addr, bank, dq, dqm, ras/cas/we, cke, clk).
- We’ll:
  - Add a WB wrapper/top for the SDRAM controller.
  - Connect it to s0_* ports of wb_interconnect.
  - Expose SDRAM pins from top_soc.
  - Keep all other slaves (UART/I2C/SPI/GPIO/JTAG-UART) as stubs for now.

DIRECTORY CONTEXT
-----------------
We add:

- ~/fpga/h3_phase1_sc/rtl/cores/opencores_sdram/
    - sdram_ctrl.v            (from OpenCores)
    - (other files as needed by that core)
- ~/fpga/h3_phase1_sc/rtl/soc/sdram_wb_wrapper.sv   (NEW)
- Update: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv    (add SDRAM instance + pins)

You still have:

- hazard3_tile.sv
- ahb_interconnect_4m.sv
- ahb_to_wb_bridge.sv
- wb_interconnect.sv
- boot_rom.sv
- bootrom.hex (Phase 1A ROM)

================================================================================
STEP 1 — PLACE THE OPENCORES SDRAM CONTROLLER RTL
================================================================================

1. Create directory for the SDRAM core:

   mkdir -p ~/fpga/h3_phase1_sc/rtl/cores/opencores_sdram

2. Download the OpenCores SDRAM controller sources from opencores.org into that
   directory. The main top-level usually has a name like:

   - sdram_ctrl.v   or
   - sdr_ctrl.v

   It typically exposes:

   - Wishbone system interface:
     - wb_clk_i, wb_rst_i
     - wb_adr_i, wb_dat_i, wb_dat_o, wb_sel_i, wb_cyc_i, wb_stb_i, wb_we_i
     - wb_ack_o, wb_err_o
   - SDRAM signals:
     - sdram_clk, sdram_cke, sdram_cs_n, sdram_ras_n, sdram_cas_n, sdram_we_n
     - sdram_ba, sdram_a
     - sdram_dqm, sdram_dq

   The exact names may differ slightly; adjust the wrapper accordingly.

================================================================================
STEP 2 — WISHBONE SDRAM WRAPPER (ADAPT TO OUR FABRIC)
================================================================================

We wrap the raw SDRAM controller into a module with **exactly** the Wishbone ports
expected by wb_interconnect for s0.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/sdram_wb_wrapper.sv -------------------

module sdram_wb_wrapper
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone slave interface (from wb_interconnect)
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output wire [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output wire        wb_ack_o,
    output wire        wb_err_o,

    // SDRAM physical interface (to DE0-Lite board pins)
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq
);

    // The OpenCores controller often expects:
    // - byte address or word address; we pass wb_adr_i directly / or truncated.
    // - 32-bit data; matches our fabric.
    // - synchronous reset and clock.

    // Adjust these instance/port names to your specific OpenCores SDRAM core.
    // Example instance (placeholder names):

    wire [31:0] sdram_dat_o;
    wire        sdram_ack_o;
    wire        sdram_err_o;

    assign wb_dat_o = sdram_dat_o;
    assign wb_ack_o = sdram_ack_o;
    assign wb_err_o = sdram_err_o;

    sdram_ctrl u_sdram (
        // System
        .wb_clk_i   (clk),
        .wb_rst_i   (rst),

        .wb_adr_i   (wb_adr_i),
        .wb_dat_i   (wb_dat_i),
        .wb_dat_o   (sdram_dat_o),
        .wb_sel_i   (wb_sel_i),
        .wb_cyc_i   (wb_cyc_i),
        .wb_stb_i   (wb_stb_i),
        .wb_we_i    (wb_we_i),
        .wb_ack_o   (sdram_ack_o),
        .wb_err_o   (sdram_err_o),

        // SDRAM
        .sdram_clk  (sdram_clk),
        .sdram_cke  (sdram_cke),
        .sdram_cs_n (sdram_cs_n),
        .sdram_ras_n(sdram_ras_n),
        .sdram_cas_n(sdram_cas_n),
        .sdram_we_n (sdram_we_n),
        .sdram_ba   (sdram_ba),
        .sdram_a    (sdram_a),
        .sdram_dqm  (sdram_dqm),
        .sdram_dq   (sdram_dq)
    );

endmodule

NOTES:
- The exact module name and ports of the OpenCores SDRAM core might differ:
  - You might need to map address width, data width, CAS latency, etc.
  - You may need to parameterize the controller (e.g. bank bits, row/col bits).
- This wrapper’s job is only to match **Wishbone** and expose SDRAM pins.

================================================================================
STEP 3 — UPDATE wb_interconnect TO BE USED WITH REAL SDRAM (LOGIC ALREADY OK)
================================================================================

Our Phase 1B wb_interconnect is already structurally correct for s0 as SDRAM.  
We just need to:

- Connect s0_* ports to sdram_wb_wrapper instead of the s0 stub.

No change required inside wb_interconnect.sv itself.

================================================================================
STEP 4 — UPDATE top_soc.sv TO INSTANTIATE SDRAM WRAPPER + EXPOSE PINS
================================================================================

We now modify top_soc.sv:

- Add SDRAM pins to the module ports.
- Replace SDRAM stub assignments for s0_… with the real wrapper instance.
- Keep stubs for s1–s5 (UART/I2C/SPI/GPIO/JTAG-UART) for now.

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv -------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n,

    // SDRAM pins (to DE0-Lite external SDRAM)
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq

    // Later phases: add UART/I2C/SPI/GPIO pins here
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    //======================
    // AHB masters as in Phase 1B (HART0 + reserved M1..M3)
    //======================
    wire [31:0] m0_haddr;
    wire [2:0]  m0_hsize;
    wire [1:0]  m0_hburst;
    wire [1:0]  m0_htrans;
    wire        m0_hwrite;
    wire [31:0] m0_hwdata;
    wire [31:0] m0_hrdata;
    wire        m0_hready;
    wire        m0_hresp;

    wire [31:0] m1_haddr = 32'h0;
    wire [2:0]  m1_hsize = 3'b010;
    wire [1:0]  m1_hburst = 2'b00;
    wire [1:0]  m1_htrans = 2'b00;
    wire        m1_hwrite = 1'b0;
    wire [31:0] m1_hwdata = 32'h0;
    wire [31:0] m1_hrdata;
    wire        m1_hready;
    wire        m1_hresp;

    wire [31:0] m2_haddr = 32'h0;
    wire [2:0]  m2_hsize = 3'b010;
    wire [1:0]  m2_hburst = 2'b00;
    wire [1:0]  m2_htrans = 2'b00;
    wire        m2_hwrite = 1'b0;
    wire [31:0] m2_hwdata = 32'h0;
    wire [31:0] m2_hrdata;
    wire        m2_hready;
    wire        m2_hresp;

    wire [31:0] m3_haddr = 32'h0;
    wire [2:0]  m3_hsize = 3'b010;
    wire [1:0]  m3_hburst = 2'b00;
    wire [1:0]  m3_htrans = 2'b00;
    wire        m3_hwrite = 1'b0;
    wire [31:0] m3_hwdata = 32'h0;
    wire [31:0] m3_hrdata;
    wire        m3_hready;
    wire        m3_hresp;

    // AHB slaves: s0 = ROM, s1 = AHB→WB
    wire [31:0] s0_haddr, s1_haddr;
    wire [2:0]  s0_hsize, s1_hsize;
    wire [1:0]  s0_hburst, s1_hburst;
    wire [1:0]  s0_htrans, s1_htrans;
    wire        s0_hwrite, s1_hwrite;
    wire [31:0] s0_hwdata, s1_hwdata;
    wire [31:0] s0_hrdata, s1_hrdata;
    wire        s0_hready, s1_hready;
    wire        s0_hresp,  s1_hresp;

    // HART0
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m0_haddr),
        .HSIZE  (m0_hsize),
        .HBURST (m0_hburst),
        .HTRANS (m0_htrans),
        .HWRITE (m0_hwrite),
        .HWDATA (m0_hwdata),
        .HRDATA (m0_hrdata),
        .HREADY (m0_hready),
        .HRESP  (m0_hresp)
    );

    // AHB interconnect
    ahb_interconnect_4m u_ahb_ic (
        .clk        (clk),
        .rst        (rst),

        .m0_haddr   (m0_haddr),
        .m0_hsize   (m0_hsize),
        .m0_hburst  (m0_hburst),
        .m0_htrans  (m0_htrans),
        .m0_hwrite  (m0_hwrite),
        .m0_hwdata  (m0_hwdata),
        .m0_hrdata  (m0_hrdata),
        .m0_hready  (m0_hready),
        .m0_hresp   (m0_hresp),

        .m1_haddr   (m1_haddr),
        .m1_hsize   (m1_hsize),
        .m1_hburst  (m1_hburst),
        .m1_htrans  (m1_htrans),
        .m1_hwrite  (m1_hwrite),
        .m1_hwdata  (m1_hwdata),
        .m1_hrdata  (m1_hrdata),
        .m1_hready  (m1_hready),
        .m1_hresp   (m1_hresp),

        .m2_haddr   (m2_haddr),
        .m2_hsize   (m2_hsize),
        .m2_hburst  (m2_hburst),
        .m2_htrans  (m2_htrans),
        .m2_hwrite  (m2_hwrite),
        .m2_hwdata  (m2_hwdata),
        .m2_hrdata  (m2_hrdata),
        .m2_hready  (m2_hready),
        .m2_hresp   (m2_hresp),

        .m3_haddr   (m3_haddr),
        .m3_hsize   (m3_hsize),
        .m3_hburst  (m3_hburst),
        .m3_htrans  (m3_htrans),
        .m3_hwrite  (m3_hwrite),
        .m3_hwdata  (m3_hwdata),
        .m3_hrdata  (m3_hrdata),
        .m3_hready  (m3_hready),
        .m3_hresp   (m3_hresp),

        .s0_haddr   (s0_haddr),
        .s0_hsize   (s0_hsize),
        .s0_hburst  (s0_hburst),
        .s0_htrans  (s0_htrans),
        .s0_hwrite  (s0_hwrite),
        .s0_hwdata  (s0_hwdata),
        .s0_hrdata  (s0_hrdata),
        .s0_hready  (s0_hready),
        .s0_hresp   (s0_hresp),

        .s1_haddr   (s1_haddr),
        .s1_hsize   (s1_hsize),
        .s1_hburst  (s1_hburst),
        .s1_htrans  (s1_htrans),
        .s1_hwrite  (s1_hwrite),
        .s1_hwdata  (s1_hwdata),
        .s1_hrdata  (s1_hrdata),
        .s1_hready  (s1_hready),
        .s1_hresp   (s1_hresp)
    );

    // Boot ROM @ 0x2000_0000
    boot_rom u_boot_rom (
        .clk    (clk),
        .rst    (rst),
        .HADDR  (s0_haddr),
        .HSIZE  (s0_hsize),
        .HBURST (s0_hburst),
        .HTRANS (s0_htrans),
        .HWRITE (s0_hwrite),
        .HWDATA (s0_hwdata),
        .HRDATA (s0_hrdata),
        .HREADY (s0_hready),
        .HRESP  (s0_hresp)
    );

    // AHB→Wishbone bridge on slave 1 (peripheral/SRAM region)
    wire [31:0] wb_adr_m;
    wire [31:0] wb_dat_o_m;
    wire [31:0] wb_dat_i_m;
    wire        wb_we_m;
    wire [3:0]  wb_sel_m;
    wire        wb_cyc_m;
    wire        wb_stb_m;
    wire        wb_ack_m;
    wire        wb_err_m;

    ahb_to_wb_bridge u_ahb2wb (
        .clk        (clk),
        .rst        (rst),

        .HADDR      (s1_haddr),
        .HSIZE      (s1_hsize),
        .HBURST     (s1_hburst),
        .HTRANS     (s1_htrans),
        .HWRITE     (s1_hwrite),
        .HWDATA     (s1_hwdata),
        .HRDATA     (s1_hrdata),
        .HREADY     (s1_hready),
        .HRESP      (s1_hresp),

        .wb_adr_o   (wb_adr_m),
        .wb_dat_o   (wb_dat_o_m),
        .wb_dat_i   (wb_dat_i_m),
        .wb_we_o    (wb_we_m),
        .wb_sel_o   (wb_sel_m),
        .wb_cyc_o   (wb_cyc_m),
        .wb_stb_o   (wb_stb_m),
        .wb_ack_i   (wb_ack_m),
        .wb_err_i   (wb_err_m)
    );

    // Wishbone interconnect
    wire [31:0] s0_dat_i, s1_dat_i, s2_dat_i, s3_dat_i, s4_dat_i, s5_dat_i;
    wire        s0_ack_i, s1_ack_i, s2_ack_i, s3_ack_i, s4_ack_i, s5_ack_i;
    wire        s0_err_i, s1_err_i, s2_err_i, s3_err_i, s4_err_i, s5_err_i;

    wire [31:0] s0_adr_o, s1_adr_o, s2_adr_o, s3_adr_o, s4_adr_o, s5_adr_o;
    wire [31:0] s0_dat_o, s1_dat_o, s2_dat_o, s3_dat_o, s4_dat_o, s5_dat_o;
    wire        s0_we_o,  s1_we_o,  s2_we_o,  s3_we_o,  s4_we_o,  s5_we_o;
    wire [3:0]  s0_sel_o, s1_sel_o, s2_sel_o, s3_sel_o, s4_sel_o, s5_sel_o;
    wire        s0_cyc_o, s1_cyc_o, s2_cyc_o, s3_cyc_o, s4_cyc_o, s5_cyc_o;
    wire        s0_stb_o, s1_stb_o, s2_stb_o, s3_stb_o, s4_stb_o, s5_stb_o;

    wb_interconnect u_wb_ic (
        .clk        (clk),
        .rst        (rst),

        .m_adr_i    (wb_adr_m),
        .m_dat_i    (wb_dat_o_m),
        .m_dat_o    (wb_dat_i_m),
        .m_we_i     (wb_we_m),
        .m_sel_i    (wb_sel_m),
        .m_cyc_i    (wb_cyc_m),
        .m_stb_i    (wb_stb_m),
        .m_ack_o    (wb_ack_m),
        .m_err_o    (wb_err_m),

        .s0_adr_o   (s0_adr_o),
        .s0_dat_o   (s0_dat_o),
        .s0_dat_i   (s0_dat_i),
        .s0_we_o    (s0_we_o),
        .s0_sel_o   (s0_sel_o),
        .s0_cyc_o   (s0_cyc_o),
        .s0_stb_o   (s0_stb_o),
        .s0_ack_i   (s0_ack_i),
        .s0_err_i   (s0_err_i),

        .s1_adr_o   (s1_adr_o),
        .s1_dat_o   (s1_dat_o),
        .s1_dat_i   (s1_dat_i),
        .s1_we_o    (s1_we_o),
        .s1_sel_o   (s1_sel_o),
        .s1_cyc_o   (s1_cyc_o),
        .s1_stb_o   (s1_stb_o),
        .s1_ack_i   (s1_ack_i),
        .s1_err_i   (s1_err_i),

        .s2_adr_o   (s2_adr_o),
        .s2_dat_o   (s2_dat_o),
        .s2_dat_i   (s2_dat_i),
        .s2_we_o    (s2_we_o),
        .s2_sel_o   (s2_sel_o),
        .s2_cyc_o   (s2_cyc_o),
        .s2_stb_o   (s2_stb_o),
        .s2_ack_i   (s2_ack_i),
        .s2_err_i   (s2_err_i),

        .s3_adr_o   (s3_adr_o),
        .s3_dat_o   (s3_dat_o),
        .s3_dat_i   (s3_dat_i),
        .s3_we_o    (s3_we_o),
        .s3_sel_o   (s3_sel_o),
        .s3_cyc_o   (s3_cyc_o),
        .s3_stb_o   (s3_stb_o),
        .s3_ack_i   (s3_ack_i),
        .s3_err_i   (s3_err_i),

        .s4_adr_o   (s4_adr_o),
        .s4_dat_o   (s4_dat_o),
        .s4_dat_i   (s4_dat_i),
        .s4_we_o    (s4_we_o),
        .s4_sel_o   (s4_sel_o),
        .s4_cyc_o   (s4_cyc_o),
        .s4_stb_o   (s4_stb_o),
        .s4_ack_i   (s4_ack_i),
        .s4_err_i   (s4_err_i),

        .s5_adr_o   (s5_adr_o),
        .s5_dat_o   (s5_dat_o),
        .s5_dat_i   (s5_dat_i),
        .s5_we_o    (s5_we_o),
        .s5_sel_o   (s5_sel_o),
        .s5_cyc_o   (s5_cyc_o),
        .s5_stb_o   (s5_stb_o),
        .s5_ack_i   (s5_ack_i),
        .s5_err_i   (s5_err_i)
    );

    // SDRAM slave (s0): connect to real SDRAM controller
    sdram_wb_wrapper u_sdram_wb (
        .clk        (clk),
        .rst        (rst),

        .wb_adr_i   (s0_adr_o),
        .wb_dat_i   (s0_dat_o),
        .wb_dat_o   (s0_dat_i),
        .wb_we_i    (s0_we_o),
        .wb_sel_i   (s0_sel_o),
        .wb_cyc_i   (s0_cyc_o),
        .wb_stb_i   (s0_stb_o),
        .wb_ack_o   (s0_ack_i),
        .wb_err_o   (s0_err_i),

        .sdram_a    (sdram_a),
        .sdram_ba   (sdram_ba),
        .sdram_clk  (sdram_clk),
        .sdram_cke  (sdram_cke),
        .sdram_cs_n (sdram_cs_n),
        .sdram_ras_n(sdram_ras_n),
        .sdram_cas_n(sdram_cas_n),
        .sdram_we_n (sdram_we_n),
        .sdram_dqm  (sdram_dqm),
        .sdram_dq   (sdram_dq)
    );

    // Stub peripherals for now
    assign s1_dat_i = 32'hUART_0000; assign s1_ack_i = s1_cyc_o & s1_stb_o; assign s1_err_i = 1'b0;
    assign s2_dat_i = 32'hI2C0_000;  assign s2_ack_i = s2_cyc_o & s2_stb_o; assign s2_err_i = 1'b0;
    assign s3_dat_i = 32'hSPI0_000;  assign s3_ack_i = s3_cyc_o & s3_stb_o; assign s3_err_i = 1'b0;
    assign s4_dat_i = 32'hGPIO_000;  assign s4_ack_i = s4_cyc_o & s4_stb_o; assign s4_err_i = 1'b0;
    assign s5_dat_i = 32'hJTAG_000;  assign s5_ack_i = s5_cyc_o & s5_stb_o; assign s5_err_i = 1'b0;

endmodule

================================================================================
STEP 5 — QUARTUS: PINS, BUILD, PROGRAM (SRAM-ONLY)
================================================================================

1. Add SDRAM controller RTL to project:
   - In Quartus → Add/Remove Files:
     - ../rtl/cores/opencores_sdram/*.v
     - ../rtl/soc/sdram_wb_wrapper.sv
     - Updated ../rtl/soc/top_soc.sv

2. Pin assignments for SDRAM:
   - Map sdram_* ports in top_soc to the correct DE0-Lite SDRAM pins according
     to the board’s user manual (Terasic pin-out table).
   - Typically:
     - sdram_clk → dedicated SDRAM clock pin.
     - sdram_a[12:0], sdram_ba[1:0], sdram_dq[15:0], sdram_dqm[1:0],
       sdram_cs_n, sdram_ras_n, sdram_cas_n, sdram_we_n, sdram_cke → as per ref.

3. Boot ROM:
   - Ensure bootrom.hex is in the Quartus project directory, or path in boot_rom.sv
     is adjusted.

4. Compile:
   - Processing → Start Compilation.

5. Program SRAM (never flash):
   - Open Quartus Programmer.
   - Mode: JTAG.
   - File: h3_phase1_sc.sof.
   - Check only “Program/Configure”.
   - Click Start.

6. Behavior:
   - Hazard3 boots from ROM at 0x2000_0000 and runs the Phase 1A stub (infinite WFI).
   - Any subsequent C firmware we create can now place .text/.data in SDRAM at
     0x8000_0000, and the bus path is fully real:
       Core → AHB → Bridge → WB → SDRAM controller → SDRAM pins.
   - On power-cycle, board reverts to factory demo image from flash.

================================================================================
WHAT PHASE 1C GIVES YOU TOWARD THE QUAD-CORE GOAL
================================================================================

- A scalable memory architecture:
  - SDRAM as a first-class WB slave under a single AHB→WB gateway.
  - Address map: 0x8000_0000.. for code/data.
- Fully compatible with adding:
  - More Hazard3 tiles (M1..M3).
  - Peripherals behind the same WB fabric (UART/I2C/SPI/GPIO/JTAG-UART).
  - Bootloader that uploads firmware into SDRAM and jumps to 0x8000_0000.

Next natural step is **Phase 1D**:
- Integrate a real OpenCores UART16550 on s1 (0x1000_0000) with a minimal test
  firmware to prove SDRAM + UART together.

##############END Phase 1C################