================================================================================
PHASE 1A: QUAD-CORE-READY SINGLE-HART HAZARD3 SoC SKELETON ON DE0-LITE
(core tile + 4-master-capable AHB interconnect + Boot ROM + top-level)
ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX
================================================================================

GOAL OF PHASE 1A
----------------
Build the minimal but structurally “correct” SoC skeleton that:

- Instantiates ONE Hazard3 core *via a tile wrapper* with HART_ID = 0.
- Uses an AHB interconnect that is architected for up to FOUR masters (M0..M3), but
  currently only connects M0.
- Has a Boot ROM at 0x2000_0000, implemented in BRAM, with contents from bootrom.hex.
- Has a top-level for DE0-Lite that wires clock/reset and exposes *no SDRAM, no UART*
  yet (we’ll add those in later sub-phases).
- Is synthesizable, programmable, and “alive” (core runs and loops in ROM).

From here, all later phases add:
- AHB→WB bridge
- SDRAM, UART, I2C, SPI, GPIO, JTAG-UART
- Bootloader, HAL, firmware
- Extra cores (for dual / quad)

Directory layout for Phase 1A:
- ~/fpga/h3_phase1_sc/
    - rtl/
        - cores/
            - hazard3/           (git clone)
        - soc/
            - hazard3_tile.sv
            - ahb_interconnect_4m.sv
            - boot_rom.sv
            - top_soc.sv
    - quartus/
        - h3_phase1_sc.qpf / .qsf / etc.
- ~/hazard3_fw/
    - bootrom/
        - bootrom.c
        - linker.ld
        - Makefile

================================================================================
STEP 1 — BASIC SETUP (DIRECTORIES + HAZARD3 REPO)
================================================================================

1. Create directories:

   mkdir -p ~/fpga/h3_phase1_sc/rtl/cores
   mkdir -p ~/fpga/h3_phase1_sc/rtl/soc
   mkdir -p ~/fpga/h3_phase1_sc/quartus
   mkdir -p ~/hazard3_fw/bootrom

2. Clone official Hazard3:

   cd ~/fpga/h3_phase1_sc/rtl/cores
   git clone https://github.com/Wren6991/hazard3.git

   You will use the AHB-based core from this repo; the exact module name might differ
   (e.g. hazard3_core, hazard3_cpu, etc.). In hazard3_tile.sv below, adapt instance
   names/ports to match the actual RTL after inspecting the repo.

================================================================================
STEP 2 — BOOT ROM C CODE + LINKER + HEX (PHASE 1A MINIMAL)
================================================================================

We’ll use a very simple ROM program that:
- Defines _start at 0x2000_0000.
- Executes an infinite loop (heartbeat).
- No peripherals yet.

----- FILE: ~/hazard3_fw/bootrom/linker.ld ------------------------------------

ENTRY(_start)

MEMORY
{
  ROM (rx) : ORIGIN = 0x20000000, LENGTH = 16K
}

SECTIONS
{
  .text :
  {
    *(.text.entry)
    *(.text*)
    *(.rodata*)
  } > ROM

  .data :
  {
    *(.data*)
  } > ROM

  .bss :
  {
    *(.bss*)
    *(COMMON)
  } > ROM
}

----- FILE: ~/hazard3_fw/bootrom/bootrom.c ------------------------------------

#include <stdint.h>

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    // Minimal ROM stub for Phase 1A:
    // Just loop forever to prove the core is fetching and executing.
    while (1) {
        __asm__ volatile("wfi");
    }
}

----- FILE: ~/hazard3_fw/bootrom/Makefile -------------------------------------

RISCV_PREFIX = riscv64-unknown-elf-
CC      = $(RISCV_PREFIX)gcc
OBJCOPY = $(RISCV_PREFIX)objcopy

CFLAGS  = -march=rv32imc -mabi=ilp32 -Os -nostdlib -ffreestanding -Wall -Wextra
LDFLAGS = -T linker.ld -nostartfiles -nostdlib

all: bootrom.hex

bootrom.elf: bootrom.c linker.ld
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ bootrom.c

bootrom.hex: bootrom.elf
	$(OBJCOPY) -O verilog $< $@

clean:
	rm -f bootrom.elf bootrom.hex

Build the ROM hex:

   cd ~/hazard3_fw/bootrom
   make

This produces bootrom.hex; you’ll point boot_rom.sv to this file.

================================================================================
STEP 3 — BOOT_ROM RTL (AHB-LITE SLAVE @ 0x2000_0000)
================================================================================

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/boot_rom.sv ---------------------------

module boot_rom
(
    input  wire        clk,
    input  wire        rst,

    // AHB-Lite slave interface (read-only)
    input  wire [31:0] HADDR,
    input  wire [2:0]  HSIZE,
    input  wire [1:0]  HBURST,
    input  wire [1:0]  HTRANS,
    input  wire        HWRITE,
    input  wire [31:0] HWDATA,
    output reg  [31:0] HRDATA,
    output wire        HREADY,
    output wire        HRESP
);

    // 16 KB ROM = 4K words of 32 bits
    localparam ADDR_WIDTH = 12;        // 2^12 = 4096 words
    localparam MEM_DEPTH  = 1 << ADDR_WIDTH;

    reg [31:0] rom [0:MEM_DEPTH-1];

    initial begin
        // expects bootrom.hex in simulation/synthesis directory
        $readmemh("bootrom.hex", rom);
    end

    assign HREADY = 1'b1; // zero-wait read
    assign HRESP  = 1'b0; // OKAY

    // Word-aligned address; ignore HSIZE for now (32-bit accesses)
    wire [ADDR_WIDTH-1:0] word_addr = HADDR[ADDR_WIDTH+1:2];

    always @(posedge clk) begin
        if (HTRANS[1] && !HWRITE) begin
            HRDATA <= rom[word_addr];
        end
    end

endmodule

================================================================================
STEP 4 — HAZARD3 TILE WRAPPER (HART TILE, AHB MASTER)
================================================================================

We wrap a Hazard3 core into a “tile” with:

- HART_ID parameter.
- AHB-Lite master port.
- Separate clk, rst.

You MUST adapt the internal instance to match the actual Hazard3 core’s module
name and ports from the cloned repo (hazard3/rtl/core/…).

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/hazard3_tile.sv -----------------------

module hazard3_tile #(
    parameter integer HART_ID = 0
)(
    input  wire        clk,
    input  wire        rst,

    // AHB-Lite master interface
    output wire [31:0] HADDR,
    output wire [2:0]  HSIZE,
    output wire [1:0]  HBURST,
    output wire [1:0]  HTRANS,
    output wire        HWRITE,
    output wire [31:0] HWDATA,
    input  wire [31:0] HRDATA,
    input  wire        HREADY,
    input  wire        HRESP

    // later: interrupts, debug, etc.
);

    // TODO: adapt this to the actual Hazard3 AHB core module and ports.
    // The following is a schematic example:

    hazard3_core_ahb #(
        .HART_ID(HART_ID)
    ) u_core (
        .clk_i     (clk),
        .rst_i     (rst),

        // AHB master out
        .haddr_o   (HADDR),
        .hsize_o   (HSIZE),
        .hburst_o  (HBURST),
        .htrans_o  (HTRANS),
        .hwrite_o  (HWRITE),
        .hwdata_o  (HWDATA),

        // AHB master in
        .hrdata_i  (HRDATA),
        .hready_i  (HREADY),
        .hresp_i   (HRESP)

        // interrupts, etc. → tie off or connect later
    );

endmodule

NOTE:
- After cloning Hazard3, inspect the source to find the AHB-enabled core wrapper.
- Replace hazard3_core_ahb and the signal names above with the actual ones.

================================================================================
STEP 5 — AHB INTERCONNECT, 4-MASTER CAPABLE (PHASE 1 USES ONLY M0)
================================================================================

We design an AHB-Lite interconnect structured to support up to 4 masters (M0..M3)
and N slaves. For Phase 1A:

- Only M0 is actually driven (from hazard3_tile HART0).
- Only S0 is used (Boot ROM).
- S1..Sx are left to future phases (AHB→WB bridge, etc.).

We’ll implement:
- Simple fixed-priority arbitration M0 > M1 > M2 > M3.
- Single shared bus; slaves see a single “arbiter output” view.
- For now, one slave region: ROM at 0x2000_0000; everything else unmapped.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/ahb_interconnect_4m.sv ----------------

module ahb_interconnect_4m
(
    input  wire        clk,
    input  wire        rst,

    //=====================
    // MASTER PORTS (4x)
    //=====================

    // Master 0
    input  wire [31:0] m0_haddr,
    input  wire [2:0]  m0_hsize,
    input  wire [1:0]  m0_hburst,
    input  wire [1:0]  m0_htrans,
    input  wire        m0_hwrite,
    input  wire [31:0] m0_hwdata,
    output reg  [31:0] m0_hrdata,
    output reg         m0_hready,
    output reg         m0_hresp,

    // Master 1 (unused in Phase 1A)
    input  wire [31:0] m1_haddr,
    input  wire [2:0]  m1_hsize,
    input  wire [1:0]  m1_hburst,
    input  wire [1:0]  m1_htrans,
    input  wire        m1_hwrite,
    input  wire [31:0] m1_hwdata,
    output reg  [31:0] m1_hrdata,
    output reg         m1_hready,
    output reg         m1_hresp,

    // Master 2
    input  wire [31:0] m2_haddr,
    input  wire [2:0]  m2_hsize,
    input  wire [1:0]  m2_hburst,
    input  wire [1:0]  m2_htrans,
    input  wire        m2_hwrite,
    input  wire [31:0] m2_hwdata,
    output reg  [31:0] m2_hrdata,
    output reg         m2_hready,
    output reg         m2_hresp,

    // Master 3
    input  wire [31:0] m3_haddr,
    input  wire [2:0]  m3_hsize,
    input  wire [1:0]  m3_hburst,
    input  wire [1:0]  m3_htrans,
    input  wire        m3_hwrite,
    input  wire [31:0] m3_hwdata,
    output reg  [31:0] m3_hrdata,
    output reg         m3_hready,
    output reg         m3_hresp,

    //=====================
    // SLAVE PORTS (here: 2, but only s0 is used)
    //=====================

    // Slave 0 (Boot ROM at 0x2000_0000)
    output reg  [31:0] s0_haddr,
    output reg  [2:0]  s0_hsize,
    output reg  [1:0]  s0_hburst,
    output reg  [1:0]  s0_htrans,
    output reg         s0_hwrite,
    output reg  [31:0] s0_hwdata,
    input  wire [31:0] s0_hrdata,
    input  wire        s0_hready,
    input  wire        s0_hresp,

    // Slave 1 (future: AHB→WB bridge for SDRAM+periph)
    output reg  [31:0] s1_haddr,
    output reg  [2:0]  s1_hsize,
    output reg  [1:0]  s1_hburst,
    output reg  [1:0]  s1_htrans,
    output reg         s1_hwrite,
    output reg  [31:0] s1_hwdata,
    input  wire [31:0] s1_hrdata,
    input  wire        s1_hready,
    input  wire        s1_hresp
);

    // -------------------------------------------------------------------------
    // ARBITRATION
    // -------------------------------------------------------------------------
    // Simple fixed priority: M0 > M1 > M2 > M3
    // "Request" = HTRANS[1] (NONSEQ or SEQ)
    wire m0_req = m0_htrans[1];
    wire m1_req = m1_htrans[1];
    wire m2_req = m2_htrans[1];
    wire m3_req = m3_htrans[1];

    reg [1:0] grant; // 0..3 = which master is granted

    always @(*) begin
        if (m0_req)      grant = 2'd0;
        else if (m1_req) grant = 2'd1;
        else if (m2_req) grant = 2'd2;
        else if (m3_req) grant = 2'd3;
        else             grant = 2'd0; // default to 0 if idle
    end

    // -------------------------------------------------------------------------
    // MUX MASTER → SHARED BUS VIEW
    // -------------------------------------------------------------------------
    reg [31:0] HADDR_bus;
    reg [2:0]  HSIZE_bus;
    reg [1:0]  HBURST_bus;
    reg [1:0]  HTRANS_bus;
    reg        HWRITE_bus;
    reg [31:0] HWDATA_bus;

    always @(*) begin
        case (grant)
            2'd0: begin
                HADDR_bus  = m0_haddr;
                HSIZE_bus  = m0_hsize;
                HBURST_bus = m0_hburst;
                HTRANS_bus = m0_htrans;
                HWRITE_bus = m0_hwrite;
                HWDATA_bus = m0_hwdata;
            end
            2'd1: begin
                HADDR_bus  = m1_haddr;
                HSIZE_bus  = m1_hsize;
                HBURST_bus = m1_hburst;
                HTRANS_bus = m1_htrans;
                HWRITE_bus = m1_hwrite;
                HWDATA_bus = m1_hwdata;
            end
            2'd2: begin
                HADDR_bus  = m2_haddr;
                HSIZE_bus  = m2_hsize;
                HBURST_bus = m2_hburst;
                HTRANS_bus = m2_htrans;
                HWRITE_bus = m2_hwrite;
                HWDATA_bus = m2_hwdata;
            end
            2'd3: begin
                HADDR_bus  = m3_haddr;
                HSIZE_bus  = m3_hsize;
                HBURST_bus = m3_hburst;
                HTRANS_bus = m3_htrans;
                HWRITE_bus = m3_hwrite;
                HWDATA_bus = m3_hwdata;
            end
            default: begin
                HADDR_bus  = 32'h0000_0000;
                HSIZE_bus  = 3'b010;
                HBURST_bus = 2'b00;
                HTRANS_bus = 2'b00;
                HWRITE_bus = 1'b0;
                HWDATA_bus = 32'h0000_0000;
            end
        endcase
    end

    // -------------------------------------------------------------------------
    // ADDRESS DECODE (ROM vs future-periph)
    // -------------------------------------------------------------------------
    // ROM at 0x2000_0000 (e.g. match upper nibble 0x2)
    wire sel_s0 = (HADDR_bus[31:28] == 4'h2);
    wire sel_s1 = !sel_s0; // everything else to slave 1 for now

    always @(*) begin
        // defaults
        s0_haddr  = 32'h0;
        s0_hsize  = 3'b010;
        s0_hburst = 2'b00;
        s0_htrans = 2'b00;
        s0_hwrite = 1'b0;
        s0_hwdata = 32'h0;

        s1_haddr  = 32'h0;
        s1_hsize  = 3'b010;
        s1_hburst = 2'b00;
        s1_htrans = 2'b00;
        s1_hwrite = 1'b0;
        s1_hwdata = 32'h0;

        if (sel_s0) begin
            s0_haddr  = HADDR_bus;
            s0_hsize  = HSIZE_bus;
            s0_hburst = HBURST_bus;
            s0_htrans = HTRANS_bus;
            s0_hwrite = HWRITE_bus;
            s0_hwdata = HWDATA_bus;
        end else begin
            s1_haddr  = HADDR_bus;
            s1_hsize  = HSIZE_bus;
            s1_hburst = HBURST_bus;
            s1_htrans = HTRANS_bus;
            s1_hwrite = HWRITE_bus;
            s1_hwdata = HWDATA_bus;
        end
    end

    // -------------------------------------------------------------------------
    // RETURN DATA/READY/RESP TO THE GRANTED MASTER
    // -------------------------------------------------------------------------
    wire [31:0] HRDATA_bus = sel_s0 ? s0_hrdata : s1_hrdata;
    wire        HREADY_bus = sel_s0 ? s0_hready : s1_hready;
    wire        HRESP_bus  = sel_s0 ? s0_hresp  : s1_hresp;

    always @(*) begin
        // default all masters to idle OKAY
        m0_hrdata = 32'h0;
        m0_hready = 1'b1;
        m0_hresp  = 1'b0;

        m1_hrdata = 32'h0;
        m1_hready = 1'b1;
        m1_hresp  = 1'b0;

        m2_hrdata = 32'h0;
        m2_hready = 1'b1;
        m2_hresp  = 1'b0;

        m3_hrdata = 32'h0;
        m3_hready = 1'b1;
        m3_hresp  = 1'b0;

        case (grant)
            2'd0: begin
                m0_hrdata = HRDATA_bus;
                m0_hready = HREADY_bus;
                m0_hresp  = HRESP_bus;
            end
            2'd1: begin
                m1_hrdata = HRDATA_bus;
                m1_hready = HREADY_bus;
                m1_hresp  = HRESP_bus;
            end
            2'd2: begin
                m2_hrdata = HRDATA_bus;
                m2_hready = HREADY_bus;
                m2_hresp  = HRESP_bus;
            end
            2'd3: begin
                m3_hrdata = HRDATA_bus;
                m3_hready = HREADY_bus;
                m3_hresp  = HRESP_bus;
            end
        endcase
    end

endmodule

NOTES:
- In Phase 1A, we will:
  - Connect only M0 to hazard3_tile HART0.
  - Leave M1..M3 unconnected or tied off.
  - Connect S0 to boot_rom.
  - Tie S1 to a dummy “error slave” that returns error or zero (simple stub).

================================================================================
STEP 6 — TOP-LEVEL FOR DE0-LITE (MINIMAL, NO PERIPHERALS YET)
================================================================================

We now define a minimal top-level that:

- Instantiates one hazard3_tile with HART_ID=0.
- Instantiates ahb_interconnect_4m.
- Instantiates boot_rom.
- Exposes only clock and reset pins for now (we’ll add IO in later phases).

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv ----------------------------

module top_soc
(
    input  wire clk_50,   // 50 MHz clock from DE0-Lite
    input  wire reset_n   // active-low reset (pushbutton)
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    //======================
    // AHB master signals from HART0 tile (M0)
    //======================
    wire [31:0] m0_haddr;
    wire [2:0]  m0_hsize;
    wire [1:0]  m0_hburst;
    wire [1:0]  m0_htrans;
    wire        m0_hwrite;
    wire [31:0] m0_hwdata;
    wire [31:0] m0_hrdata;
    wire        m0_hready;
    wire        m0_hresp;

    // M1..M3 unconnected in Phase 1A
    wire [31:0] m1_haddr = 32'h0;
    wire [2:0]  m1_hsize = 3'b010;
    wire [1:0]  m1_hburst = 2'b00;
    wire [1:0]  m1_htrans = 2'b00;
    wire        m1_hwrite = 1'b0;
    wire [31:0] m1_hwdata = 32'h0;
    wire [31:0] m1_hrdata;
    wire        m1_hready;
    wire        m1_hresp;

    wire [31:0] m2_haddr = 32'h0;
    wire [2:0]  m2_hsize = 3'b010;
    wire [1:0]  m2_hburst = 2'b00;
    wire [1:0]  m2_htrans = 2'b00;
    wire        m2_hwrite = 1'b0;
    wire [31:0] m2_hwdata = 32'h0;
    wire [31:0] m2_hrdata;
    wire        m2_hready;
    wire        m2_hresp;

    wire [31:0] m3_haddr = 32'h0;
    wire [2:0]  m3_hsize = 3'b010;
    wire [1:0]  m3_hburst = 2'b00;
    wire [1:0]  m3_htrans = 2'b00;
    wire        m3_hwrite = 1'b0;
    wire [31:0] m3_hwdata = 32'h0;
    wire [31:0] m3_hrdata;
    wire        m3_hready;
    wire        m3_hresp;

    //======================
    // Slave 0 = boot ROM
    // Slave 1 = dummy error slave (for Phase 1A)
    //======================
    wire [31:0] s0_haddr, s1_haddr;
    wire [2:0]  s0_hsize, s1_hsize;
    wire [1:0]  s0_hburst, s1_hburst;
    wire [1:0]  s0_htrans, s1_htrans;
    wire        s0_hwrite, s1_hwrite;
    wire [31:0] s0_hwdata, s1_hwdata;
    wire [31:0] s0_hrdata, s1_hrdata;
    wire        s0_hready, s1_hready;
    wire        s0_hresp,  s1_hresp;

    // HART0 tile
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m0_haddr),
        .HSIZE  (m0_hsize),
        .HBURST (m0_hburst),
        .HTRANS (m0_htrans),
        .HWRITE (m0_hwrite),
        .HWDATA (m0_hwdata),
        .HRDATA (m0_hrdata),
        .HREADY (m0_hready),
        .HRESP  (m0_hresp)
    );

    // AHB interconnect, 4 masters, 2 slaves
    ahb_interconnect_4m u_ahb_ic (
        .clk        (clk),
        .rst        (rst),

        // M0
        .m0_haddr   (m0_haddr),
        .m0_hsize   (m0_hsize),
        .m0_hburst  (m0_hburst),
        .m0_htrans  (m0_htrans),
        .m0_hwrite  (m0_hwrite),
        .m0_hwdata  (m0_hwdata),
        .m0_hrdata  (m0_hrdata),
        .m0_hready  (m0_hready),
        .m0_hresp   (m0_hresp),

        // M1..M3 (unused)
        .m1_haddr   (m1_haddr),
        .m1_hsize   (m1_hsize),
        .m1_hburst  (m1_hburst),
        .m1_htrans  (m1_htrans),
        .m1_hwrite  (m1_hwrite),
        .m1_hwdata  (m1_hwdata),
        .m1_hrdata  (m1_hrdata),
        .m1_hready  (m1_hready),
        .m1_hresp   (m1_hresp),

        .m2_haddr   (m2_haddr),
        .m2_hsize   (m2_hsize),
        .m2_hburst  (m2_hburst),
        .m2_htrans  (m2_htrans),
        .m2_hwrite  (m2_hwrite),
        .m2_hwdata  (m2_hwdata),
        .m2_hrdata  (m2_hrdata),
        .m2_hready  (m2_hready),
        .m2_hresp   (m2_hresp),

        .m3_haddr   (m3_haddr),
        .m3_hsize   (m3_hsize),
        .m3_hburst  (m3_hburst),
        .m3_htrans  (m3_htrans),
        .m3_hwrite  (m3_hwrite),
        .m3_hwdata  (m3_hwdata),
        .m3_hrdata  (m3_hrdata),
        .m3_hready  (m3_hready),
        .m3_hresp   (m3_hresp),

        // Slave 0 = ROM
        .s0_haddr   (s0_haddr),
        .s0_hsize   (s0_hsize),
        .s0_hburst  (s0_hburst),
        .s0_htrans  (s0_htrans),
        .s0_hwrite  (s0_hwrite),
        .s0_hwdata  (s0_hwdata),
        .s0_hrdata  (s0_hrdata),
        .s0_hready  (s0_hready),
        .s0_hresp   (s0_hresp),

        // Slave 1 = dummy
        .s1_haddr   (s1_haddr),
        .s1_hsize   (s1_hsize),
        .s1_hburst  (s1_hburst),
        .s1_htrans  (s1_htrans),
        .s1_hwrite  (s1_hwrite),
        .s1_hwdata  (s1_hwdata),
        .s1_hrdata  (s1_hrdata),
        .s1_hready  (s1_hready),
        .s1_hresp   (s1_hresp)
    );

    // Boot ROM at 0x2000_0000
    boot_rom u_boot_rom (
        .clk    (clk),
        .rst    (rst),
        .HADDR  (s0_haddr),
        .HSIZE  (s0_hsize),
        .HBURST (s0_hburst),
        .HTRANS (s0_htrans),
        .HWRITE (s0_hwrite),
        .HWDATA (s0_hwdata),
        .HRDATA (s0_hrdata),
        .HREADY (s0_hready),
        .HRESP  (s0_hresp)
    );

    // Dummy slave 1: always ready, returns 0, OKAY
    assign s1_hrdata = 32'hDEAD_DEAD;
    assign s1_hready = 1'b1;
    assign s1_hresp  = 1'b0;

endmodule

================================================================================
STEP 7 — QUARTUS PROJECT (PHASE 1A) AND BRING-UP
================================================================================

1. Create Quartus project:

   cd ~/fpga/h3_phase1_sc/quartus
   quartus &

   - New Project Wizard:
     - Directory: ~/fpga/h3_phase1_sc/quartus
     - Name: h3_phase1_sc
     - Top-level entity: top_soc
   - Device: MAX 10 → 10M50DAF484C7G (DE0-Lite)

2. Add RTL files:
   - Project → Add/Remove Files in Project:
     - ../rtl/soc/top_soc.sv
     - ../rtl/soc/hazard3_tile.sv
     - ../rtl/soc/ahb_interconnect_4m.sv
     - ../rtl/soc/boot_rom.sv
     - All relevant Hazard3 core files from ../rtl/cores/hazard3/rtl/...
   - Make sure SystemVerilog (.sv) is enabled where needed.

3. Boot ROM hex:
   - Copy bootrom.hex into the Quartus project directory (or adjust relative
     path in boot_rom.sv to point to ../../hazard3_fw/bootrom/bootrom.hex).
   - Quartus must see bootrom.hex at compile time.

4. Pin assignments (minimal for Phase 1A):
   - clk_50: assign to the DE0-Lite 50 MHz pin (per board manual).
   - reset_n: assign to a pushbutton (e.g. KEY0).
   - No other pins needed yet.

5. Compile:
   - Processing → Start Compilation.
   - If there are missing module names/ports:
     - Fix hazard3_tile.sv to match the actual Hazard3 core wrapper.
     - Ensure all Hazard3 RTL files are included.

6. Program DE0-Lite:
   - Open Quartus Programmer (quartus_pgmw).
   - Hardware Setup → select USB-Blaster.
   - Add h3_phase1_sc.sof from output_files/.
   - Check “Program/Configure”.
   - Click Start.

7. After programming:
   - The Hazard3 core (HART0) begins executing at 0x2000_0000 (Boot ROM).
   - It runs _start(), which loops and executes WFI.
   - From the outside, nothing visible happens yet — but the SoC is structurally
     correct, and the CPU is alive and fetching from ROM.

================================================================================
WHAT PHASE 1A HAS ACHIEVED (QUAD-CORE FUTURE IN MIND)
================================================================================

- You now have a **single-hart Hazard3 SoC skeleton** with:
  - A HART tile abstraction (`hazard3_tile`) with HART_ID.
  - A **4-master-capable** AHB interconnect (`ahb_interconnect_4m`) that will
    easily scale to dual/quad core by adding more tiles and connecting M1..M3.
  - A Boot ROM subsystem at 0x2000_0000 using bootrom.hex.
  - A minimal top-level for DE0-Lite that compiles and runs.

- This is a **clean base** for:
  - Phase 1B: AHB→Wishbone bridge + Wishbone interconnect.
  - Phase 1C+: SDRAM, UART, I2C, SPI, GPIO, JTAG-UART, bootloader, HAL.
  - Phase 2: dual-core bring-up.
  - Phase 3: quad-core with core control and hart coordination.
№############END PHASE1_A################

================================================================================
PHASE 1B: AHB→WISHBONE BRIDGE + WISHBONE FABRIC SHELL (QUAD-CORE-READY)
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH PROGRAMMING)
================================================================================

GOAL OF PHASE 1B
----------------
Extend the Phase 1A SoC skeleton to introduce the full bus hierarchy:

- KEEP:
  - Hazard3 tile (HART0) as AHB master M0.
  - 4-master-capable AHB interconnect (M0..M3, S0=Boot ROM).
  - Boot ROM @ 0x2000_0000, with bootrom.hex.
  - top_soc.sv structure and DE0-Lite top-level.

- ADD in Phase 1B:
  - AHB→Wishbone bridge (burst-aware, but we can treat it as single-beat for now).
  - Wishbone fabric with address decode for:
    - SDRAM @ 0x8000_0000 (future Phase 1C).
    - UART0 @ 0x1000_0000 (future 1D).
    - I2C0 @ 0x1000_0100 (future 1E).
    - SPI0 @ 0x1000_0200 (future 1F).
    - GPIO @ 0x1000_0300 (future 1G).
    - JTAG-UART @ 0x1000_0500 (future 1H).
  - Stub Wishbone slaves for now (return fixed data, OKAY).

NOTES:
- STILL: We only ever program .sof via JTAG → SRAM. No .pof, no flash. On power-cycle
  the DE0-Lite returns to its factory image.
- This phase is about bus structure, NOT functionality. All peripherals are stubs.

Directory context:

- ~/fpga/h3_phase1_sc/rtl/soc/
    - hazard3_tile.sv              (from 1A)
    - ahb_interconnect_4m.sv       (from 1A)
    - boot_rom.sv                  (from 1A)
    - top_soc.sv                   (UPDATED in 1B)
    - ahb_to_wb_bridge.sv          (NEW)
    - wb_interconnect.sv           (NEW)

================================================================================
STEP 1 — AHB→WISHBONE BRIDGE (SINGLE-BEAT, BURST-CAPABLE STRUCTURE)
================================================================================

We design a simple AHB-Lite slave → Wishbone master bridge:

- AHB slave interface:
  - Responds to reads/writes in the 0x1000_0000–0x8FFF_FFFF region.
- Wishbone master interface:
  - Issues a single Wishbone cycle per AHB transfer (Phase 1B).
- Later we can extend it to actually use HBURST for bursts, but the interface will
  already be correct.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/ahb_to_wb_bridge.sv -------------------

module ahb_to_wb_bridge
(
    input  wire        clk,
    input  wire        rst,

    // AHB-Lite slave interface
    input  wire [31:0] HADDR,
    input  wire [2:0]  HSIZE,
    input  wire [1:0]  HBURST,
    input  wire [1:0]  HTRANS,
    input  wire        HWRITE,
    input  wire [31:0] HWDATA,
    output reg  [31:0] HRDATA,
    output reg         HREADY,
    output reg         HRESP,

    // Wishbone master interface
    output reg  [31:0] wb_adr_o,
    output reg  [31:0] wb_dat_o,
    input  wire [31:0] wb_dat_i,
    output reg         wb_we_o,
    output reg  [3:0]  wb_sel_o,
    output reg         wb_cyc_o,
    output reg         wb_stb_o,
    input  wire        wb_ack_i,
    input  wire        wb_err_i
);

    // Simple FSM: IDLE → WB_CYCLE → DONE
    localparam ST_IDLE  = 2'd0;
    localparam ST_WB    = 2'd1;
    localparam ST_RESP  = 2'd2;

    reg [1:0] state, next_state;

    // Latched AHB request info
    reg [31:0] lat_addr;
    reg [31:0] lat_wdata;
    reg        lat_write;
    reg [3:0]  lat_sel;

    wire ahb_valid = HTRANS[1]; // NONSEQ or SEQ

    // Derive byte enables from HSIZE and address (simplified: assume 32-bit)
    // For now we just treat all accesses as 32-bit word.
    wire [3:0] ahb_sel = 4'b1111;

    // FSM
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= ST_IDLE;
        end else begin
            state <= next_state;
        end
    end

    always @(*) begin
        next_state = state;
        case (state)
            ST_IDLE: begin
                if (ahb_valid) begin
                    next_state = ST_WB;
                end
            end
            ST_WB: begin
                if (wb_ack_i || wb_err_i) begin
                    next_state = ST_RESP;
                end
            end
            ST_RESP: begin
                next_state = ST_IDLE;
            end
        endcase
    end

    // Latch AHB request on first valid transfer
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            lat_addr  <= 32'h0;
            lat_wdata <= 32'h0;
            lat_write <= 1'b0;
            lat_sel   <= 4'b0000;
        end else begin
            if (state == ST_IDLE && ahb_valid) begin
                lat_addr  <= HADDR;
                lat_wdata <= HWDATA;
                lat_write <= HWRITE;
                lat_sel   <= ahb_sel;
            end
        end
    end

    // Drive Wishbone signals
    always @(*) begin
        wb_adr_o = 32'h0;
        wb_dat_o = 32'h0;
        wb_we_o  = 1'b0;
        wb_sel_o = 4'b0000;
        wb_cyc_o = 1'b0;
        wb_stb_o = 1'b0;

        case (state)
            ST_WB: begin
                wb_adr_o = lat_addr;
                wb_dat_o = lat_wdata;
                wb_we_o  = lat_write;
                wb_sel_o = lat_sel;
                wb_cyc_o = 1'b1;
                wb_stb_o = 1'b1;
            end
            default: begin
                // IDLE / RESP → no WB cycle
            end
        endcase
    end

    // AHB response
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            HRDATA <= 32'h0;
            HREADY <= 1'b1;
            HRESP  <= 1'b0;
        end else begin
            case (state)
                ST_IDLE: begin
                    HREADY <= 1'b1; // ready for new transfer
                    HRESP  <= 1'b0;
                end
                ST_WB: begin
                    HREADY <= 1'b0; // wait for WB
                    HRESP  <= 1'b0;
                end
                ST_RESP: begin
                    HREADY <= 1'b1;
                    HRESP  <= wb_err_i ? 1'b1 : 1'b0;
                    HRDATA <= wb_dat_i;
                end
            endcase
        end
    end

endmodule

================================================================================
STEP 2 — WISHBONE INTERCONNECT SHELL (6 SLAVES, ALL STUBS FOR NOW)
================================================================================

We now define a single-master, multi-slave Wishbone interconnect:

- Single master: output of ahb_to_wb_bridge.
- Slaves:
  - s0: SDRAM     @ 0x8000_0000–0x8FFF_FFFF (Phase 1C).
  - s1: UART0     @ 0x1000_0000–0x1000_00FF.
  - s2: I2C0      @ 0x1000_0100–0x1000_01FF.
  - s3: SPI0      @ 0x1000_0200–0x1000_02FF.
  - s4: GPIO      @ 0x1000_0300–0x1000_03FF.
  - s5: JTAG-UART @ 0x1000_0500–0x1000_05FF.

In Phase 1B:
- Each slave is a stub: always ACK, returns fixed data, no error.
- In later phases we replace those stubs with real IP instances.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/wb_interconnect.sv --------------------

module wb_interconnect
(
    input  wire        clk,
    input  wire        rst,

    // Master interface
    input  wire [31:0] m_adr_i,
    input  wire [31:0] m_dat_i,
    output reg  [31:0] m_dat_o,
    input  wire        m_we_i,
    input  wire [3:0]  m_sel_i,
    input  wire        m_cyc_i,
    input  wire        m_stb_i,
    output reg         m_ack_o,
    output reg         m_err_o,

    // Slave 0: SDRAM
    output reg  [31:0] s0_adr_o,
    output reg  [31:0] s0_dat_o,
    input  wire [31:0] s0_dat_i,
    output reg         s0_we_o,
    output reg  [3:0]  s0_sel_o,
    output reg         s0_cyc_o,
    output reg         s0_stb_o,
    input  wire        s0_ack_i,
    input  wire        s0_err_i,

    // Slave 1: UART0
    output reg  [31:0] s1_adr_o,
    output reg  [31:0] s1_dat_o,
    input  wire [31:0] s1_dat_i,
    output reg         s1_we_o,
    output reg  [3:0]  s1_sel_o,
    output reg         s1_cyc_o,
    output reg         s1_stb_o,
    input  wire        s1_ack_i,
    input  wire        s1_err_i,

    // Slave 2: I2C0
    output reg  [31:0] s2_adr_o,
    output reg  [31:0] s2_dat_o,
    input  wire [31:0] s2_dat_i,
    output reg         s2_we_o,
    output reg  [3:0]  s2_sel_o,
    output reg         s2_cyc_o,
    output reg         s2_stb_o,
    input  wire        s2_ack_i,
    input  wire        s2_err_i,

    // Slave 3: SPI0
    output reg  [31:0] s3_adr_o,
    output reg  [31:0] s3_dat_o,
    input  wire [31:0] s3_dat_i,
    output reg         s3_we_o,
    output reg  [3:0]  s3_sel_o,
    output reg         s3_cyc_o,
    output reg         s3_stb_o,
    input  wire        s3_ack_i,
    input  wire        s3_err_i,

    // Slave 4: GPIO
    output reg  [31:0] s4_adr_o,
    output reg  [31:0] s4_dat_o,
    input  wire [31:0] s4_dat_i,
    output reg         s4_we_o,
    output reg  [3:0]  s4_sel_o,
    output reg         s4_cyc_o,
    output reg         s4_stb_o,
    input  wire        s4_ack_i,
    input  wire        s4_err_i,

    // Slave 5: JTAG-UART
    output reg  [31:0] s5_adr_o,
    output reg  [31:0] s5_dat_o,
    input  wire [31:0] s5_dat_i,
    output reg         s5_we_o,
    output reg  [3:0]  s5_sel_o,
    output reg         s5_cyc_o,
    output reg         s5_stb_o,
    input  wire        s5_ack_i,
    input  wire        s5_err_i
);

    // Address decode
    // s0: SDRAM region >= 0x8000_0000
    wire sel_s0 = (m_adr_i[31:28] == 4'h8);

    // s1..s5: peripheral regions
    wire sel_s1 = (m_adr_i[31:8] == 24'h100000); // 0x1000_0000 - 0x1000_00FF
    wire sel_s2 = (m_adr_i[31:8] == 24'h100001); // 0x1000_0100 - 0x1000_01FF
    wire sel_s3 = (m_adr_i[31:8] == 24'h100002); // 0x1000_0200 - 0x1000_02FF
    wire sel_s4 = (m_adr_i[31:8] == 24'h100003); // 0x1000_0300 - 0x1000_03FF
    wire sel_s5 = (m_adr_i[31:8] == 24'h100005); // 0x1000_0500 - 0x1000_05FF

    // default: no slave → error
    wire no_slave = !(sel_s0 | sel_s1 | sel_s2 | sel_s3 | sel_s4 | sel_s5);

    // Drive slaves based on select
    always @(*) begin
        // default all slaves inactive
        s0_adr_o = 32'h0; s0_dat_o = 32'h0; s0_we_o = 1'b0; s0_sel_o = 4'b0000; s0_cyc_o = 1'b0; s0_stb_o = 1'b0;
        s1_adr_o = 32'h0; s1_dat_o = 32'h0; s1_we_o = 1'b0; s1_sel_o = 4'b0000; s1_cyc_o = 1'b0; s1_stb_o = 1'b0;
        s2_adr_o = 32'h0; s2_dat_o = 32'h0; s2_we_o = 1'b0; s2_sel_o = 4'b0000; s2_cyc_o = 1'b0; s2_stb_o = 1'b0;
        s3_adr_o = 32'h0; s3_dat_o = 32'h0; s3_we_o = 1'b0; s3_sel_o = 4'b0000; s3_cyc_o = 1'b0; s3_stb_o = 1'b0;
        s4_adr_o = 32'h0; s4_dat_o = 32'h0; s4_we_o = 1'b0; s4_sel_o = 4'b0000; s4_cyc_o = 1'b0; s4_stb_o = 1'b0;
        s5_adr_o = 32'h0; s5_dat_o = 32'h0; s5_we_o = 1'b0; s5_sel_o = 4'b0000; s5_cyc_o = 1'b0; s5_stb_o = 1'b0;

        if (m_cyc_i && m_stb_i) begin
            if (sel_s0) begin
                s0_adr_o = m_adr_i;
                s0_dat_o = m_dat_i;
                s0_we_o  = m_we_i;
                s0_sel_o = m_sel_i;
                s0_cyc_o = 1'b1;
                s0_stb_o = 1'b1;
            end else if (sel_s1) begin
                s1_adr_o = m_adr_i;
                s1_dat_o = m_dat_i;
                s1_we_o  = m_we_i;
                s1_sel_o = m_sel_i;
                s1_cyc_o = 1'b1;
                s1_stb_o = 1'b1;
            end else if (sel_s2) begin
                s2_adr_o = m_adr_i;
                s2_dat_o = m_dat_i;
                s2_we_o  = m_we_i;
                s2_sel_o = m_sel_i;
                s2_cyc_o = 1'b1;
                s2_stb_o = 1'b1;
            end else if (sel_s3) begin
                s3_adr_o = m_adr_i;
                s3_dat_o = m_dat_i;
                s3_we_o  = m_we_i;
                s3_sel_o = m_sel_i;
                s3_cyc_o = 1'b1;
                s3_stb_o = 1'b1;
            end else if (sel_s4) begin
                s4_adr_o = m_adr_i;
                s4_dat_o = m_dat_i;
                s4_we_o  = m_we_i;
                s4_sel_o = m_sel_i;
                s4_cyc_o = 1'b1;
                s4_stb_o = 1'b1;
            end else if (sel_s5) begin
                s5_adr_o = m_adr_i;
                s5_dat_o = m_dat_i;
                s5_we_o  = m_we_i;
                s5_sel_o = m_sel_i;
                s5_cyc_o = 1'b1;
                s5_stb_o = 1'b1;
            end
        end
    end

    // Return data/ack/err to master
    always @(*) begin
        m_dat_o = 32'h0;
        m_ack_o = 1'b0;
        m_err_o = 1'b0;

        if (m_cyc_i && m_stb_i) begin
            if (sel_s0) begin
                m_dat_o = s0_dat_i;
                m_ack_o = s0_ack_i;
                m_err_o = s0_err_i;
            end else if (sel_s1) begin
                m_dat_o = s1_dat_i;
                m_ack_o = s1_ack_i;
                m_err_o = s1_err_i;
            end else if (sel_s2) begin
                m_dat_o = s2_dat_i;
                m_ack_o = s2_ack_i;
                m_err_o = s2_err_i;
            end else if (sel_s3) begin
                m_dat_o = s3_dat_i;
                m_ack_o = s3_ack_i;
                m_err_o = s3_err_i;
            end else if (sel_s4) begin
                m_dat_o = s4_dat_i;
                m_ack_o = s4_ack_i;
                m_err_o = s4_err_i;
            end else if (sel_s5) begin
                m_dat_o = s5_dat_i;
                m_ack_o = s5_ack_i;
                m_err_o = s5_err_i;
            end else if (no_slave) begin
                m_dat_o = 32'hBAD0_0000;
                m_ack_o = 1'b1;
                m_err_o = 1'b1;
            end
        end
    end

endmodule

================================================================================
STEP 3 — TOP-LEVEL UPDATE: CONNECT AHB→WB BRIDGE + WB INTERCONNECT + STUB SLAVES
================================================================================

Now we update top_soc.sv to:

- Hook up AHB slave 1 (previous dummy) to ahb_to_wb_bridge.
- Hook the bridge’s Wishbone master to wb_interconnect.
- Instantiate stub Wishbone slaves for SDRAM, UART, I2C, SPI, GPIO, JTAG-UART.

NOTE:
- You REPLACE the old dummy S1 logic in top_soc.sv with the new bridge+WB fabric.
- The rest (HART0 tile, AHB interconnect, Boot ROM) remains as in Phase 1A.

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv -------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    //======================
    // AHB master signals from HART0 tile (M0)
    //======================
    wire [31:0] m0_haddr;
    wire [2:0]  m0_hsize;
    wire [1:0]  m0_hburst;
    wire [1:0]  m0_htrans;
    wire        m0_hwrite;
    wire [31:0] m0_hwdata;
    wire [31:0] m0_hrdata;
    wire        m0_hready;
    wire        m0_hresp;

    // M1..M3 unused
    wire [31:0] m1_haddr = 32'h0;
    wire [2:0]  m1_hsize = 3'b010;
    wire [1:0]  m1_hburst = 2'b00;
    wire [1:0]  m1_htrans = 2'b00;
    wire        m1_hwrite = 1'b0;
    wire [31:0] m1_hwdata = 32'h0;
    wire [31:0] m1_hrdata;
    wire        m1_hready;
    wire        m1_hresp;

    wire [31:0] m2_haddr = 32'h0;
    wire [2:0]  m2_hsize = 3'b010;
    wire [1:0]  m2_hburst = 2'b00;
    wire [1:0]  m2_htrans = 2'b00;
    wire        m2_hwrite = 1'b0;
    wire [31:0] m2_hwdata = 32'h0;
    wire [31:0] m2_hrdata;
    wire        m2_hready;
    wire        m2_hresp;

    wire [31:0] m3_haddr = 32'h0;
    wire [2:0]  m3_hsize = 3'b010;
    wire [1:0]  m3_hburst = 2'b00;
    wire [1:0]  m3_htrans = 2'b00;
    wire        m3_hwrite = 1'b0;
    wire [31:0] m3_hwdata = 32'h0;
    wire [31:0] m3_hrdata;
    wire        m3_hready;
    wire        m3_hresp;

    // Slave 0: Boot ROM
    wire [31:0] s0_haddr, s1_haddr;
    wire [2:0]  s0_hsize, s1_hsize;
    wire [1:0]  s0_hburst, s1_hburst;
    wire [1:0]  s0_htrans, s1_htrans;
    wire        s0_hwrite, s1_hwrite;
    wire [31:0] s0_hwdata, s1_hwdata;
    wire [31:0] s0_hrdata, s1_hrdata;
    wire        s0_hready, s1_hready;
    wire        s0_hresp,  s1_hresp;

    // HART0 tile
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m0_haddr),
        .HSIZE  (m0_hsize),
        .HBURST (m0_hburst),
        .HTRANS (m0_htrans),
        .HWRITE (m0_hwrite),
        .HWDATA (m0_hwdata),
        .HRDATA (m0_hrdata),
        .HREADY (m0_hready),
        .HRESP  (m0_hresp)
    );

    // AHB interconnect
    ahb_interconnect_4m u_ahb_ic (
        .clk        (clk),
        .rst        (rst),

        .m0_haddr   (m0_haddr),
        .m0_hsize   (m0_hsize),
        .m0_hburst  (m0_hburst),
        .m0_htrans  (m0_htrans),
        .m0_hwrite  (m0_hwrite),
        .m0_hwdata  (m0_hwdata),
        .m0_hrdata  (m0_hrdata),
        .m0_hready  (m0_hready),
        .m0_hresp   (m0_hresp),

        .m1_haddr   (m1_haddr),
        .m1_hsize   (m1_hsize),
        .m1_hburst  (m1_hburst),
        .m1_htrans  (m1_htrans),
        .m1_hwrite  (m1_hwrite),
        .m1_hwdata  (m1_hwdata),
        .m1_hrdata  (m1_hrdata),
        .m1_hready  (m1_hready),
        .m1_hresp   (m1_hresp),

        .m2_haddr   (m2_haddr),
        .m2_hsize   (m2_hsize),
        .m2_hburst  (m2_hburst),
        .m2_htrans  (m2_htrans),
        .m2_hwrite  (m2_hwrite),
        .m2_hwdata  (m2_hwdata),
        .m2_hrdata  (m2_hrdata),
        .m2_hready  (m2_hready),
        .m2_hresp   (m2_hresp),

        .m3_haddr   (m3_haddr),
        .m3_hsize   (m3_hsize),
        .m3_hburst  (m3_hburst),
        .m3_htrans  (m3_htrans),
        .m3_hwrite  (m3_hwrite),
        .m3_hwdata  (m3_hwdata),
        .m3_hrdata  (m3_hrdata),
        .m3_hready  (m3_hready),
        .m3_hresp   (m3_hresp),

        .s0_haddr   (s0_haddr),
        .s0_hsize   (s0_hsize),
        .s0_hburst  (s0_hburst),
        .s0_htrans  (s0_htrans),
        .s0_hwrite  (s0_hwrite),
        .s0_hwdata  (s0_hwdata),
        .s0_hrdata  (s0_hrdata),
        .s0_hready  (s0_hready),
        .s0_hresp   (s0_hresp),

        .s1_haddr   (s1_haddr),
        .s1_hsize   (s1_hsize),
        .s1_hburst  (s1_hburst),
        .s1_htrans  (s1_htrans),
        .s1_hwrite  (s1_hwrite),
        .s1_hwdata  (s1_hwdata),
        .s1_hrdata  (s1_hrdata),
        .s1_hready  (s1_hready),
        .s1_hresp   (s1_hresp)
    );

    // Boot ROM
    boot_rom u_boot_rom (
        .clk    (clk),
        .rst    (rst),
        .HADDR  (s0_haddr),
        .HSIZE  (s0_hsize),
        .HBURST (s0_hburst),
        .HTRANS (s0_htrans),
        .HWRITE (s0_hwrite),
        .HWDATA (s0_hwdata),
        .HRDATA (s0_hrdata),
        .HREADY (s0_hready),
        .HRESP  (s0_hresp)
    );

    // AHB→Wishbone bridge on slave 1
    wire [31:0] wb_adr_m;
    wire [31:0] wb_dat_o_m;
    wire [31:0] wb_dat_i_m;
    wire        wb_we_m;
    wire [3:0]  wb_sel_m;
    wire        wb_cyc_m;
    wire        wb_stb_m;
    wire        wb_ack_m;
    wire        wb_err_m;

    ahb_to_wb_bridge u_ahb2wb (
        .clk        (clk),
        .rst        (rst),

        .HADDR      (s1_haddr),
        .HSIZE      (s1_hsize),
        .HBURST     (s1_hburst),
        .HTRANS     (s1_htrans),
        .HWRITE     (s1_hwrite),
        .HWDATA     (s1_hwdata),
        .HRDATA     (s1_hrdata),
        .HREADY     (s1_hready),
        .HRESP      (s1_hresp),

        .wb_adr_o   (wb_adr_m),
        .wb_dat_o   (wb_dat_o_m),
        .wb_dat_i   (wb_dat_i_m),
        .wb_we_o    (wb_we_m),
        .wb_sel_o   (wb_sel_m),
        .wb_cyc_o   (wb_cyc_m),
        .wb_stb_o   (wb_stb_m),
        .wb_ack_i   (wb_ack_m),
        .wb_err_i   (wb_err_m)
    );

    // Wishbone interconnect and stub slaves
    wire [31:0] s0_dat_i, s1_dat_i, s2_dat_i, s3_dat_i, s4_dat_i, s5_dat_i;
    wire        s0_ack_i, s1_ack_i, s2_ack_i, s3_ack_i, s4_ack_i, s5_ack_i;
    wire        s0_err_i, s1_err_i, s2_err_i, s3_err_i, s4_err_i, s5_err_i;

    wire [31:0] s0_adr_o, s1_adr_o, s2_adr_o, s3_adr_o, s4_adr_o, s5_adr_o;
    wire [31:0] s0_dat_o, s1_dat_o, s2_dat_o, s3_dat_o, s4_dat_o, s5_dat_o;
    wire        s0_we_o, s1_we_o, s2_we_o, s3_we_o, s4_we_o, s5_we_o;
    wire [3:0]  s0_sel_o, s1_sel_o, s2_sel_o, s3_sel_o, s4_sel_o, s5_sel_o;
    wire        s0_cyc_o, s1_cyc_o, s2_cyc_o, s3_cyc_o, s4_cyc_o, s5_cyc_o;
    wire        s0_stb_o, s1_stb_o, s2_stb_o, s3_stb_o, s4_stb_o, s5_stb_o;

    wb_interconnect u_wb_ic (
        .clk        (clk),
        .rst        (rst),

        .m_adr_i    (wb_adr_m),
        .m_dat_i    (wb_dat_o_m),
        .m_dat_o    (wb_dat_i_m),
        .m_we_i     (wb_we_m),
        .m_sel_i    (wb_sel_m),
        .m_cyc_i    (wb_cyc_m),
        .m_stb_i    (wb_stb_m),
        .m_ack_o    (wb_ack_m),
        .m_err_o    (wb_err_m),

        .s0_adr_o   (s0_adr_o),
        .s0_dat_o   (s0_dat_o),
        .s0_dat_i   (s0_dat_i),
        .s0_we_o    (s0_we_o),
        .s0_sel_o   (s0_sel_o),
        .s0_cyc_o   (s0_cyc_o),
        .s0_stb_o   (s0_stb_o),
        .s0_ack_i   (s0_ack_i),
        .s0_err_i   (s0_err_i),

        .s1_adr_o   (s1_adr_o),
        .s1_dat_o   (s1_dat_o),
        .s1_dat_i   (s1_dat_i),
        .s1_we_o    (s1_we_o),
        .s1_sel_o   (s1_sel_o),
        .s1_cyc_o   (s1_cyc_o),
        .s1_stb_o   (s1_stb_o),
        .s1_ack_i   (s1_ack_i),
        .s1_err_i   (s1_err_i),

        .s2_adr_o   (s2_adr_o),
        .s2_dat_o   (s2_dat_o),
        .s2_dat_i   (s2_dat_i),
        .s2_we_o    (s2_we_o),
        .s2_sel_o   (s2_sel_o),
        .s2_cyc_o   (s2_cyc_o),
        .s2_stb_o   (s2_stb_o),
        .s2_ack_i   (s2_ack_i),
        .s2_err_i   (s2_err_i),

        .s3_adr_o   (s3_adr_o),
        .s3_dat_o   (s3_dat_o),
        .s3_dat_i   (s3_dat_i),
        .s3_we_o    (s3_we_o),
        .s3_sel_o   (s3_sel_o),
        .s3_cyc_o   (s3_cyc_o),
        .s3_stb_o   (s3_stb_o),
        .s3_ack_i   (s3_ack_i),
        .s3_err_i   (s3_err_i),

        .s4_adr_o   (s4_adr_o),
        .s4_dat_o   (s4_dat_o),
        .s4_dat_i   (s4_dat_i),
        .s4_we_o    (s4_we_o),
        .s4_sel_o   (s4_sel_o),
        .s4_cyc_o   (s4_cyc_o),
        .s4_stb_o   (s4_stb_o),
        .s4_ack_i   (s4_ack_i),
        .s4_err_i   (s4_err_i),

        .s5_adr_o   (s5_adr_o),
        .s5_dat_o   (s5_dat_o),
        .s5_dat_i   (s5_dat_i),
        .s5_we_o    (s5_we_o),
        .s5_sel_o   (s5_sel_o),
        .s5_cyc_o   (s5_cyc_o),
        .s5_stb_o   (s5_stb_o),
        .s5_ack_i   (s5_ack_i),
        .s5_err_i   (s5_err_i)
    );

    // Stub slaves for now: always ACK, no error, return distinct constants
    assign s0_dat_i = 32'hSDRA_0000; assign s0_ack_i = s0_cyc_o & s0_stb_o; assign s0_err_i = 1'b0;
    assign s1_dat_i = 32'hUART_0000; assign s1_ack_i = s1_cyc_o & s1_stb_o; assign s1_err_i = 1'b0;
    assign s2_dat_i = 32'hI2C0_000;  assign s2_ack_i = s2_cyc_o & s2_stb_o; assign s2_err_i = 1'b0;
    assign s3_dat_i = 32'hSPI0_000;  assign s3_ack_i = s3_cyc_o & s3_stb_o; assign s3_err_i = 1'b0;
    assign s4_dat_i = 32'hGPIO_000;  assign s4_ack_i = s4_cyc_o & s4_stb_o; assign s4_err_i = 1'b0;
    assign s5_dat_i = 32'hJTAG_000;  assign s5_ack_i = s5_cyc_o & s5_stb_o; assign s5_err_i = 1'b0;

endmodule

================================================================================
STEP 4 — QUARTUS BUILD & PROGRAMMING (STILL SRAM-ONLY, NO FLASH)
================================================================================

1. Ensure files are in place:
   - ~/fpga/h3_phase1_sc/rtl/soc/hazard3_tile.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/ahb_interconnect_4m.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/boot_rom.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/ahb_to_wb_bridge.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/wb_interconnect.sv
   - ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv
   - Hazard3 core RTL under rtl/cores/hazard3/...

2. Boot ROM hex:
   - cd ~/hazard3_fw/bootrom
   - make
   - Copy bootrom.hex into ~/fpga/h3_phase1_sc/quartus (or adjust path in boot_rom.sv).

3. In Quartus:
   - Open h3_phase1_sc project (from Phase 1A).
   - Add the new RTL files (ahb_to_wb_bridge, wb_interconnect, updated top_soc.sv).
   - Re-run Analysis & Synthesis and full Compilation.

4. Program DE0-Lite (SRAM-only):
   - Open Quartus Programmer.
   - Mode: JTAG.
   - File: h3_phase1_sc.sof (output_files/).
   - Check ONLY “Program/Configure”.
   - DO NOT create or program .pof. DO NOT set any configuration device.
   - Click Start.

5. After programming:
   - HART0 still boots from ROM and loops in _start().
   - Any AHB access in 0x1000_0000–0x8FFF_FFFF goes through the AHB→WB bridge
     and WB interconnect to stub slaves, returning known constants.

================================================================================
WHAT PHASE 1B ACHIEVES TOWARD QUAD-CORE GOAL
================================================================================

- You now have a **quad-core-ready bus architecture**:
  - 4-master AHB interconnect (M0 live, M1–M3 reserved).
  - AHB→WB bridge as a unified gateway to all off-core memory & peripherals.
  - Wishbone fabric with stable, final address map for SDRAM and peripherals.

- The next phases can now cleanly:
  - Replace SDRAM stub (s0) with OpenCores SDRAM controller (Phase 1C).
  - Replace UART/I2C/SPI/GPIO/JTAG-UART stubs (s1–s5) with real IP (Phases 1D–1H).
  - Add bootloader, HAL, and firmware on top (1I–1K).
  - Then scale to 2 and 4 cores by hooking up more hazard3_tile instances to M1..M3.

################END PHASE1B#############
================================================================================
PHASE 1C: SDRAM INTEGRATION (OPENCORES CONTROLLER) INTO AHB→WB FABRIC
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 1C
----------------
Replace the SDRAM stub (Wishbone s0) from Phase 1B with a **real** OpenCores-style
SDRAM controller, giving you:

- External SDRAM @ 0x8000_0000 on DE0-Lite.
- SDRAM accessed via:
  Hazard3 → AHB interconnect → AHB→WB bridge → WB SDRAM controller.
- Still: only `.sof` programmed via JTAG into **SRAM**, never flash.
  On power-cycle, the DE0-Lite returns to its factory demo.

ASSUMPTIONS
-----------
- You have the DE0-Lite’s SDRAM chip (IS42S16400 or equivalent 16-bit SDRAM) wired
  to the FPGA using the Terasic reference design.
- You can download an OpenCores SDRAM controller that:
  - Speaks **Wishbone** on the system side.
  - Drives standard SDRAM signals (addr, bank, dq, dqm, ras/cas/we, cke, clk).
- We’ll:
  - Add a WB wrapper/top for the SDRAM controller.
  - Connect it to s0_* ports of wb_interconnect.
  - Expose SDRAM pins from top_soc.
  - Keep all other slaves (UART/I2C/SPI/GPIO/JTAG-UART) as stubs for now.

DIRECTORY CONTEXT
-----------------
We add:

- ~/fpga/h3_phase1_sc/rtl/cores/opencores_sdram/
    - sdram_ctrl.v            (from OpenCores)
    - (other files as needed by that core)
- ~/fpga/h3_phase1_sc/rtl/soc/sdram_wb_wrapper.sv   (NEW)
- Update: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv    (add SDRAM instance + pins)

You still have:

- hazard3_tile.sv
- ahb_interconnect_4m.sv
- ahb_to_wb_bridge.sv
- wb_interconnect.sv
- boot_rom.sv
- bootrom.hex (Phase 1A ROM)

================================================================================
STEP 1 — PLACE THE OPENCORES SDRAM CONTROLLER RTL
================================================================================

1. Create directory for the SDRAM core:

   mkdir -p ~/fpga/h3_phase1_sc/rtl/cores/opencores_sdram

2. Download the OpenCores SDRAM controller sources from opencores.org into that
   directory. The main top-level usually has a name like:

   - sdram_ctrl.v   or
   - sdr_ctrl.v

   It typically exposes:

   - Wishbone system interface:
     - wb_clk_i, wb_rst_i
     - wb_adr_i, wb_dat_i, wb_dat_o, wb_sel_i, wb_cyc_i, wb_stb_i, wb_we_i
     - wb_ack_o, wb_err_o
   - SDRAM signals:
     - sdram_clk, sdram_cke, sdram_cs_n, sdram_ras_n, sdram_cas_n, sdram_we_n
     - sdram_ba, sdram_a
     - sdram_dqm, sdram_dq

   The exact names may differ slightly; adjust the wrapper accordingly.

================================================================================
STEP 2 — WISHBONE SDRAM WRAPPER (ADAPT TO OUR FABRIC)
================================================================================

We wrap the raw SDRAM controller into a module with **exactly** the Wishbone ports
expected by wb_interconnect for s0.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/sdram_wb_wrapper.sv -------------------

module sdram_wb_wrapper
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone slave interface (from wb_interconnect)
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output wire [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output wire        wb_ack_o,
    output wire        wb_err_o,

    // SDRAM physical interface (to DE0-Lite board pins)
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq
);

    // The OpenCores controller often expects:
    // - byte address or word address; we pass wb_adr_i directly / or truncated.
    // - 32-bit data; matches our fabric.
    // - synchronous reset and clock.

    // Adjust these instance/port names to your specific OpenCores SDRAM core.
    // Example instance (placeholder names):

    wire [31:0] sdram_dat_o;
    wire        sdram_ack_o;
    wire        sdram_err_o;

    assign wb_dat_o = sdram_dat_o;
    assign wb_ack_o = sdram_ack_o;
    assign wb_err_o = sdram_err_o;

    sdram_ctrl u_sdram (
        // System
        .wb_clk_i   (clk),
        .wb_rst_i   (rst),

        .wb_adr_i   (wb_adr_i),
        .wb_dat_i   (wb_dat_i),
        .wb_dat_o   (sdram_dat_o),
        .wb_sel_i   (wb_sel_i),
        .wb_cyc_i   (wb_cyc_i),
        .wb_stb_i   (wb_stb_i),
        .wb_we_i    (wb_we_i),
        .wb_ack_o   (sdram_ack_o),
        .wb_err_o   (sdram_err_o),

        // SDRAM
        .sdram_clk  (sdram_clk),
        .sdram_cke  (sdram_cke),
        .sdram_cs_n (sdram_cs_n),
        .sdram_ras_n(sdram_ras_n),
        .sdram_cas_n(sdram_cas_n),
        .sdram_we_n (sdram_we_n),
        .sdram_ba   (sdram_ba),
        .sdram_a    (sdram_a),
        .sdram_dqm  (sdram_dqm),
        .sdram_dq   (sdram_dq)
    );

endmodule

NOTES:
- The exact module name and ports of the OpenCores SDRAM core might differ:
  - You might need to map address width, data width, CAS latency, etc.
  - You may need to parameterize the controller (e.g. bank bits, row/col bits).
- This wrapper’s job is only to match **Wishbone** and expose SDRAM pins.

================================================================================
STEP 3 — UPDATE wb_interconnect TO BE USED WITH REAL SDRAM (LOGIC ALREADY OK)
================================================================================

Our Phase 1B wb_interconnect is already structurally correct for s0 as SDRAM.  
We just need to:

- Connect s0_* ports to sdram_wb_wrapper instead of the s0 stub.

No change required inside wb_interconnect.sv itself.

================================================================================
STEP 4 — UPDATE top_soc.sv TO INSTANTIATE SDRAM WRAPPER + EXPOSE PINS
================================================================================

We now modify top_soc.sv:

- Add SDRAM pins to the module ports.
- Replace SDRAM stub assignments for s0_… with the real wrapper instance.
- Keep stubs for s1–s5 (UART/I2C/SPI/GPIO/JTAG-UART) for now.

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv -------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n,

    // SDRAM pins (to DE0-Lite external SDRAM)
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq

    // Later phases: add UART/I2C/SPI/GPIO pins here
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    //======================
    // AHB masters as in Phase 1B (HART0 + reserved M1..M3)
    //======================
    wire [31:0] m0_haddr;
    wire [2:0]  m0_hsize;
    wire [1:0]  m0_hburst;
    wire [1:0]  m0_htrans;
    wire        m0_hwrite;
    wire [31:0] m0_hwdata;
    wire [31:0] m0_hrdata;
    wire        m0_hready;
    wire        m0_hresp;

    wire [31:0] m1_haddr = 32'h0;
    wire [2:0]  m1_hsize = 3'b010;
    wire [1:0]  m1_hburst = 2'b00;
    wire [1:0]  m1_htrans = 2'b00;
    wire        m1_hwrite = 1'b0;
    wire [31:0] m1_hwdata = 32'h0;
    wire [31:0] m1_hrdata;
    wire        m1_hready;
    wire        m1_hresp;

    wire [31:0] m2_haddr = 32'h0;
    wire [2:0]  m2_hsize = 3'b010;
    wire [1:0]  m2_hburst = 2'b00;
    wire [1:0]  m2_htrans = 2'b00;
    wire        m2_hwrite = 1'b0;
    wire [31:0] m2_hwdata = 32'h0;
    wire [31:0] m2_hrdata;
    wire        m2_hready;
    wire        m2_hresp;

    wire [31:0] m3_haddr = 32'h0;
    wire [2:0]  m3_hsize = 3'b010;
    wire [1:0]  m3_hburst = 2'b00;
    wire [1:0]  m3_htrans = 2'b00;
    wire        m3_hwrite = 1'b0;
    wire [31:0] m3_hwdata = 32'h0;
    wire [31:0] m3_hrdata;
    wire        m3_hready;
    wire        m3_hresp;

    // AHB slaves: s0 = ROM, s1 = AHB→WB
    wire [31:0] s0_haddr, s1_haddr;
    wire [2:0]  s0_hsize, s1_hsize;
    wire [1:0]  s0_hburst, s1_hburst;
    wire [1:0]  s0_htrans, s1_htrans;
    wire        s0_hwrite, s1_hwrite;
    wire [31:0] s0_hwdata, s1_hwdata;
    wire [31:0] s0_hrdata, s1_hrdata;
    wire        s0_hready, s1_hready;
    wire        s0_hresp,  s1_hresp;

    // HART0
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 (
        .clk    (clk),
        .rst    (rst),

        .HADDR  (m0_haddr),
        .HSIZE  (m0_hsize),
        .HBURST (m0_hburst),
        .HTRANS (m0_htrans),
        .HWRITE (m0_hwrite),
        .HWDATA (m0_hwdata),
        .HRDATA (m0_hrdata),
        .HREADY (m0_hready),
        .HRESP  (m0_hresp)
    );

    // AHB interconnect
    ahb_interconnect_4m u_ahb_ic (
        .clk        (clk),
        .rst        (rst),

        .m0_haddr   (m0_haddr),
        .m0_hsize   (m0_hsize),
        .m0_hburst  (m0_hburst),
        .m0_htrans  (m0_htrans),
        .m0_hwrite  (m0_hwrite),
        .m0_hwdata  (m0_hwdata),
        .m0_hrdata  (m0_hrdata),
        .m0_hready  (m0_hready),
        .m0_hresp   (m0_hresp),

        .m1_haddr   (m1_haddr),
        .m1_hsize   (m1_hsize),
        .m1_hburst  (m1_hburst),
        .m1_htrans  (m1_htrans),
        .m1_hwrite  (m1_hwrite),
        .m1_hwdata  (m1_hwdata),
        .m1_hrdata  (m1_hrdata),
        .m1_hready  (m1_hready),
        .m1_hresp   (m1_hresp),

        .m2_haddr   (m2_haddr),
        .m2_hsize   (m2_hsize),
        .m2_hburst  (m2_hburst),
        .m2_htrans  (m2_htrans),
        .m2_hwrite  (m2_hwrite),
        .m2_hwdata  (m2_hwdata),
        .m2_hrdata  (m2_hrdata),
        .m2_hready  (m2_hready),
        .m2_hresp   (m2_hresp),

        .m3_haddr   (m3_haddr),
        .m3_hsize   (m3_hsize),
        .m3_hburst  (m3_hburst),
        .m3_htrans  (m3_htrans),
        .m3_hwrite  (m3_hwrite),
        .m3_hwdata  (m3_hwdata),
        .m3_hrdata  (m3_hrdata),
        .m3_hready  (m3_hready),
        .m3_hresp   (m3_hresp),

        .s0_haddr   (s0_haddr),
        .s0_hsize   (s0_hsize),
        .s0_hburst  (s0_hburst),
        .s0_htrans  (s0_htrans),
        .s0_hwrite  (s0_hwrite),
        .s0_hwdata  (s0_hwdata),
        .s0_hrdata  (s0_hrdata),
        .s0_hready  (s0_hready),
        .s0_hresp   (s0_hresp),

        .s1_haddr   (s1_haddr),
        .s1_hsize   (s1_hsize),
        .s1_hburst  (s1_hburst),
        .s1_htrans  (s1_htrans),
        .s1_hwrite  (s1_hwrite),
        .s1_hwdata  (s1_hwdata),
        .s1_hrdata  (s1_hrdata),
        .s1_hready  (s1_hready),
        .s1_hresp   (s1_hresp)
    );

    // Boot ROM @ 0x2000_0000
    boot_rom u_boot_rom (
        .clk    (clk),
        .rst    (rst),
        .HADDR  (s0_haddr),
        .HSIZE  (s0_hsize),
        .HBURST (s0_hburst),
        .HTRANS (s0_htrans),
        .HWRITE (s0_hwrite),
        .HWDATA (s0_hwdata),
        .HRDATA (s0_hrdata),
        .HREADY (s0_hready),
        .HRESP  (s0_hresp)
    );

    // AHB→Wishbone bridge on slave 1 (peripheral/SRAM region)
    wire [31:0] wb_adr_m;
    wire [31:0] wb_dat_o_m;
    wire [31:0] wb_dat_i_m;
    wire        wb_we_m;
    wire [3:0]  wb_sel_m;
    wire        wb_cyc_m;
    wire        wb_stb_m;
    wire        wb_ack_m;
    wire        wb_err_m;

    ahb_to_wb_bridge u_ahb2wb (
        .clk        (clk),
        .rst        (rst),

        .HADDR      (s1_haddr),
        .HSIZE      (s1_hsize),
        .HBURST     (s1_hburst),
        .HTRANS     (s1_htrans),
        .HWRITE     (s1_hwrite),
        .HWDATA     (s1_hwdata),
        .HRDATA     (s1_hrdata),
        .HREADY     (s1_hready),
        .HRESP      (s1_hresp),

        .wb_adr_o   (wb_adr_m),
        .wb_dat_o   (wb_dat_o_m),
        .wb_dat_i   (wb_dat_i_m),
        .wb_we_o    (wb_we_m),
        .wb_sel_o   (wb_sel_m),
        .wb_cyc_o   (wb_cyc_m),
        .wb_stb_o   (wb_stb_m),
        .wb_ack_i   (wb_ack_m),
        .wb_err_i   (wb_err_m)
    );

    // Wishbone interconnect
    wire [31:0] s0_dat_i, s1_dat_i, s2_dat_i, s3_dat_i, s4_dat_i, s5_dat_i;
    wire        s0_ack_i, s1_ack_i, s2_ack_i, s3_ack_i, s4_ack_i, s5_ack_i;
    wire        s0_err_i, s1_err_i, s2_err_i, s3_err_i, s4_err_i, s5_err_i;

    wire [31:0] s0_adr_o, s1_adr_o, s2_adr_o, s3_adr_o, s4_adr_o, s5_adr_o;
    wire [31:0] s0_dat_o, s1_dat_o, s2_dat_o, s3_dat_o, s4_dat_o, s5_dat_o;
    wire        s0_we_o,  s1_we_o,  s2_we_o,  s3_we_o,  s4_we_o,  s5_we_o;
    wire [3:0]  s0_sel_o, s1_sel_o, s2_sel_o, s3_sel_o, s4_sel_o, s5_sel_o;
    wire        s0_cyc_o, s1_cyc_o, s2_cyc_o, s3_cyc_o, s4_cyc_o, s5_cyc_o;
    wire        s0_stb_o, s1_stb_o, s2_stb_o, s3_stb_o, s4_stb_o, s5_stb_o;

    wb_interconnect u_wb_ic (
        .clk        (clk),
        .rst        (rst),

        .m_adr_i    (wb_adr_m),
        .m_dat_i    (wb_dat_o_m),
        .m_dat_o    (wb_dat_i_m),
        .m_we_i     (wb_we_m),
        .m_sel_i    (wb_sel_m),
        .m_cyc_i    (wb_cyc_m),
        .m_stb_i    (wb_stb_m),
        .m_ack_o    (wb_ack_m),
        .m_err_o    (wb_err_m),

        .s0_adr_o   (s0_adr_o),
        .s0_dat_o   (s0_dat_o),
        .s0_dat_i   (s0_dat_i),
        .s0_we_o    (s0_we_o),
        .s0_sel_o   (s0_sel_o),
        .s0_cyc_o   (s0_cyc_o),
        .s0_stb_o   (s0_stb_o),
        .s0_ack_i   (s0_ack_i),
        .s0_err_i   (s0_err_i),

        .s1_adr_o   (s1_adr_o),
        .s1_dat_o   (s1_dat_o),
        .s1_dat_i   (s1_dat_i),
        .s1_we_o    (s1_we_o),
        .s1_sel_o   (s1_sel_o),
        .s1_cyc_o   (s1_cyc_o),
        .s1_stb_o   (s1_stb_o),
        .s1_ack_i   (s1_ack_i),
        .s1_err_i   (s1_err_i),

        .s2_adr_o   (s2_adr_o),
        .s2_dat_o   (s2_dat_o),
        .s2_dat_i   (s2_dat_i),
        .s2_we_o    (s2_we_o),
        .s2_sel_o   (s2_sel_o),
        .s2_cyc_o   (s2_cyc_o),
        .s2_stb_o   (s2_stb_o),
        .s2_ack_i   (s2_ack_i),
        .s2_err_i   (s2_err_i),

        .s3_adr_o   (s3_adr_o),
        .s3_dat_o   (s3_dat_o),
        .s3_dat_i   (s3_dat_i),
        .s3_we_o    (s3_we_o),
        .s3_sel_o   (s3_sel_o),
        .s3_cyc_o   (s3_cyc_o),
        .s3_stb_o   (s3_stb_o),
        .s3_ack_i   (s3_ack_i),
        .s3_err_i   (s3_err_i),

        .s4_adr_o   (s4_adr_o),
        .s4_dat_o   (s4_dat_o),
        .s4_dat_i   (s4_dat_i),
        .s4_we_o    (s4_we_o),
        .s4_sel_o   (s4_sel_o),
        .s4_cyc_o   (s4_cyc_o),
        .s4_stb_o   (s4_stb_o),
        .s4_ack_i   (s4_ack_i),
        .s4_err_i   (s4_err_i),

        .s5_adr_o   (s5_adr_o),
        .s5_dat_o   (s5_dat_o),
        .s5_dat_i   (s5_dat_i),
        .s5_we_o    (s5_we_o),
        .s5_sel_o   (s5_sel_o),
        .s5_cyc_o   (s5_cyc_o),
        .s5_stb_o   (s5_stb_o),
        .s5_ack_i   (s5_ack_i),
        .s5_err_i   (s5_err_i)
    );

    // SDRAM slave (s0): connect to real SDRAM controller
    sdram_wb_wrapper u_sdram_wb (
        .clk        (clk),
        .rst        (rst),

        .wb_adr_i   (s0_adr_o),
        .wb_dat_i   (s0_dat_o),
        .wb_dat_o   (s0_dat_i),
        .wb_we_i    (s0_we_o),
        .wb_sel_i   (s0_sel_o),
        .wb_cyc_i   (s0_cyc_o),
        .wb_stb_i   (s0_stb_o),
        .wb_ack_o   (s0_ack_i),
        .wb_err_o   (s0_err_i),

        .sdram_a    (sdram_a),
        .sdram_ba   (sdram_ba),
        .sdram_clk  (sdram_clk),
        .sdram_cke  (sdram_cke),
        .sdram_cs_n (sdram_cs_n),
        .sdram_ras_n(sdram_ras_n),
        .sdram_cas_n(sdram_cas_n),
        .sdram_we_n (sdram_we_n),
        .sdram_dqm  (sdram_dqm),
        .sdram_dq   (sdram_dq)
    );

    // Stub peripherals for now
    assign s1_dat_i = 32'hUART_0000; assign s1_ack_i = s1_cyc_o & s1_stb_o; assign s1_err_i = 1'b0;
    assign s2_dat_i = 32'hI2C0_000;  assign s2_ack_i = s2_cyc_o & s2_stb_o; assign s2_err_i = 1'b0;
    assign s3_dat_i = 32'hSPI0_000;  assign s3_ack_i = s3_cyc_o & s3_stb_o; assign s3_err_i = 1'b0;
    assign s4_dat_i = 32'hGPIO_000;  assign s4_ack_i = s4_cyc_o & s4_stb_o; assign s4_err_i = 1'b0;
    assign s5_dat_i = 32'hJTAG_000;  assign s5_ack_i = s5_cyc_o & s5_stb_o; assign s5_err_i = 1'b0;

endmodule

================================================================================
STEP 5 — QUARTUS: PINS, BUILD, PROGRAM (SRAM-ONLY)
================================================================================

1. Add SDRAM controller RTL to project:
   - In Quartus → Add/Remove Files:
     - ../rtl/cores/opencores_sdram/*.v
     - ../rtl/soc/sdram_wb_wrapper.sv
     - Updated ../rtl/soc/top_soc.sv

2. Pin assignments for SDRAM:
   - Map sdram_* ports in top_soc to the correct DE0-Lite SDRAM pins according
     to the board’s user manual (Terasic pin-out table).
   - Typically:
     - sdram_clk → dedicated SDRAM clock pin.
     - sdram_a[12:0], sdram_ba[1:0], sdram_dq[15:0], sdram_dqm[1:0],
       sdram_cs_n, sdram_ras_n, sdram_cas_n, sdram_we_n, sdram_cke → as per ref.

3. Boot ROM:
   - Ensure bootrom.hex is in the Quartus project directory, or path in boot_rom.sv
     is adjusted.

4. Compile:
   - Processing → Start Compilation.

5. Program SRAM (never flash):
   - Open Quartus Programmer.
   - Mode: JTAG.
   - File: h3_phase1_sc.sof.
   - Check only “Program/Configure”.
   - Click Start.

6. Behavior:
   - Hazard3 boots from ROM at 0x2000_0000 and runs the Phase 1A stub (infinite WFI).
   - Any subsequent C firmware we create can now place .text/.data in SDRAM at
     0x8000_0000, and the bus path is fully real:
       Core → AHB → Bridge → WB → SDRAM controller → SDRAM pins.
   - On power-cycle, board reverts to factory demo image from flash.

================================================================================
WHAT PHASE 1C GIVES YOU TOWARD THE QUAD-CORE GOAL
================================================================================

- A scalable memory architecture:
  - SDRAM as a first-class WB slave under a single AHB→WB gateway.
  - Address map: 0x8000_0000.. for code/data.
- Fully compatible with adding:
  - More Hazard3 tiles (M1..M3).
  - Peripherals behind the same WB fabric (UART/I2C/SPI/GPIO/JTAG-UART).
  - Bootloader that uploads firmware into SDRAM and jumps to 0x8000_0000.

Next natural step is **Phase 1D**:
- Integrate a real OpenCores UART16550 on s1 (0x1000_0000) with a minimal test
  firmware to prove SDRAM + UART together.

##############END Phase 1C################
================================================================================
PHASE 1D: REAL UART16550 INTEGRATION ON WISHBONE s1 @ 0x1000_0000
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 1D
----------------
Take the SoC from Phase 1C (Hazard3 + AHB→WB + SDRAM) and:

- Replace the UART stub on Wishbone s1 with a **real** OpenCores UART16550.
- Map UART0 at 0x1000_0000 (word-addressed).
- Expose UART RX/TX pins on DE0-Lite Arduino D0/D1 (or equivalent).
- Add a tiny test firmware that:
  - Boots from ROM.
  - Writes to UART0 registers.
  - Sends a “Hello from UART0” message over the external USB‑serial dongle.

NO changes to your ephemeral rule:
- Only `.sof` via JTAG to **SRAM**.
- Never program flash (.pof).
- On power-cycle, DE0‑Lite returns to factory demo.

ASSUMPTIONS
-----------
- You already have:
  - Phase 1A + 1B + 1C implemented and compiling:
    - hazard3_tile.sv
    - ahb_interconnect_4m.sv
    - ahb_to_wb_bridge.sv
    - wb_interconnect.sv
    - boot_rom.sv
    - sdram_wb_wrapper.sv
    - top_soc.sv (with SDRAM pins)
  - Boot ROM stub (bootrom.c) that loops forever.
- You have (or can obtain) OpenCores UART16550 RTL with a Wishbone interface.

DIRECTORY CONTEXT
-----------------
We add:

- ~/fpga/h3_phase1_sc/rtl/cores/opencores_uart16550/
    - uart_top.v (or similar; main 16550 + WB top)
    - other UART core files
- ~/fpga/h3_phase1_sc/rtl/soc/uart16550_wb_wrapper.sv   (NEW)
- Update: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv         (connect UART to s1)
- Update: ~/hazard3_fw/bootrom/bootrom.c                 (minimal UART test)

We maintain:
- Only `.sof` via JTAG.
- Bootrom.hex as ROM content.

================================================================================
STEP 1 — PLACE THE OPENCORES UART16550 SOURCES
================================================================================

1. Create directory for UART core:

   mkdir -p ~/fpga/h3_phase1_sc/rtl/cores/opencores_uart16550

2. Download OpenCores UART16550 from opencores.org (or equivalent mirror):

   - Place its Verilog files in:
     ~/fpga/h3_phase1_sc/rtl/cores/opencores_uart16550/

3. Identify the Wishbone wrapper/top for the UART core:
   - Common names: uart_top.v, uart_wb.v, etc.
   - It typically exposes:
     - Wishbone:
       - wb_clk_i, wb_rst_i
       - wb_adr_i, wb_dat_i, wb_dat_o, wb_sel_i, wb_cyc_i, wb_stb_i, wb_we_i
       - wb_ack_o
     - UART pins:
       - stx_o (TX)
       - srx_i (RX)
     - Optional modem control pins (we can tie unused to constants).

You’ll adjust the wrapper below to the exact module/port names from the core you fetched.

================================================================================
STEP 2 — UART16550 WISHBONE WRAPPER (s1 SLAVE)
================================================================================

We wrap the OpenCores UART16550 into a module with the Wishbone interface that
matches s1_* in wb_interconnect.

Addressing model:
- We’ll use the low address bits [7:2] as register index (word-addressed).
- The core may expect byte addressing; we pass the full wb_adr_i and let it use what it needs.

UART configuration:
- 8N1, FIFOs enabled, 115200 baud from 50 MHz clock.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/uart16550_wb_wrapper.sv ----------------

module uart16550_wb_wrapper
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone slave interface
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output wire [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output wire        wb_ack_o,
    output wire        wb_err_o,

    // UART pins
    input  wire        uart_rx,
    output wire        uart_tx
);

    // For this simple case, we don't use wb_err_o.
    assign wb_err_o = 1'b0;

    // OpenCores UART16550 usually has an 8-bit data bus.
    // We map our 32-bit WB bus to 8 bits by using the low byte and ignoring others.
    // For a more correct implementation, you’d consider wb_sel_i and partial writes.

    wire        uart_ack;
    wire [7:0]  uart_dat_o;

    assign wb_ack_o   = uart_ack;
    assign wb_dat_o   = {24'h0, uart_dat_o};

    // Example instance; adapt module/port names to the actual OpenCores UART top.
    uart_top u_uart (
        .wb_clk_i   (clk),
        .wb_rst_i   (rst),

        .wb_adr_i   (wb_adr_i[4:2]),   // word-aligned 3-bit register index (0..7)
        .wb_dat_i   (wb_dat_i[7:0]),
        .wb_dat_o   (uart_dat_o),
        .wb_we_i    (wb_we_i),
        .wb_sel_i   (wb_sel_i[0]),
        .wb_cyc_i   (wb_cyc_i),
        .wb_stb_i   (wb_stb_i),
        .wb_ack_o   (uart_ack),

        // Modem control (tie off if not used)
        .stx_pad_o  (uart_tx),
        .srx_pad_i  (uart_rx),
        .rts_pad_o  (),
        .cts_pad_i  (1'b0),
        .dtr_pad_o  (),
        .dsr_pad_i  (1'b0),
        .ri_pad_i   (1'b0),
        .dcd_pad_i  (1'b0),

        // Interrupt (unused for now)
        .int_o      ()
    );

endmodule

NOTES:
- You must check the actual OpenCores UART top port list and adjust:
  - Module name (uart_top vs. something else).
  - Address width (wb_adr_i bits).
  - Data bus width (8 vs. 32 bits).
  - Modem control pins.

================================================================================
STEP 3 — UPDATE top_soc.sv TO CONNECT UART0 ON s1 AND EXPOSE UART PINS
================================================================================

We now:

- Add UART pins (uart0_rx, uart0_tx) to top_soc.
- Replace the s1 stub (UART) with the real uart16550_wb_wrapper.

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv --------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n,

    // SDRAM pins
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq,

    // UART0 pins (map to D0/D1 on DE0-Lite Arduino header)
    input  wire        uart0_rx,
    output wire        uart0_tx

    // Later: add I2C/SPI/GPIO pins
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    // (UNCHANGED) AHB masters M0..M3, AHB slaves s0..s1, Hazard3 tile,
    // AHB interconnect, Boot ROM, AHB→WB bridge, WB interconnect, SDRAM integration
    // Keep everything from Phase 1C as-is, except the stub for s1 (UART).

    // ... (same declarations as Phase 1C: m0..m3_*; s0..s1_*; etc.) ...

    // HART0
    hazard3_tile #(
        .HART_ID(0)
    ) u_hart0 ( /* same as Phase 1C */ );

    // AHB interconnect
    ahb_interconnect_4m u_ahb_ic ( /* same as Phase 1C */ );

    // Boot ROM
    boot_rom u_boot_rom ( /* same as Phase 1C (hooked to s0_*) */ );

    // AHB→Wishbone bridge on s1
    wire [31:0] wb_adr_m;
    wire [31:0] wb_dat_o_m;
    wire [31:0] wb_dat_i_m;
    wire        wb_we_m;
    wire [3:0]  wb_sel_m;
    wire        wb_cyc_m;
    wire        wb_stb_m;
    wire        wb_ack_m;
    wire        wb_err_m;

    ahb_to_wb_bridge u_ahb2wb ( /* same as Phase 1C (hooked to s1_*) */ );

    // Wishbone interconnect
    wire [31:0] s0_dat_i, s1_dat_i, s2_dat_i, s3_dat_i, s4_dat_i, s5_dat_i;
    wire        s0_ack_i, s1_ack_i, s2_ack_i, s3_ack_i, s4_ack_i, s5_ack_i;
    wire        s0_err_i, s1_err_i, s2_err_i, s3_err_i, s4_err_i, s5_err_i;

    wire [31:0] s0_adr_o, s1_adr_o, s2_adr_o, s3_adr_o, s4_adr_o, s5_adr_o;
    wire [31:0] s0_dat_o, s1_dat_o, s2_dat_o, s3_dat_o, s4_dat_o, s5_dat_o;
    wire        s0_we_o, s1_we_o, s2_we_o, s3_we_o, s4_we_o, s5_we_o;
    wire [3:0]  s0_sel_o, s1_sel_o, s2_sel_o, s3_sel_o, s4_sel_o, s5_sel_o;
    wire        s0_cyc_o, s1_cyc_o, s2_cyc_o, s3_cyc_o, s4_cyc_o, s5_cyc_o;
    wire        s0_stb_o, s1_stb_o, s2_stb_o, s3_stb_o, s4_stb_o, s5_stb_o;

    wb_interconnect u_wb_ic ( /* same as Phase 1C */ );

    // SDRAM (s0)
    sdram_wb_wrapper u_sdram_wb (
        .clk        (clk),
        .rst        (rst),

        .wb_adr_i   (s0_adr_o),
        .wb_dat_i   (s0_dat_o),
        .wb_dat_o   (s0_dat_i),
        .wb_we_i    (s0_we_o),
        .wb_sel_i   (s0_sel_o),
        .wb_cyc_i   (s0_cyc_o),
        .wb_stb_i   (s0_stb_o),
        .wb_ack_o   (s0_ack_i),
        .wb_err_o   (s0_err_i),

        .sdram_a    (sdram_a),
        .sdram_ba   (sdram_ba),
        .sdram_clk  (sdram_clk),
        .sdram_cke  (sdram_cke),
        .sdram_cs_n (sdram_cs_n),
        .sdram_ras_n(sdram_ras_n),
        .sdram_cas_n(sdram_cas_n),
        .sdram_we_n (sdram_we_n),
        .sdram_dqm  (sdram_dqm),
        .sdram_dq   (sdram_dq)
    );

    // UART0 (s1): real OpenCores 16550
    uart16550_wb_wrapper u_uart0 (
        .clk        (clk),
        .rst        (rst),

        .wb_adr_i   (s1_adr_o),
        .wb_dat_i   (s1_dat_o),
        .wb_dat_o   (s1_dat_i),
        .wb_we_i    (s1_we_o),
        .wb_sel_i   (s1_sel_o),
        .wb_cyc_i   (s1_cyc_o),
        .wb_stb_i   (s1_stb_o),
        .wb_ack_o   (s1_ack_i),
        .wb_err_o   (s1_err_i),

        .uart_rx    (uart0_rx),
        .uart_tx    (uart0_tx)
    );

    // Still stub peripherals for now
    assign s2_dat_i = 32'hI2C0_000;  assign s2_ack_i = s2_cyc_o & s2_stb_o; assign s2_err_i = 1'b0;
    assign s3_dat_i = 32'hSPI0_000;  assign s3_ack_i = s3_cyc_o & s3_stb_o; assign s3_err_i = 1'b0;
    assign s4_dat_i = 32'hGPIO_000;  assign s4_ack_i = s4_cyc_o & s4_stb_o; assign s4_err_i = 1'b0;
    assign s5_dat_i = 32'hJTAG_000;  assign s5_ack_i = s5_cyc_o & s5_stb_o; assign s5_err_i = 1'b0;

endmodule

NOTE:
- I’ve elided the repeated, unchanged declarations/instantiations from Phase 1C
  with “(same as Phase 1C)” to keep this readable, but in your actual file you’ll
  have the complete code.

================================================================================
STEP 4 — UPDATE BOOT ROM TO EXERCISE UART0
================================================================================

For a first UART test, we can:

- Keep executing from ROM @ 0x2000_0000.
- Directly program UART registers via its memory map at 0x1000_0000.
- Print a short string once.

We’ll assume a 16550-like register layout with byte addressing:

Offset (byte)  Register
0x00           RBR/THR (RX/TX)
0x04           IER
0x08           IIR/FCR
0x0C           LCR
0x10           MCR
0x14           LSR
0x18           MSR
0x1C           SCR
DLAB=1 remaps 0x00/0x04 to DLL/DLM

We’ll use 32-bit accesses but only low byte matters (wrapper maps to 8-bit).

----- UPDATED FILE: ~/hazard3_fw/bootrom/bootrom.c ----------------------------

#include <stdint.h>

#define UART0_BASE   0x10000000u

#define UART_RBR     (*(volatile uint32_t *)(UART0_BASE + 0x00)) // RX (DLAB=0)
#define UART_THR     (*(volatile uint32_t *)(UART0_BASE + 0x00)) // TX (DLAB=0)
#define UART_IER     (*(volatile uint32_t *)(UART0_BASE + 0x04))
#define UART_IIR     (*(volatile uint32_t *)(UART0_BASE + 0x08))
#define UART_FCR     (*(volatile uint32_t *)(UART0_BASE + 0x08))
#define UART_LCR     (*(volatile uint32_t *)(UART0_BASE + 0x0C))
#define UART_MCR     (*(volatile uint32_t *)(UART0_BASE + 0x10))
#define UART_LSR     (*(volatile uint32_t *)(UART0_BASE + 0x14))

#define UART_LSR_DR   (1u << 0)
#define UART_LSR_THRE (1u << 5)

static void uart_init(uint32_t sys_clk_hz, uint32_t baud)
{
    // 16550: divisor = clk / (16 * baud)
    uint32_t divisor = sys_clk_hz / (16u * baud);

    // Enable DLAB to access DLL/DLM
    UART_LCR = 0x80u;
    UART_THR = (divisor & 0xFFu);          // DLL
    UART_IER = ((divisor >> 8) & 0xFFu);   // DLM

    // 8N1, DLAB=0
    UART_LCR = 0x03u;

    // Enable FIFO, clear RX/TX
    UART_FCR = 0x07u;

    // Modem Control: set OUT2 (often needed to enable interrupts), but we won't use IRQs yet
    UART_MCR = 0x08u;
}

static void uart_putc(char c)
{
    while (!(UART_LSR & UART_LSR_THRE)) {
        // wait
    }
    UART_THR = (uint8_t)c;
}

static void uart_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') {
            uart_putc('\r');
        }
        uart_putc(*s++);
    }
}

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;
    uart_init(SYS_CLK_HZ, 115200u);

    uart_puts("Hazard3 Phase 1D: UART16550 test\n");
    uart_puts("If you see this over UART0, the bridge + WB + UART are alive.\n");

    while (1) {
        __asm__ volatile("wfi");
    }
}

Rebuild bootrom.hex:

   cd ~/hazard3_fw/bootrom
   make

Ensure bootrom.hex is visible to Quartus (e.g. copy to project dir).

================================================================================
STEP 5 — QUARTUS: FILES, PINS, BUILD, PROGRAM (SRAM-ONLY)
================================================================================

1. Add UART core RTL:
   - Quartus → Add/Remove Files:
     - ../rtl/cores/opencores_uart16550/*.v
     - ../rtl/soc/uart16550_wb_wrapper.sv
     - Updated ../rtl/soc/top_soc.sv

2. UART0 pin assignment:
   - Map uart0_tx and uart0_rx to DE0-Lite Arduino D1 and D0 respectively
     (check board manual for exact pin names).
   - Connect your 3.3 V USB‑serial dongle:
     - Dongle TX → SoC RX (D0 / uart0_rx).
     - Dongle RX → SoC TX (D1 / uart0_tx).
     - GND → GND.

3. Boot ROM:
   - Ensure the new bootrom.hex (with UART test) is in the location referenced
     by boot_rom.sv.

4. Compile:
   - Processing → Start Compilation.

5. Program SRAM only:
   - Quartus Programmer:
     - Hardware: USB-Blaster.
     - File: h3_phase1_sc.sof.
     - Check only “Program/Configure”.
     - START.
   - Do **not** create/use .pof or program any configuration device.

6. Run-time test:
   - Power on DE0-Lite → factory demo loads from flash by default.
   - Program .sof over JTAG → Hazard3 SoC overlays into SRAM.
   - Open a serial terminal on the host at 115200 8N1 on the USB‑serial port.
   - Reset DE0-Lite (reset_n asserted then released).
   - You should see:

     Hazard3 Phase 1D: UART16550 test
     If you see this over UART0, the bridge + WB + UART are alive.

   - Power-cycle the board:
     - Your SoC disappears.
     - Factory demo reappears, as required.

================================================================================
WHAT PHASE 1D GIVES YOU TOWARD THE QUAD-CORE GOAL
================================================================================

- Real, OpenCores UART16550 integrated into the same WB fabric as SDRAM.
- Cleanly memory-mapped at 0x1000_0000 behind AHB→WB bridge.
- Verified end-to-end path:
  Hazard3 core → AHB → AHB→WB bridge → WB interconnect → UART16550 → pins.
- Preserves:
  - Quad-core-ready AHB fabric (M0..M3).
  - Ephemeral configuration (SRAM-only .sof, factory demo on power-cycle).
################END PHASE1D##############
================================================================================
PHASE 1E: REAL I2C MASTER INTEGRATION ON WISHBONE s2 @ 0x1000_0100
(ALL CONTENT IN ONE COPY-PASTABLE TEXTBOX, SRAM-ONLY, NO FLASH)
================================================================================

GOAL OF PHASE 1E
----------------
Extend the SoC from Phase 1D (Hazard3 + SDRAM + UART16550) by:

- Replacing the I2C stub on Wishbone s2 with a **real OpenCores I2C master**.
- Mapping I2C0 at 0x1000_0100 (byte/word accessed via WB).
- Exposing SDA/SCL pins (open-drain) on Arduino A4/A5.
- Adding a simple ROM-based test:
  - Configure I2C for 100 kHz.
  - Try a write/read to a known/slave address (e.g. 0x68 or dummy poll).
  - Print status via UART0.

Still:
- Only `.sof` via JTAG to SRAM (no .pof, no flash programming).
- Power-cycle → DE0-Lite factory demo restored automatically.

ASSUMPTIONS
-----------
You already have from earlier phases:

- AHB master (HART0 tile) and 4-master AHB fabric.
- AHB→WB bridge feeding wb_interconnect.
- SDRAM integrated as s0 (OpenCores SDRAM).
- UART16550 integrated as s1 (OpenCores UART) @ 0x1000_0000.
- Stub slaves for s2 (I2C), s3 (SPI), s4 (GPIO), s5 (JTAG-UART).
- Boot ROM that prints over UART0.

We now replace the I2C stub on s2 with a real OpenCores I2C master.

================================================================================
STEP 1 — PLACE THE OPENCORES I2C MASTER SOURCES
================================================================================

1. Create directory for I2C core:

   mkdir -p ~/fpga/h3_phase1_sc/rtl/cores/opencores_i2c

2. Download OpenCores I2C master from opencores.org and place all RTL files in:

   ~/fpga/h3_phase1_sc/rtl/cores/opencores_i2c/

3. Identify the Wishbone top-level, commonly named something like:

   i2c_master_top.v

   It typically has ports like:

   - Wishbone:
     - wb_clk_i, wb_rst_i
     - wb_adr_i[2:0], wb_dat_i[7:0], wb_dat_o[7:0]
     - wb_we_i, wb_stb_i, wb_cyc_i
     - wb_ack_o
   - I2C:
     - scl_pad_i, scl_pad_o, scl_padoen_o
     - sda_pad_i, sda_pad_o, sda_padoen_o

We’ll wrap that into our WB interface and map to top_soc SDA/SCL pins as open-drain.

================================================================================
STEP 2 — I2C WISHBONE WRAPPER (s2 SLAVE)
================================================================================

We wrap i2c_master_top into a module with the s2_* Wishbone interface expected by
wb_interconnect:

- 32-bit WB data but core is 8-bit → we map low byte.
- We use address bits [4:2] or [2:0] depending on the core.
- Provide SDA/SCL as inout, using oe signals from core.

----- FILE: ~/fpga/h3_phase1_sc/rtl/soc/i2c_wb_wrapper.sv ---------------------

module i2c_wb_wrapper
(
    input  wire        clk,
    input  wire        rst,

    // Wishbone slave interface
    input  wire [31:0] wb_adr_i,
    input  wire [31:0] wb_dat_i,
    output wire [31:0] wb_dat_o,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire        wb_cyc_i,
    input  wire        wb_stb_i,
    output wire        wb_ack_o,
    output wire        wb_err_o,

    // I2C pins (to board)
    inout  wire        sda,
    inout  wire        scl
);

    assign wb_err_o = 1'b0;

    // Low byte used for I2C core
    wire [7:0] i2c_dat_o;

    assign wb_dat_o = {24'h0, i2c_dat_o};

    // Address mapping:
    // The classic OpenCores I2C uses 3-bit register index:
    // 0: PRERlo, 1: PRERhi, 2: CTR, 3: TXR/RXR, 4: CR/SR, others reserved.
    wire [2:0] reg_adr = wb_adr_i[4:2];

    // I2C pads: open-drain behavior
    wire scl_pad_i, scl_pad_o, scl_padoen_o;
    wire sda_pad_i, sda_pad_o, sda_padoen_o;

    assign scl_pad_i = scl;
    assign sda_pad_i = sda;

    assign scl = (scl_padoen_o == 1'b0) ? scl_pad_o : 1'bz;
    assign sda = (sda_padoen_o == 1'b0) ? sda_pad_o : 1'bz;

    i2c_master_top u_i2c (
        .wb_clk_i   (clk),
        .wb_rst_i   (rst),

        .wb_adr_i   (reg_adr),
        .wb_dat_i   (wb_dat_i[7:0]),
        .wb_dat_o   (i2c_dat_o),
        .wb_we_i    (wb_we_i),
        .wb_stb_i   (wb_stb_i),
        .wb_cyc_i   (wb_cyc_i),
        .wb_ack_o   (wb_ack_o),

        // Interrupt (unused for now)
        .wb_inta_o  (),

        // I2C signals
        .scl_pad_i  (scl_pad_i),
        .scl_pad_o  (scl_pad_o),
        .scl_padoen_o (scl_padoen_o),
        .sda_pad_i  (sda_pad_i),
        .sda_pad_o  (sda_pad_o),
        .sda_padoen_o (sda_padoen_o)
    );

endmodule

NOTE:
- Adjust module/port names if your I2C core differs.
- The key is: we present a clean WB slave and drive sda/scl as open-drain IO.

================================================================================
STEP 3 — UPDATE top_soc.sv TO INSTANTIATE I2C (s2) + EXPOSE SDA/SCL PINS
================================================================================

We add:

- I2C pins to top_soc (i2c_sda, i2c_scl).
- Replace the s2 stub with i2c_wb_wrapper instance.

----- UPDATED FILE: ~/fpga/h3_phase1_sc/rtl/soc/top_soc.sv --------------------

module top_soc
(
    input  wire clk_50,
    input  wire reset_n,

    // SDRAM pins
    output wire [12:0] sdram_a,
    output wire [1:0]  sdram_ba,
    output wire        sdram_clk,
    output wire        sdram_cke,
    output wire        sdram_cs_n,
    output wire        sdram_ras_n,
    output wire        sdram_cas_n,
    output wire        sdram_we_n,
    output wire [1:0]  sdram_dqm,
    inout  wire [15:0] sdram_dq,

    // UART0 pins
    input  wire        uart0_rx,
    output wire        uart0_tx,

    // I2C0 pins (map to Arduino A4/A5)
    inout  wire        i2c_sda,
    inout  wire        i2c_scl

    // Later: SPI, GPIO, JTAG-UART
);

    wire clk = clk_50;
    wire rst = ~reset_n;

    // All AHB/wb signals same as Phase 1D; only difference is s2 hookup.

    // ... Hazard3 tile, AHB interconnect, Boot ROM, AHB→WB bridge, WB interconnect
    //     and SDRAM (u_sdram_wb) same as Phase 1D ...

    // UART0 on s1 (unchanged)
    uart16550_wb_wrapper u_uart0 (
        .clk        (clk),
        .rst        (rst),
        .wb_adr_i   (s1_adr_o),
        .wb_dat_i   (s1_dat_o),
        .wb_dat_o   (s1_dat_i),
        .wb_we_i    (s1_we_o),
        .wb_sel_i   (s1_sel_o),
        .wb_cyc_i   (s1_cyc_o),
        .wb_stb_i   (s1_stb_o),
        .wb_ack_o   (s1_ack_i),
        .wb_err_o   (s1_err_i),

        .uart_rx    (uart0_rx),
        .uart_tx    (uart0_tx)
    );

    // I2C0 on s2: real OpenCores I2C master
    i2c_wb_wrapper u_i2c0 (
        .clk        (clk),
        .rst        (rst),

        .wb_adr_i   (s2_adr_o),
        .wb_dat_i   (s2_dat_o),
        .wb_dat_o   (s2_dat_i),
        .wb_we_i    (s2_we_o),
        .wb_sel_i   (s2_sel_o),
        .wb_cyc_i   (s2_cyc_o),
        .wb_stb_i   (s2_stb_o),
        .wb_ack_o   (s2_ack_i),
        .wb_err_o   (s2_err_i),

        .sda        (i2c_sda),
        .scl        (i2c_scl)
    );

    // Keep stubs for others for now
    assign s3_dat_i = 32'hSPI0_000;  assign s3_ack_i = s3_cyc_o & s3_stb_o; assign s3_err_i = 1'b0;
    assign s4_dat_i = 32'hGPIO_000;  assign s4_ack_i = s4_cyc_o & s4_stb_o; assign s4_err_i = 1'b0;
    assign s5_dat_i = 32'hJTAG_000;  assign s5_ack_i = s5_cyc_o & s5_stb_o; assign s5_err_i = 1'b0;

endmodule

(In your actual file, ensure all the AHB/WB signal declarations and other instantiations
from Phase 1C/1D remain intact; only the s2 stub is replaced.)

================================================================================
STEP 4 — BOOT ROM I2C TEST (ROM-BASED, PRINTS STATUS OVER UART)
================================================================================

We’ll extend bootrom.c to:

- Initialize UART (as in 1D).
- Initialize I2C core:
  - Set prescaler for ~100 kHz from 50 MHz.
  - Enable core.
- Attempt a simple transaction:
  - Write to a target address (e.g. 0x68) with a dummy register index.
  - Check for ACK/NACK.
- Print result on UART.

I2C Register Map (OpenCores standard):

Base: 0x1000_0100

Offset  Register
0x00    PRERlo
0x04    PRERhi
0x08    CTR
0x0C    TXR/RXR
0x10    CR/SR

Bits:
- CTR:
  - EN (bit 7) = 1 to enable core
- CR:
  - STA (bit 7) = START
  - STO (bit 6) = STOP
  - RD  (bit 5) = read
  - WR  (bit 4) = write
  - ACK (bit 3) = ACK bit for reads
- SR:
  - RxACK (bit 7) = 0 if ACK received, 1 if NACK
  - TIP  (bit 1) = transfer in progress

----- UPDATED FILE: ~/hazard3_fw/bootrom/bootrom.c ----------------------------

#include <stdint.h>

#define UART0_BASE   0x10000000u
#define UART_RBR     (*(volatile uint32_t *)(UART0_BASE + 0x00))
#define UART_THR     (*(volatile uint32_t *)(UART0_BASE + 0x00))
#define UART_IER     (*(volatile uint32_t *)(UART0_BASE + 0x04))
#define UART_FCR     (*(volatile uint32_t *)(UART0_BASE + 0x08))
#define UART_LCR     (*(volatile uint32_t *)(UART0_BASE + 0x0C))
#define UART_MCR     (*(volatile uint32_t *)(UART0_BASE + 0x10))
#define UART_LSR     (*(volatile uint32_t *)(UART0_BASE + 0x14))

#define UART_LSR_DR   (1u << 0)
#define UART_LSR_THRE (1u << 5)

#define I2C0_BASE    0x10000100u
#define I2C_PRER_LO  (*(volatile uint32_t *)(I2C0_BASE + 0x00))
#define I2C_PRER_HI  (*(volatile uint32_t *)(I2C0_BASE + 0x04))
#define I2C_CTR      (*(volatile uint32_t *)(I2C0_BASE + 0x08))
#define I2C_TXR      (*(volatile uint32_t *)(I2C0_BASE + 0x0C))
#define I2C_RXR      (*(volatile uint32_t *)(I2C0_BASE + 0x0C))
#define I2C_CR       (*(volatile uint32_t *)(I2C0_BASE + 0x10))
#define I2C_SR       (*(volatile uint32_t *)(I2C0_BASE + 0x10))

#define I2C_CTR_EN   (1u << 7)
#define I2C_CR_STA   (1u << 7)
#define I2C_CR_STO   (1u << 6)
#define I2C_CR_RD    (1u << 5)
#define I2C_CR_WR    (1u << 4)
#define I2C_CR_ACK   (1u << 3)

#define I2C_SR_RXACK (1u << 7)
#define I2C_SR_TIP   (1u << 1)

static void uart_init(uint32_t sys_clk_hz, uint32_t baud)
{
    uint32_t divisor = sys_clk_hz / (16u * baud);

    UART_LCR = 0x80u;
    UART_THR = (divisor & 0xFFu);
    UART_IER = ((divisor >> 8) & 0xFFu);
    UART_LCR = 0x03u;
    UART_FCR = 0x07u;
    UART_MCR = 0x08u;
}

static void uart_putc(char c)
{
    while (!(UART_LSR & UART_LSR_THRE)) { }
    UART_THR = (uint8_t)c;
}

static void uart_puts(const char *s)
{
    while (*s) {
        if (*s == '\n') uart_putc('\r');
        uart_putc(*s++);
    }
}

static void i2c_init(uint32_t sys_clk_hz, uint32_t bus_khz)
{
    uint32_t freq = bus_khz * 1000u;
    uint32_t presc = (sys_clk_hz / (5u * freq)) - 1u; // from OC I2C docs

    I2C_PRER_LO = (presc & 0xFFu);
    I2C_PRER_HI = ((presc >> 8) & 0xFFu);
    I2C_CTR     = I2C_CTR_EN;
}

static int i2c_write_byte(uint8_t addr7, uint8_t reg, uint8_t data)
{
    // Send START + address (write)
    I2C_TXR = (uint32_t)((addr7 << 1) | 0u);
    I2C_CR  = I2C_CR_STA | I2C_CR_WR;
    while (I2C_SR & I2C_SR_TIP) { }
    if (I2C_SR & I2C_SR_RXACK) return -1;

    // Send register index
    I2C_TXR = reg;
    I2C_CR  = I2C_CR_WR;
    while (I2C_SR & I2C_SR_TIP) { }
    if (I2C_SR & I2C_SR_RXACK) return -2;

    // Send data + STOP
    I2C_TXR = data;
    I2C_CR  = I2C_CR_WR | I2C_CR_STO;
    while (I2C_SR & I2C_SR_TIP) { }
    if (I2C_SR & I2C_SR_RXACK) return -3;

    return 0;
}

void _start(void) __attribute__((section(".text.entry")));
void _start(void)
{
    const uint32_t SYS_CLK_HZ = 50000000u;

    uart_init(SYS_CLK_HZ, 115200u);
    uart_puts("Hazard3 Phase 1E: I2C master test\n");

    // Initialize I2C at 100 kHz
    i2c_init(SYS_CLK_HZ, 100u);
    uart_puts("I2C initialized at ~100 kHz\n");

    // Example: try writing to an I2C device at address 0x68, register 0x00, value 0x55
    // If no device is present, we will see NACK and print error.
    int rc = i2c_write_byte(0x68, 0x00, 0x55);

    if (rc == 0) {
        uart_puts("I2C write to 0x68 succeeded (ACK)\n");
    } else {
        uart_puts("I2C write to 0x68 failed with code: ");
        char c = '0' + (char)(-rc);
        uart_putc(c);
        uart_putc('\n');
    }

    while (1) {
        __asm__ volatile("wfi");
    }
}

Rebuild bootrom:

   cd ~/hazard3_fw/bootrom
   make

Copy/update bootrom.hex in the Quartus project directory or ensure path in boot_rom.sv is correct.

================================================================================
STEP 5 — QUARTUS: ADD FILES, SET PINS, COMPILE, PROGRAM (SRAM-ONLY)
================================================================================

1. Add I2C core RTL and wrapper:
   - Quartus → Add/Remove Files:
     - ../rtl/cores/opencores_i2c/*.v
     - ../rtl/soc/i2c_wb_wrapper.sv
     - Updated ../rtl/soc/top_soc.sv

2. Assign I2C pins:
   - Map i2c_sda and i2c_scl to the Arduino A4/A5 pins on DE0-Lite according
     to the board manual (they are usually dedicated I2C pins).
   - Ensure external pull-up resistors or on-board pull-ups are present (SDA/SCL
     are open-drain).

3. Boot ROM:
   - Ensure updated bootrom.hex is accessible for boot_rom.sv.

4. Compile:
   - Processing → Start Compilation.

5. Program SRAM only:
   - Quartus Programmer:
     - Hardware: USB-Blaster.
     - File: h3_phase1_sc.sof.
     - Mode: JTAG, “Program/Configure” checked.
     - START.
   - Do NOT create or program .pof. Do NOT program configuration flash.

6. Run test:
   - Connect UART0 to external USB-serial, open terminal at 115200 8N1.
   - Power on DE0-Lite → factory demo.
   - Program .sof over JTAG → Hazard3 SoC overlays in SRAM.
   - Reset board.
   - Observe UART output:
     - “Hazard3 Phase 1E: I2C master test”
     - “I2C initialized at ~100 kHz”
     - Either “I2C write to 0x68 succeeded (ACK)” or an error code.
   - Power-cycle:
     - Hazard3 SoC disappears.
     - Factory demo returns (ephemeral configuration rule satisfied).

================================================================================
WHAT PHASE 1E GIVES YOU TOWARD THE QUAD-CORE GOAL
================================================================================

- Real OpenCores I2C master integrated as a proper WB slave on s2.
- Clean memory-mapped I2C interface at 0x1000_0100 behind the same AHB→WB bridge
  used by SDRAM and UART.
- Verified system path:
  Hazard3 core → AHB fabric → AHB→WB → WB interconnect → I2C master → SDA/SCL.
- The bus + address map remain stable for future:
  - Adding SPI (1F), GPIO (1G), JTAG-UART (1H).
  - Building bootloader (1I) and HAL (1J).
  - Scaling to multiple Hazard3 tiles sharing this same memory/peripheral fabric.
#########END PHASE1F############
