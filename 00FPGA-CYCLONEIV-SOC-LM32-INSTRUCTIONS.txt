================================================================================
LM32 INSTRUMENT SOC ON DUEPROLOGIC – FULL STEP‑BY‑STEP BUILD (DSP + DDS/NCO +
LOGIC ANALYZER + USB PROTOCOL ANALYZER + SCOPE, PYTHON‑CONTROLLED, VOLATILE)
================================================================================
*** needs lm32-gcc
see 00fpga-build.sh to build lm32gcc

This is a complete, end‑to‑end set of instructions and code you can copy/paste
and adapt. It assumes:

- Board: Altera Cyclone IV FPGA Development Board – DueProLogic (EP4CE6 class)
- Tool: Quartus Prime Lite
- Soft CPU: LM32 (from M-Labs GitHub)
- Host: PC with Python 3, pyserial, numpy, scipy, matplotlib (for analysis)
- Connection: USB‑UART adapter wired to FPGA UART pins
- Design: FPGA = LM32 SoC + instrument peripherals; Host Python = UX, DSP design,
  USB decoding, visualization
- Volatility: You ONLY load a .sof into FPGA SRAM via JTAG. You NEVER program
  configuration flash. Power cycle = board returns to factory/demo image.

Everything below is explicit. There are no templates or placeholders; where a
value must be tuned (e.g., exact LM32 RTL filenames or DueProLogic pin numbers),
you substitute with your actual ones.

-------------------------------------------------------------------------------
1. DIRECTORY STRUCTURE
-------------------------------------------------------------------------------

On your host machine, create a project directory:

lm32_lab_soc/
  rtl/
    lm32/                   # LM32 CPU core (git clone)
    wb/                     # Wishbone fabric and peripherals
      wb_interconnect.v
      wb_rom.v
      wb_ram.v
      wb_uart.v
      wb_gpio.v
      wb_dsp.v
      wb_dds.v
      wb_logic_analyzer.v
      wb_usb_analyzer.v
      wb_scope.v
  top/
    soc_top.v               # Top-level RTL
  firmware/
    crt0.S                  # LM32 startup
    main.c                  # Command interpreter
    hw.h                    # Memory-mapped register addresses
    uart.c
    uart.h
    dsp.c
    dsp.h
    logic_analyzer.c
    logic_analyzer.h
    usb_analyzer.c
    usb_analyzer.h
    scope.c
    scope.h
    linker.ld
    Makefile
  host/
    common.py               # UART link helper
    dsp_host.py
    dds_host.py
    logic_analyzer_host.py
    scope_host.py
    usb_analyzer_host.py
  quartus/
    lm32_lab_soc.qpf        # Created by Quartus
    lm32_lab_soc.qsf        # Created by Quartus
    pin_notes.txt           # Your manual pin notes (edit yourself)

Create these directories:

mkdir -p lm32_lab_soc/rtl/wb
mkdir -p lm32_lab_soc/top
mkdir -p lm32_lab_soc/firmware
mkdir -p lm32_lab_soc/host
mkdir -p lm32_lab_soc/quartus

-------------------------------------------------------------------------------
2. GET LM32 CPU CORE
-------------------------------------------------------------------------------

cd lm32_lab_soc/rtl
git clone https://github.com/m-labs/lm32.git

You will later add the LM32 RTL files (from rtl/lm32/rtl/*.v) into the Quartus
project. You do not modify LM32 itself.

-------------------------------------------------------------------------------
3. WISHBONE PERIPHERALS RTL
-------------------------------------------------------------------------------
All the following Verilog files go under lm32_lab_soc/rtl/wb.

3.1 wb_rom.v
--------------

This is a 16 KB ROM mapped to 0x0000_0000 for LM32 instructions, initialized
from firmware.hex:

File: lm32_lab_soc/rtl/wb/wb_rom.v

--------------------------------------------------------------------------------
module wb_rom #(
    parameter AW = 12  // 2^12 words = 4096 x 32 bits = 16KB
) (
    input  wire         clk,
    input  wire         rst,
    // Wishbone (read-only)
    input  wire [31:0]  wb_adr_i,
    input  wire         wb_stb_i,
    input  wire         wb_cyc_i,
    input  wire         wb_we_i,
    input  wire [3:0]   wb_sel_i,
    input  wire [31:0]  wb_dat_i,
    output reg  [31:0]  wb_dat_o,
    output reg          wb_ack_o
);
    reg [31:0] mem [0:(1<<AW)-1];

    initial begin
        $readmemh("firmware.hex", mem);
    end

    wire [AW-1:0] addr = wb_adr_i[AW+1:2];

    always @(posedge clk) begin
        if (rst) begin
            wb_ack_o <= 1'b0;
            wb_dat_o <= 32'h00000000;
        end else begin
            wb_ack_o <= 1'b0;
            if (wb_cyc_i && wb_stb_i && !wb_we_i) begin
                wb_dat_o <= mem[addr];
                wb_ack_o <= 1'b1;
            end
        end
    end
endmodule
--------------------------------------------------------------------------------

3.2 wb_ram.v
------------

8 KB data RAM at 0x1000_0000 for LM32 stack and variables:

File: lm32_lab_soc/rtl/wb/wb_ram.v

--------------------------------------------------------------------------------
module wb_ram #(
    parameter AW = 11   // 2^11 words = 2048 x 32 bits = 8KB
) (
    input  wire         clk,
    input  wire         rst,
    // Wishbone
    input  wire [31:0]  wb_adr_i,
    input  wire         wb_stb_i,
    input  wire         wb_cyc_i,
    input  wire         wb_we_i,
    input  wire [3:0]   wb_sel_i,
    input  wire [31:0]  wb_dat_i,
    output reg  [31:0]  wb_dat_o,
    output reg          wb_ack_o
);
    reg [31:0] mem [0:(1<<AW)-1];

    wire [AW-1:0] addr = wb_adr_i[AW+1:2];

    always @(posedge clk) begin
        if (rst) begin
            wb_ack_o <= 1'b0;
            wb_dat_o <= 32'h0;
        end else begin
            wb_ack_o <= 1'b0;
            if (wb_cyc_i && wb_stb_i) begin
                wb_ack_o <= 1'b1;
                if (wb_we_i) begin
                    if (wb_sel_i[0]) mem[addr][7:0]   <= wb_dat_i[7:0];
                    if (wb_sel_i[1]) mem[addr][15:8]  <= wb_dat_i[15:8];
                    if (wb_sel_i[2]) mem[addr][23:16] <= wb_dat_i[23:16];
                    if (wb_sel_i[3]) mem[addr][31:24] <= wb_dat_i[31:24];
                end
                wb_dat_o <= mem[addr];
            end
        end
    end
endmodule
--------------------------------------------------------------------------------

3.3 wb_uart.v
-------------

UART at 0x2000_0000, 115200 baud from 50 MHz. Registers:

- 0x0: data (R/W)
- 0x4: status (R/W)
  - read bit0 = tx_ready (1=can write)
  - read bit1 = rx_ready (1=data available)
  - write bit1=1 clears rx_ready

File: lm32_lab_soc/rtl/wb/wb_uart.v

--------------------------------------------------------------------------------
module wb_uart #(
    parameter CLOCK_HZ = 50000000,
    parameter BAUD     = 115200
) (
    input  wire        clk,
    input  wire        rst,
    // Wishbone
    input  wire [31:0] wb_adr_i,
    input  wire        wb_stb_i,
    input  wire        wb_cyc_i,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    output reg         wb_ack_o,
    // UART pins
    input  wire        rx,
    output wire        tx
);
    localparam integer DIV = CLOCK_HZ / BAUD;

    reg [9:0]  tx_shift;
    reg [15:0] tx_cnt;
    reg [3:0]  tx_bit;
    reg        tx_busy;
    reg        tx_reg;
    assign tx = tx_reg;

    reg [9:0]  rx_shift;
    reg [15:0] rx_cnt;
    reg [3:0]  rx_bit;
    reg        rx_busy;
    reg [7:0]  rx_data;
    reg        rx_ready;

    wire sel = wb_cyc_i && wb_stb_i;
    wire [3:0] word_off = wb_adr_i[5:2];

    always @(posedge clk) begin
        if (rst) begin
            wb_ack_o  <= 1'b0;
            wb_dat_o  <= 32'h0;
            tx_reg    <= 1'b1;
            tx_busy   <= 1'b0;
            tx_cnt    <= 16'd0;
            tx_bit    <= 4'd0;
            rx_busy   <= 1'b0;
            rx_cnt    <= 16'd0;
            rx_bit    <= 4'd0;
            rx_data   <= 8'd0;
            rx_ready  <= 1'b0;
        end else begin
            wb_ack_o <= 1'b0;

            if (tx_busy) begin
                if (tx_cnt == 0) begin
                    tx_cnt   <= DIV - 1;
                    tx_reg   <= tx_shift[0];
                    tx_shift <= {1'b1, tx_shift[9:1]};
                    if (tx_bit == 4'd9) begin
                        tx_busy <= 1'b0;
                    end else begin
                        tx_bit <= tx_bit + 1;
                    end
                end else begin
                    tx_cnt <= tx_cnt - 1;
                end
            end

            if (!rx_busy && !rx && !rx_ready) begin
                rx_busy <= 1'b1;
                rx_cnt  <= DIV + (DIV/2);
                rx_bit  <= 4'd0;
            end else if (rx_busy) begin
                if (rx_cnt == 0) begin
                    rx_cnt   <= DIV;
                    rx_shift <= {rx, rx_shift[9:1]};
                    if (rx_bit == 4'd9) begin
                        rx_busy  <= 1'b0;
                        rx_data  <= rx_shift[8:1];
                        rx_ready <= 1'b1;
                    end else begin
                        rx_bit <= rx_bit + 1;
                    end
                end else begin
                    rx_cnt <= rx_cnt - 1;
                end
            end

            if (sel) begin
                wb_ack_o <= 1'b1;
                if (wb_we_i) begin
                    if (word_off == 4'h0) begin
                        if (!tx_busy) begin
                            tx_shift <= {1'b1, wb_dat_i[7:0], 1'b0};
                            tx_bit   <= 4'd0;
                            tx_cnt   <= DIV - 1;
                            tx_busy  <= 1'b1;
                        end
                    end else if (word_off == 4'h1) begin
                        if (wb_dat_i[1]) rx_ready <= 1'b0;
                    end
                end else begin
                    if (word_off == 4'h0) begin
                        wb_dat_o <= {24'h0, rx_data};
                        rx_ready <= 1'b0;
                    end else if (word_off == 4'h1) begin
                        wb_dat_o <= {30'h0, rx_ready, !tx_busy};
                    end else begin
                        wb_dat_o <= 32'h0;
                    end
                end
            end
        end
    end
endmodule
--------------------------------------------------------------------------------

3.4 wb_gpio.v
-------------

Simple GPIO at 0x2000_1000 for LEDs/buttons:

File: lm32_lab_soc/rtl/wb/wb_gpio.v

--------------------------------------------------------------------------------
module wb_gpio (
    input  wire        clk,
    input  wire        rst,
    // Wishbone
    input  wire [31:0] wb_adr_i,
    input  wire        wb_stb_i,
    input  wire        wb_cyc_i,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    output reg         wb_ack_o,
    // IO
    input  wire [31:0] gpio_in,
    output reg  [31:0] gpio_out
);
    wire sel = wb_cyc_i && wb_stb_i;
    wire [3:0] word_off = wb_adr_i[5:2];

    always @(posedge clk) begin
        if (rst) begin
            wb_ack_o <= 1'b0;
            wb_dat_o <= 32'h0;
            gpio_out <= 32'h0;
        end else begin
            wb_ack_o <= 1'b0;
            if (sel) begin
                wb_ack_o <= 1'b1;
                if (wb_we_i) begin
                    if (word_off == 4'h0) begin
                        if (wb_sel_i[0]) gpio_out[7:0]   <= wb_dat_i[7:0];
                        if (wb_sel_i[1]) gpio_out[15:8]  <= wb_dat_i[15:8];
                        if (wb_sel_i[2]) gpio_out[23:16] <= wb_dat_i[23:16];
                        if (wb_sel_i[3]) gpio_out[31:24] <= wb_dat_i[31:24];
                    end
                end else begin
                    if (word_off == 4'h0) begin
                        wb_dat_o <= gpio_out;
                    end else if (word_off == 4'h1) begin
                        wb_dat_o <= gpio_in;
                    end else begin
                        wb_dat_o <= 32'h0;
                    end
                end
            end
        end
    end
endmodule
--------------------------------------------------------------------------------

3.5 wb_dsp.v (FIR)
------------------

FIR DSP accelerator at 0x2000_2000:

- 0x0: ctrl/status
  - write bit0=1 start
  - write bit1=1 clear done
  - read bit0=busy
  - read bit1=done
- 0x8: input sample (signed 16-bit)
- 0xC: output sample (signed 32-bit)
- 0x10 + i*4: coefficient i (signed 16-bit)

File: lm32_lab_soc/rtl/wb/wb_dsp.v

--------------------------------------------------------------------------------
module wb_dsp #(
    parameter TAPS = 16
) (
    input  wire        clk,
    input  wire        rst,
    // Wishbone
    input  wire [31:0] wb_adr_i,
    input  wire        wb_stb_i,
    input  wire        wb_cyc_i,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    output reg         wb_ack_o
);
    reg start, busy, done;
    reg signed [15:0] sample_in;
    reg signed [31:0] sample_out;

    reg signed [15:0] coeffs [0:TAPS-1];
    reg signed [15:0] delay  [0:TAPS-1];

    integer i;
    reg [4:0] tap_index;
    reg signed [47:0] acc;

    wire sel = wb_cyc_i && wb_stb_i;
    wire [5:0] word_off = wb_adr_i[7:2];

    always @(posedge clk) begin
        if (rst) begin
            wb_ack_o   <= 1'b0;
            wb_dat_o   <= 32'h0;
            start      <= 1'b0;
            busy       <= 1'b0;
            done       <= 1'b0;
            sample_in  <= 16'sd0;
            sample_out <= 32'sd0;
            acc        <= 48'sd0;
            tap_index  <= 5'd0;
            for (i = 0; i < TAPS; i = i+1) begin
                coeffs[i] <= 16'sd0;
                delay[i]  <= 16'sd0;
            end
        end else begin
            wb_ack_o <= 1'b0;

            if (start && !busy) begin
                for (i = TAPS-1; i > 0; i = i-1)
                    delay[i] <= delay[i-1];
                delay[0] <= sample_in;
                acc      <= 48'sd0;
                tap_index <= 5'd0;
                busy     <= 1'b1;
                done     <= 1'b0;
                start    <= 1'b0;
            end else if (busy) begin
                acc <= acc + delay[tap_index] * coeffs[tap_index];
                if (tap_index == TAPS-1) begin
                    busy       <= 1'b0;
                    done       <= 1'b1;
                    sample_out <= acc[31:0];
                end else begin
                    tap_index <= tap_index + 1;
                end
            end

            if (sel) begin
                wb_ack_o <= 1'b1;
                if (wb_we_i) begin
                    case (word_off)
                        6'h0: begin
                            if (wb_dat_i[0]) start <= 1'b1;
                            if (wb_dat_i[1]) done  <= 1'b0;
                        end
                        6'h2: sample_in <= wb_dat_i[15:0];
                        default: begin
                            if (word_off >= 6'h4 && word_off < 6'h4 + TAPS) begin
                                coeffs[word_off - 6'h4] <= wb_dat_i[15:0];
                            end
                        end
                    endcase
                end else begin
                    case (word_off)
                        6'h0: wb_dat_o <= {30'h0, done, busy};
                        6'h2: wb_dat_o <= {16'h0, sample_in};
                        6'h3: wb_dat_o <= sample_out;
                        default: begin
                            if (word_off >= 6'h4 && word_off < 6'h4 + TAPS)
                                wb_dat_o <= {16'h0, coeffs[word_off - 6'h4]};
                            else
                                wb_dat_o <= 32'h0;
                        end
                    endcase
                end
            end
        end
    end
endmodule
--------------------------------------------------------------------------------

3.6 wb_dds.v (NCO/DDS)
----------------------

DDS at 0x2000_3000:

- 0x0: phase increment (PHASE_BITS)
- 0x4: amplitude (AMP_BITS)
- 0x8: control (bit0=enable)
- output: dds_out bus to pins

File: lm32_lab_soc/rtl/wb/wb_dds.v

--------------------------------------------------------------------------------
module wb_dds #(
    parameter PHASE_BITS = 24,
    parameter AMP_BITS   = 12
) (
    input  wire        clk,
    input  wire        rst,
    // Wishbone
    input  wire [31:0] wb_adr_i,
    input  wire        wb_stb_i,
    input  wire        wb_cyc_i,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    output reg         wb_ack_o,
    // Output
    output reg  [AMP_BITS-1:0] dds_out
);
    reg [PHASE_BITS-1:0] phase, phase_inc;
    reg [AMP_BITS-1:0]   amplitude;
    reg                  enable;

    wire sel = wb_cyc_i && wb_stb_i;
    wire [3:0] word_off = wb_adr_i[5:2];

    wire [AMP_BITS-1:0] tri =
        phase[PHASE_BITS-1] ? ~phase[PHASE_BITS-2 -: AMP_BITS] :
                              phase[PHASE_BITS-2 -: AMP_BITS];

    always @(posedge clk) begin
        if (rst) begin
            wb_ack_o  <= 1'b0;
            wb_dat_o  <= 32'h0;
            phase     <= {PHASE_BITS{1'b0}};
            phase_inc <= {PHASE_BITS{1'b0}};
            amplitude <= {AMP_BITS{1'b0}};
            enable    <= 1'b0;
            dds_out   <= {AMP_BITS{1'b0}};
        end else begin
            wb_ack_o <= 1'b0;

            if (enable) begin
                phase   <= phase + phase_inc;
                dds_out <= (tri * amplitude) >> (AMP_BITS-1);
            end else begin
                dds_out <= {AMP_BITS{1'b0}};
            end

            if (sel) begin
                wb_ack_o <= 1'b1;
                if (wb_we_i) begin
                    case (word_off)
                        4'h0: phase_inc <= wb_dat_i[PHASE_BITS-1:0];
                        4'h1: amplitude <= wb_dat_i[AMP_BITS-1:0];
                        4'h2: enable    <= wb_dat_i[0];
                    endcase
                end else begin
                    case (word_off)
                        4'h0: wb_dat_o <= phase_inc;
                        4'h1: wb_dat_o <= amplitude;
                        4'h2: wb_dat_o <= {31'h0, enable};
                        4'h3: wb_dat_o <= { {(32-AMP_BITS){1'b0}}, dds_out };
                        default: wb_dat_o <= 32'h0;
                    endcase
                end
            end
        end
    end
endmodule
--------------------------------------------------------------------------------

3.7 wb_logic_analyzer.v
------------------------

Logic analyzer at 0x2000_4000:

- 0x0: CONTROL (bit0=arm, bit1=single_mode)
- 0x4: STATUS (bit0=armed, bit1=triggered, bit2=done)
- 0x8: TRIG_VAL (lower PROBE_WIDTH bits)
- 0xC: TRIG_MASK
- 0x10: SAMPLE_COUNT
- 0x100..: captured samples

File: lm32_lab_soc/rtl/wb/wb_logic_analyzer.v

--------------------------------------------------------------------------------
module wb_logic_analyzer #(
    parameter PROBE_WIDTH = 16,
    parameter DEPTH       = 1024
) (
    input  wire                   clk,
    input  wire                   rst,
    // Wishbone
    input  wire [31:0]            wb_adr_i,
    input  wire                   wb_stb_i,
    input  wire                   wb_cyc_i,
    input  wire                   wb_we_i,
    input  wire [3:0]             wb_sel_i,
    input  wire [31:0]            wb_dat_i,
    output reg  [31:0]            wb_dat_o,
    output reg                    wb_ack_o,
    // Probes
    input  wire [PROBE_WIDTH-1:0] probe_in
);
    reg arm, single;
    reg armed, triggered, done;
    reg [PROBE_WIDTH-1:0] trig_val, trig_mask;
    reg [15:0] sample_count;

    reg [PROBE_WIDTH-1:0] mem [0:DEPTH-1];
    reg [15:0] wr_ptr;
    reg [15:0] samples_left;

    wire sel = wb_cyc_i && wb_stb_i;
    wire [7:0] word_off = wb_adr_i[9:2];

    always @(posedge clk) begin
        if (rst) begin
            wb_ack_o      <= 1'b0;
            wb_dat_o      <= 32'h0;
            arm           <= 1'b0;
            single        <= 1'b1;
            armed         <= 1'b0;
            triggered     <= 1'b0;
            done          <= 1'b0;
            trig_val      <= {PROBE_WIDTH{1'b0}};
            trig_mask     <= {PROBE_WIDTH{1'b0}};
            sample_count  <= 16'd256;
            wr_ptr        <= 16'd0;
            samples_left  <= 16'd0;
        end else begin
            wb_ack_o <= 1'b0;

            if (arm && !armed) begin
                armed        <= 1'b1;
                triggered    <= 1'b0;
                done         <= 1'b0;
                wr_ptr       <= 16'd0;
                samples_left <= sample_count;
            end

            if (armed && !done) begin
                if (!triggered) begin
                    if (((probe_in ^ trig_val) & trig_mask) == {PROBE_WIDTH{1'b0}}) begin
                        triggered <= 1'b1;
                    end
                end else begin
                    mem[wr_ptr] <= probe_in;
                    wr_ptr      <= wr_ptr + 1;
                    if (samples_left == 16'd1) begin
                        done   <= 1'b1;
                        armed  <= 1'b0;
                        if (!single) arm <= 1'b1;
                    end else begin
                        samples_left <= samples_left - 1;
                    end
                end
            end

            if (sel) begin
                wb_ack_o <= 1'b1;
                if (wb_we_i) begin
                    case (word_off)
                        8'h00: begin
                            arm    <= wb_dat_i[0];
                            single <= wb_dat_i[1];
                        end
                        8'h02: trig_val[15:0]  <= wb_dat_i[15:0];
                        8'h03: trig_mask[15:0] <= wb_dat_i[15:0];
                        8'h04: sample_count    <= wb_dat_i[15:0];
                    endcase
                end else begin
                    case (word_off)
                        8'h00: wb_dat_o <= {30'h0, single, arm};
                        8'h01: wb_dat_o <= {29'h0, done, triggered, armed};
                        8'h02: wb_dat_o <= {16'h0, trig_val[15:0]};
                        8'h03: wb_dat_o <= {16'h0, trig_mask[15:0]};
                        8'h04: wb_dat_o <= {16'h0, sample_count};
                        default: begin
                            if (word_off >= 8'h40) begin
                                wb_dat_o <= {16'h0, mem[word_off - 8'h40]};
                            end else begin
                                wb_dat_o <= 32'h0;
                            end
                        end
                    endcase
                end
            end
        end
    end
endmodule
--------------------------------------------------------------------------------

3.8 wb_usb_analyzer.v
----------------------

USB edge/time capture at 0x2000_5000:

- 0x0: CONTROL (bit0=arm, writing 1 resets buffer and starts capture)
- 0x4: STATUS (bit0=done, bit1=overflow)
- 0x8: COUNT (events captured)
- 0x100..: entries as {dp, dm, timestamp[15:0]} in bits [17:0] of each word.

File: lm32_lab_soc/rtl/wb/wb_usb_analyzer.v

--------------------------------------------------------------------------------
module wb_usb_analyzer #(
    parameter DEPTH = 512
) (
    input  wire clk,
    input  wire rst,
    // Wishbone
    input  wire [31:0] wb_adr_i,
    input  wire        wb_stb_i,
    input  wire        wb_cyc_i,
    input  wire        wb_we_i,
    input  wire [3:0]  wb_sel_i,
    input  wire [31:0] wb_dat_i,
    output reg  [31:0] wb_dat_o,
    output reg         wb_ack_o,
    // USB lines
    input  wire        usb_dp,
    input  wire        usb_dm
);
    reg arm, done, overflow;
    reg [15:0] sample_count;
    reg [15:0] wr_ptr;
    reg [15:0] timestamp;
    reg        prev_dp, prev_dm;

    reg [17:0] mem [0:DEPTH-1];

    wire sel = wb_cyc_i && wb_stb_i;
    wire [7:0] word_off = wb_adr_i[9:2];

    always @(posedge clk) begin
        if (rst) begin
            wb_ack_o     <= 1'b0;
            wb_dat_o     <= 32'h0;
            arm          <= 1'b0;
            done         <= 1'b0;
            overflow     <= 1'b0;
            sample_count <= 16'd0;
            wr_ptr       <= 16'd0;
            timestamp    <= 16'd0;
            prev_dp      <= 1'b0;
            prev_dm      <= 1'b0;
        end else begin
            wb_ack_o <= 1'b0;

            timestamp <= timestamp + 1;

            if (arm && !done) begin
                if ({usb_dp, usb_dm} != {prev_dp, prev_dm}) begin
                    if (wr_ptr < DEPTH) begin
                        mem[wr_ptr] <= {usb_dp, usb_dm, timestamp};
                        wr_ptr       <= wr_ptr + 1;
                        sample_count <= sample_count + 1;
                    end else begin
                        overflow <= 1'b1;
                        done     <= 1'b1;
                        arm      <= 1'b0;
                    end
                end
            end

            prev_dp <= usb_dp;
            prev_dm <= usb_dm;

            if (sel) begin
                wb_ack_o <= 1'b1;
                if (wb_we_i) begin
                    case (word_off)
                        8'h00: begin
                            arm <= wb_dat_i[0];
                            if (wb_dat_i[0]) begin
                                done         <= 1'b0;
                                overflow     <= 1'b0;
                                wr_ptr       <= 16'd0;
                                sample_count <= 16'd0;
                                timestamp    <= 16'd0;
                                prev_dp      <= usb_dp;
                                prev_dm      <= usb_dm;
                            end
                        end
                    endcase
                end else begin
                    case (word_off)
                        8'h00: wb_dat_o <= {31'h0, arm};
                        8'h01: wb_dat_o <= {30'h0, overflow, done};
                        8'h02: wb_dat_o <= {16'h0, sample_count};
                        default: begin
                            if (word_off >= 8'h40) begin
                                if (word_off - 8'h40 < sample_count)
                                    wb_dat_o <= {14'h0, mem[word_off - 8'h40]};
                                else
                                    wb_dat_o <= 32'h0;
                            end else begin
                                wb_dat_o <= 32'h0;
                            end
                        end
                    endcase
                end
            end
        end
    end
endmodule
--------------------------------------------------------------------------------

3.9 wb_scope.v
--------------

Scope sampler at 0x2000_6000:

- 0x0: CONTROL (bit0=arm)
- 0x4: STATUS (bit0=done)
- 0x8: SAMPLE_COUNT
- 0xC: DECIMATION
- 0x100..: samples (WIDTH bits stored in lower bits)

File: lm32_lab_soc/rtl/wb/wb_scope.v

--------------------------------------------------------------------------------
module wb_scope #(
    parameter WIDTH = 12,
    parameter DEPTH = 1024
) (
    input  wire             clk,
    input  wire             rst,
    // Wishbone
    input  wire [31:0]      wb_adr_i,
    input  wire             wb_stb_i,
    input  wire             wb_cyc_i,
    input  wire             wb_we_i,
    input  wire [3:0]       wb_sel_i,
    input  wire [31:0]      wb_dat_i,
    output reg  [31:0]      wb_dat_o,
    output reg              wb_ack_o,
    // Input signal
    input  wire [WIDTH-1:0] sig_in
);
    reg arm, done;
    reg [15:0] sample_count;
    reg [15:0] decim;
    reg [15:0] decim_cnt;
    reg [15:0] wr_ptr;

    reg [WIDTH-1:0] mem [0:DEPTH-1];

    wire sel = wb_cyc_i && wb_stb_i;
    wire [7:0] word_off = wb_adr_i[9:2];

    always @(posedge clk) begin
        if (rst) begin
            wb_ack_o     <= 1'b0;
            wb_dat_o     <= 32'h0;
            arm          <= 1'b0;
            done         <= 1'b0;
            sample_count <= 16'd256;
            decim        <= 16'd1;
            decim_cnt    <= 16'd0;
            wr_ptr       <= 16'd0;
        end else begin
            wb_ack_o <= 1'b0;

            if (arm && !done) begin
                if (decim_cnt == 0) begin
                    mem[wr_ptr] <= sig_in;
                    wr_ptr      <= wr_ptr + 1;
                    decim_cnt   <= decim - 1;
                    if (wr_ptr == sample_count - 1) begin
                        done <= 1'b1;
                        arm  <= 1'b0;
                    end
                end else begin
                    decim_cnt <= decim_cnt - 1;
                end
            end

            if (sel) begin
                wb_ack_o <= 1'b1;
                if (wb_we_i) begin
                    case (word_off)
                        8'h00: begin
                            arm <= wb_dat_i[0];
                            if (wb_dat_i[0]) begin
                                done      <= 1'b0;
                                wr_ptr    <= 16'd0;
                                decim_cnt <= 16'd0;
                            end
                        end
                        8'h02: sample_count <= wb_dat_i[15:0];
                        8'h03: decim        <= wb_dat_i[15:0];
                    endcase
                end else begin
                    case (word_off)
                        8'h00: wb_dat_o <= {31'h0, arm};
                        8'h01: wb_dat_o <= {31'h0, done};
                        8'h02: wb_dat_o <= {16'h0, sample_count};
                        8'h03: wb_dat_o <= {16'h0, decim};
                        default: begin
                            if (word_off >= 8'h40) begin
                                wb_dat_o <= { {(32-WIDTH){1'b0}}, mem[word_off - 8'h40] };
                            end else begin
                                wb_dat_o <= 32'h0;
                            end
                        end
                    endcase
                end
            end
        end
    end
endmodule
--------------------------------------------------------------------------------

3.10 wb_interconnect.v
----------------------

Wishbone interconnect for LM32 data bus:

File: lm32_lab_soc/rtl/wb/wb_interconnect.v

--------------------------------------------------------------------------------
module wb_interconnect (
    input  wire        clk,
    input  wire        rst,
    // Master (LM32 data WB)
    input  wire [31:0] m_adr_i,
    input  wire        m_stb_i,
    input  wire        m_cyc_i,
    input  wire        m_we_i,
    input  wire [3:0]  m_sel_i,
    input  wire [31:0] m_dat_i,
    output reg  [31:0] m_dat_o,
    output reg         m_ack_o,
    // Slave 0: RAM
    output reg  [31:0] s0_adr_o,
    output reg         s0_stb_o,
    output reg         s0_cyc_o,
    output reg         s0_we_o,
    output reg  [3:0]  s0_sel_o,
    output reg  [31:0] s0_dat_o,
    input  wire [31:0] s0_dat_i,
    input  wire        s0_ack_i,
    // Slave 1: UART
    output reg  [31:0] s1_adr_o,
    output reg         s1_stb_o,
    output reg         s1_cyc_o,
    output reg         s1_we_o,
    output reg  [3:0]  s1_sel_o,
    output reg  [31:0] s1_dat_o,
    input  wire [31:0] s1_dat_i,
    input  wire        s1_ack_i,
    // Slave 2: GPIO
    output reg  [31:0] s2_adr_o,
    output reg         s2_stb_o,
    output reg         s2_cyc_o,
    output reg         s2_we_o,
    output reg  [3:0]  s2_sel_o,
    output reg  [31:0] s2_dat_o,
    input  wire [31:0] s2_dat_i,
    input  wire        s2_ack_i,
    // Slave 3: DSP
    output reg  [31:0] s3_adr_o,
    output reg         s3_stb_o,
    output reg         s3_cyc_o,
    output reg         s3_we_o,
    output reg  [3:0]  s3_sel_o,
    output reg  [31:0] s3_dat_o,
    input  wire [31:0] s3_dat_i,
    input  wire        s3_ack_i,
    // Slave 4: DDS
    output reg  [31:0] s4_adr_o,
    output reg         s4_stb_o,
    output reg         s4_cyc_o,
    output reg         s4_we_o,
    output reg  [3:0]  s4_sel_o,
    output reg  [31:0] s4_dat_o,
    input  wire [31:0] s4_dat_i,
    input  wire        s4_ack_i,
    // Slave 5: Logic analyzer
    output reg  [31:0] s5_adr_o,
    output reg         s5_stb_o,
    output reg         s5_cyc_o,
    output reg         s5_we_o,
    output reg  [3:0]  s5_sel_o,
    output reg  [31:0] s5_dat_o,
    input  wire [31:0] s5_dat_i,
    input  wire        s5_ack_i,
    // Slave 6: USB analyzer
    output reg  [31:0] s6_adr_o,
    output reg         s6_stb_o,
    output reg         s6_cyc_o,
    output reg         s6_we_o,
    output reg  [3:0]  s6_sel_o,
    output reg  [31:0] s6_dat_o,
    input  wire [31:0] s6_dat_i,
    input  wire        s6_ack_i,
    // Slave 7: Scope
    output reg  [31:0] s7_adr_o,
    output reg         s7_stb_o,
    output reg         s7_cyc_o,
    output reg         s7_we_o,
    output reg  [3:0]  s7_sel_o,
    output reg  [31:0] s7_dat_o,
    input  wire [31:0] s7_dat_i,
    input  wire        s7_ack_i
);
    wire sel_ram   = (m_adr_i[31:28] == 4'h1);
    wire sel_uart  = (m_adr_i[31:20] == 12'h200);
    wire sel_gpio  = (m_adr_i[31:20] == 12'h201);
    wire sel_dsp   = (m_adr_i[31:20] == 12'h202);
    wire sel_dds   = (m_adr_i[31:20] == 12'h203);
    wire sel_la    = (m_adr_i[31:20] == 12'h204);
    wire sel_usb   = (m_adr_i[31:20] == 12'h205);
    wire sel_scope = (m_adr_i[31:20] == 12'h206);

    always @(*) begin
        s0_stb_o = 0; s0_cyc_o = 0; s0_we_o = 0;
        s1_stb_o = 0; s1_cyc_o = 0; s1_we_o = 0;
        s2_stb_o = 0; s2_cyc_o = 0; s2_we_o = 0;
        s3_stb_o = 0; s3_cyc_o = 0; s3_we_o = 0;
        s4_stb_o = 0; s4_cyc_o = 0; s4_we_o = 0;
        s5_stb_o = 0; s5_cyc_o = 0; s5_we_o = 0;
        s6_stb_o = 0; s6_cyc_o = 0; s6_we_o = 0;
        s7_stb_o = 0; s7_cyc_o = 0; s7_we_o = 0;

        s0_adr_o = m_adr_i; s1_adr_o = m_adr_i; s2_adr_o = m_adr_i; s3_adr_o = m_adr_i;
        s4_adr_o = m_adr_i; s5_adr_o = m_adr_i; s6_adr_o = m_adr_i; s7_adr_o = m_adr_i;
        s0_sel_o = m_sel_i; s1_sel_o = m_sel_i; s2_sel_o = m_sel_i; s3_sel_o = m_sel_i;
        s4_sel_o = m_sel_i; s5_sel_o = m_sel_i; s6_sel_o = m_sel_i; s7_sel_o = m_sel_i;
        s0_dat_o = m_dat_i; s1_dat_o = m_dat_i; s2_dat_o = m_dat_i; s3_dat_o = m_dat_i;
        s4_dat_o = m_dat_i; s5_dat_o = m_dat_i; s6_dat_o = m_dat_i; s7_dat_o = m_dat_i;

        if (m_cyc_i && m_stb_i) begin
            if (sel_ram) begin
                s0_cyc_o = 1; s0_stb_o = 1; s0_we_o = m_we_i;
            end else if (sel_uart) begin
                s1_cyc_o = 1; s1_stb_o = 1; s1_we_o = m_we_i;
            end else if (sel_gpio) begin
                s2_cyc_o = 1; s2_stb_o = 1; s2_we_o = m_we_i;
            end else if (sel_dsp) begin
                s3_cyc_o = 1; s3_stb_o = 1; s3_we_o = m_we_i;
            end else if (sel_dds) begin
                s4_cyc_o = 1; s4_stb_o = 1; s4_we_o = m_we_i;
            end else if (sel_la) begin
                s5_cyc_o = 1; s5_stb_o = 1; s5_we_o = m_we_i;
            end else if (sel_usb) begin
                s6_cyc_o = 1; s6_stb_o = 1; s6_we_o = m_we_i;
            end else if (sel_scope) begin
                s7_cyc_o = 1; s7_stb_o = 1; s7_we_o = m_we_i;
            end
        end
    end

    always @(*) begin
        m_ack_o = 1'b0;
        m_dat_o = 32'h0;
        if (sel_ram)   begin m_ack_o = s0_ack_i; m_dat_o = s0_dat_i; end
        else if (sel_uart)  begin m_ack_o = s1_ack_i; m_dat_o = s1_dat_i; end
        else if (sel_gpio)  begin m_ack_o = s2_ack_i; m_dat_o = s2_dat_i; end
        else if (sel_dsp)   begin m_ack_o = s3_ack_i; m_dat_o = s3_dat_i; end
        else if (sel_dds)   begin m_ack_o = s4_ack_i; m_dat_o = s4_dat_i; end
        else if (sel_la)    begin m_ack_o = s5_ack_i; m_dat_o = s5_dat_i; end
        else if (sel_usb)   begin m_ack_o = s6_ack_i; m_dat_o = s6_dat_i; end
        else if (sel_scope) begin m_ack_o = s7_ack_i; m_dat_o = s7_dat_i; end
    end
endmodule
--------------------------------------------------------------------------------

-------------------------------------------------------------------------------
4. TOP-LEVEL SOC – soc_top.v
-------------------------------------------------------------------------------

File: lm32_lab_soc/top/soc_top.v

--------------------------------------------------------------------------------
module soc_top (
    input  wire clk_50,
    input  wire reset_n,

    input  wire uart_rx,
    output wire uart_tx,

    output wire [7:0] leds,
    input  wire [7:0] buttons,

    input  wire [15:0] la_probes,
    input  wire        usb_dp,
    input  wire        usb_dm,
    input  wire [11:0] scope_in,
    output wire [11:0] dds_out
);
    wire clk = clk_50;
    wire rst = ~reset_n;

    wire [31:0] I_ADR, I_DAT_I;
    wire        I_CYC, I_STB, I_ACK;
    wire        I_WE;
    wire [3:0]  I_SEL;
    wire [31:0] I_DAT_O;

    wire [31:0] D_ADR, D_DAT_I;
    wire        D_CYC, D_STB, D_ACK;
    wire        D_WE;
    wire [3:0]  D_SEL;
    wire [31:0] D_DAT_O;

    lm32_cpu cpu (
        .clk_i(clk),
        .rst_i(rst),
        .I_ADR_O(I_ADR),
        .I_DAT_I(I_DAT_I),
        .I_CYC_O(I_CYC),
        .I_STB_O(I_STB),
        .I_ACK_I(I_ACK),
        .I_WE_O(I_WE),
        .I_SEL_O(I_SEL),
        .I_DAT_O(I_DAT_O),
        .D_ADR_O(D_ADR),
        .D_DAT_I(D_DAT_I),
        .D_CYC_O(D_CYC),
        .D_STB_O(D_STB),
        .D_ACK_I(D_ACK),
        .D_WE_O(D_WE),
        .D_SEL_O(D_SEL),
        .D_DAT_O(D_DAT_O),
        .interrupt(32'h0),
        .ext_break(1'b0),
        .ext_vec(32'h0)
    );

    wb_rom rom (
        .clk(clk),
        .rst(rst),
        .wb_adr_i(I_ADR),
        .wb_stb_i(I_STB),
        .wb_cyc_i(I_CYC),
        .wb_we_i(I_WE),
        .wb_sel_i(I_SEL),
        .wb_dat_i(I_DAT_O),
        .wb_dat_o(I_DAT_I),
        .wb_ack_o(I_ACK)
    );

    wire [31:0] s0_adr, s0_dat_o, s0_dat_i;
    wire        s0_stb, s0_cyc, s0_we, s0_ack;
    wire [3:0]  s0_sel;

    wb_ram ram (
        .clk(clk),
        .rst(rst),
        .wb_adr_i(s0_adr),
        .wb_stb_i(s0_stb),
        .wb_cyc_i(s0_cyc),
        .wb_we_i(s0_we),
        .wb_sel_i(s0_sel),
        .wb_dat_i(s0_dat_o),
        .wb_dat_o(s0_dat_i),
        .wb_ack_o(s0_ack)
    );

    wire [31:0] s1_adr, s1_dat_o, s1_dat_i;
    wire        s1_stb, s1_cyc, s1_we, s1_ack;
    wire [3:0]  s1_sel;

    wb_uart uart (
        .clk(clk),
        .rst(rst),
        .wb_adr_i(s1_adr),
        .wb_stb_i(s1_stb),
        .wb_cyc_i(s1_cyc),
        .wb_we_i(s1_we),
        .wb_sel_i(s1_sel),
        .wb_dat_i(s1_dat_o),
        .wb_dat_o(s1_dat_i),
        .wb_ack_o(s1_ack),
        .rx(uart_rx),
        .tx(uart_tx)
    );

    wire [31:0] s2_adr, s2_dat_o, s2_dat_i;
    wire        s2_stb, s2_cyc, s2_we, s2_ack;
    wire [3:0]  s2_sel;
    wire [31:0] gpio_out;
    wire [31:0] gpio_in = {16'h0000, buttons, 8'h00};

    wb_gpio gpio (
        .clk(clk),
        .rst(rst),
        .wb_adr_i(s2_adr),
        .wb_stb_i(s2_stb),
        .wb_cyc_i(s2_cyc),
        .wb_we_i(s2_we),
        .wb_sel_i(s2_sel),
        .wb_dat_i(s2_dat_o),
        .wb_dat_o(s2_dat_i),
        .wb_ack_o(s2_ack),
        .gpio_in(gpio_in),
        .gpio_out(gpio_out)
    );

    assign leds = gpio_out[7:0];

    wire [31:0] s3_adr, s3_dat_o, s3_dat_i;
    wire        s3_stb, s3_cyc, s3_we, s3_ack;
    wire [3:0]  s3_sel;

    wb_dsp dsp (
        .clk(clk),
        .rst(rst),
        .wb_adr_i(s3_adr),
        .wb_stb_i(s3_stb),
        .wb_cyc_i(s3_cyc),
        .wb_we_i(s3_we),
        .wb_sel_i(s3_sel),
        .wb_dat_i(s3_dat_o),
        .wb_dat_o(s3_dat_i),
        .wb_ack_o(s3_ack)
    );

    wire [31:0] s4_adr, s4_dat_o, s4_dat_i;
    wire        s4_stb, s4_cyc, s4_we, s4_ack;
    wire [3:0]  s4_sel;

    wb_dds dds (
        .clk(clk),
        .rst(rst),
        .wb_adr_i(s4_adr),
        .wb_stb_i(s4_stb),
        .wb_cyc_i(s4_cyc),
        .wb_we_i(s4_we),
        .wb_sel_i(s4_sel),
        .wb_dat_i(s4_dat_o),
        .wb_dat_o(s4_dat_i),
        .wb_ack_o(s4_ack),
        .dds_out(dds_out)
    );

    wire [31:0] s5_adr, s5_dat_o, s5_dat_i;
    wire        s5_stb, s5_cyc, s5_we, s5_ack;
    wire [3:0]  s5_sel;

    wb_logic_analyzer la (
        .clk(clk),
        .rst(rst),
        .wb_adr_i(s5_adr),
        .wb_stb_i(s5_stb),
        .wb_cyc_i(s5_cyc),
        .wb_we_i(s5_we),
        .wb_sel_i(s5_sel),
        .wb_dat_i(s5_dat_o),
        .wb_dat_o(s5_dat_i),
        .wb_ack_o(s5_ack),
        .probe_in(la_probes)
    );

    wire [31:0] s6_adr, s6_dat_o, s6_dat_i;
    wire        s6_stb, s6_cyc, s6_we, s6_ack;
    wire [3:0]  s6_sel;

    wb_usb_analyzer usb (
        .clk(clk),
        .rst(rst),
        .wb_adr_i(s6_adr),
        .wb_stb_i(s6_stb),
        .wb_cyc_i(s6_cyc),
        .wb_we_i(s6_we),
        .wb_sel_i(s6_sel),
        .wb_dat_i(s6_dat_o),
        .wb_dat_o(s6_dat_i),
        .wb_ack_o(s6_ack),
        .usb_dp(usb_dp),
        .usb_dm(usb_dm)
    );

    wire [31:0] s7_adr, s7_dat_o, s7_dat_i;
    wire        s7_stb, s7_cyc, s7_we, s7_ack;
    wire [3:0]  s7_sel;

    wb_scope scope (
        .clk(clk),
        .rst(rst),
        .wb_adr_i(s7_adr),
        .wb_stb_i(s7_stb),
        .wb_cyc_i(s7_cyc),
        .wb_we_i(s7_we),
        .wb_sel_i(s7_sel),
        .wb_dat_i(s7_dat_o),
        .wb_dat_o(s7_dat_i),
        .wb_ack_o(s7_ack),
        .sig_in(scope_in)
    );

    wb_interconnect inter (
        .clk(clk),
        .rst(rst),
        .m_adr_i(D_ADR),
        .m_stb_i(D_STB),
        .m_cyc_i(D_CYC),
        .m_we_i(D_WE),
        .m_sel_i(D_SEL),
        .m_dat_i(D_DAT_O),
        .m_dat_o(D_DAT_I),
        .m_ack_o(D_ACK),
        .s0_adr_o(s0_adr), .s0_stb_o(s0_stb), .s0_cyc_o(s0_cyc), .s0_we_o(s0_we), .s0_sel_o(s0_sel), .s0_dat_o(s0_dat_o), .s0_dat_i(s0_dat_i), .s0_ack_i(s0_ack),
        .s1_adr_o(s1_adr), .s1_stb_o(s1_stb), .s1_cyc_o(s1_cyc), .s1_we_o(s1_we), .s1_sel_o(s1_sel), .s1_dat_o(s1_dat_o), .s1_dat_i(s1_dat_i), .s1_ack_i(s1_ack),
        .s2_adr_o(s2_adr), .s2_stb_o(s2_stb), .s2_cyc_o(s2_cyc), .s2_we_o(s2_we), .s2_sel_o(s2_sel), .s2_dat_o(s2_dat_o), .s2_dat_i(s2_dat_i), .s2_ack_i(s2_ack),
        .s3_adr_o(s3_adr), .s3_stb_o(s3_stb), .s3_cyc_o(s3_cyc), .s3_we_o(s3_we), .s3_sel_o(s3_sel), .s3_dat_o(s3_dat_o), .s3_dat_i(s3_dat_i), .s3_ack_i(s3_ack),
        .s4_adr_o(s4_adr), .s4_stb_o(s4_stb), .s4_cyc_o(s4_cyc), .s4_we_o(s4_we), .s4_sel_o(s4_sel), .s4_dat_o(s4_dat_o), .s4_dat_i(s4_dat_i), .s4_ack_i(s4_ack),
        .s5_adr_o(s5_adr), .s5_stb_o(s5_stb), .s5_cyc_o(s5_cyc), .s5_we_o(s5_we), .s5_sel_o(s5_sel), .s5_dat_o(s5_dat_o), .s5_dat_i(s5_dat_i), .s5_ack_i(s5_ack),
        .s6_adr_o(s6_adr), .s6_stb_o(s6_stb), .s6_cyc_o(s6_cyc), .s6_we_o(s6_we), .s6_sel_o(s6_sel), .s6_dat_o(s6_dat_o), .s6_dat_i(s6_dat_i), .s6_ack_i(s6_ack),
        .s7_adr_o(s7_adr), .s7_stb_o(s7_stb), .s7_cyc_o(s7_cyc), .s7_we_o(s7_we), .s7_sel_o(s7_sel), .s7_dat_o(s7_dat_o), .s7_dat_i(s7_dat_i), .s7_ack_i(s7_ack)
    );
endmodule
--------------------------------------------------------------------------------

-------------------------------------------------------------------------------
5. FIRMWARE (LM32)
-------------------------------------------------------------------------------

5.1 hw.h
--------

File: lm32_lab_soc/firmware/hw.h

--------------------------------------------------------------------------------
#ifndef HW_H
#define HW_H

#include <stdint.h>

#define UART_BASE       0x20000000
#define GPIO_BASE       0x20001000
#define DSP_BASE        0x20002000
#define DDS_BASE        0x20003000
#define LA_BASE         0x20004000
#define USB_BASE        0x20005000
#define SCOPE_BASE      0x20006000

#define UART_DATA       (*(volatile uint32_t *)(UART_BASE + 0x0))
#define UART_STATUS     (*(volatile uint32_t *)(UART_BASE + 0x4))

#define GPIO_OUT        (*(volatile uint32_t *)(GPIO_BASE + 0x0))
#define GPIO_IN         (*(volatile uint32_t *)(GPIO_BASE + 0x4))

#define DSP_CTRL        (*(volatile uint32_t *)(DSP_BASE + 0x0))
#define DSP_STATUS      (*(volatile uint32_t *)(DSP_BASE + 0x0))
#define DSP_IN          (*(volatile uint32_t *)(DSP_BASE + 0x8))
#define DSP_OUT         (*(volatile uint32_t *)(DSP_BASE + 0xC))
#define DSP_COEFF(i)    (*(volatile uint32_t *)(DSP_BASE + 0x10 + ((i) * 4)))

#define DDS_PHASE_INC   (*(volatile uint32_t *)(DDS_BASE + 0x0))
#define DDS_AMPL        (*(volatile uint32_t *)(DDS_BASE + 0x4))
#define DDS_CTRL        (*(volatile uint32_t *)(DDS_BASE + 0x8))

#define LA_CTRL         (*(volatile uint32_t *)(LA_BASE + 0x0))
#define LA_STATUS       (*(volatile uint32_t *)(LA_BASE + 0x4))
#define LA_TRIGVAL      (*(volatile uint32_t *)(LA_BASE + 0x8))
#define LA_TRIGMSK      (*(volatile uint32_t *)(LA_BASE + 0xC))
#define LA_SAMPLES      (*(volatile uint32_t *)(LA_BASE + 0x10))
#define LA_DATA(i)      (*(volatile uint32_t *)(LA_BASE + 0x100 + ((i) * 4)))

#define USB_CTRL        (*(volatile uint32_t *)(USB_BASE + 0x0))
#define USB_STATUS      (*(volatile uint32_t *)(USB_BASE + 0x4))
#define USB_COUNT       (*(volatile uint32_t *)(USB_BASE + 0x8))
#define USB_ENTRY(i)    (*(volatile uint32_t *)(USB_BASE + 0x100 + ((i) * 4)))

#define SC_CTRL         (*(volatile uint32_t *)(SCOPE_BASE + 0x0))
#define SC_STATUS       (*(volatile uint32_t *)(SCOPE_BASE + 0x4))
#define SC_SAMPLES      (*(volatile uint32_t *)(SCOPE_BASE + 0x8))
#define SC_DECIM        (*(volatile uint32_t *)(SCOPE_BASE + 0xC))
#define SC_DATA(i)      (*(volatile uint32_t *)(SCOPE_BASE + 0x100 + ((i) * 4)))

#endif
--------------------------------------------------------------------------------

5.2 uart.h / uart.c
-------------------

File: lm32_lab_soc/firmware/uart.h

--------------------------------------------------------------------------------
#ifndef UART_H
#define UART_H

#include <stdint.h>

void uart_putc(char c);
char uart_getc(void);
void uart_puts(const char *s);
void uart_puthex(uint32_t v);
int  uart_readline(char *buf, int maxlen);

#endif
--------------------------------------------------------------------------------

File: lm32_lab_soc/firmware/uart.c

--------------------------------------------------------------------------------
#include <stdint.h>
#include "hw.h"
#include "uart.h"

void uart_putc(char c) {
    while (!(UART_STATUS & 1));
    UART_DATA = (uint8_t)c;
}

char uart_getc(void) {
    while (!(UART_STATUS & 2));
    uint32_t v = UART_DATA;
    return (char)(v & 0xFF);
}

void uart_puts(const char *s) {
    while (*s) {
        if (*s == '\n') uart_putc('\r');
        uart_putc(*s++);
    }
}

void uart_puthex(uint32_t v) {
    const char *hex = "0123456789ABCDEF";
    for (int i = 7; i >= 0; i--) {
        uart_putc(hex[(v >> (4*i)) & 0xF]);
    }
}

int uart_readline(char *buf, int maxlen) {
    int i = 0;
    while (i < maxlen - 1) {
        char c = uart_getc();
        if (c == '\r' || c == '\n') break;
        buf[i++] = c;
        uart_putc(c);
    }
    buf[i] = 0;
    uart_puts("\r\n");
    return i;
}
--------------------------------------------------------------------------------

5.3 dsp.h / dsp.c
-----------------

File: lm32_lab_soc/firmware/dsp.h

--------------------------------------------------------------------------------
#ifndef DSP_H
#define DSP_H

#include <stdint.h>

void dsp_reset(void);
void dsp_set_coeff(uint32_t idx, int16_t c);
int32_t dsp_run_sample(int16_t s);

#endif
--------------------------------------------------------------------------------

File: lm32_lab_soc/firmware/dsp.c

--------------------------------------------------------------------------------
#include <stdint.h>
#include "hw.h"
#include "dsp.h"

#define DSP_TAPS 16

void dsp_reset(void) {
    for (int i = 0; i < DSP_TAPS; i++) {
        DSP_COEFF(i) = 0;
    }
    DSP_CTRL = 2;
}

void dsp_set_coeff(uint32_t idx, int16_t c) {
    if (idx >= DSP_TAPS) return;
    DSP_COEFF(idx) = (uint16_t)c;
}

int32_t dsp_run_sample(int16_t s) {
    DSP_IN = (uint16_t)s;
    DSP_CTRL = 1;
    while (!(DSP_STATUS & 0x2));
    DSP_CTRL = 2;
    return (int32_t)DSP_OUT;
}
--------------------------------------------------------------------------------

5.4 logic_analyzer.h / logic_analyzer.c
---------------------------------------

File: lm32_lab_soc/firmware/logic_analyzer.h

--------------------------------------------------------------------------------
#ifndef LOGIC_ANALYZER_H
#define LOGIC_ANALYZER_H

#include <stdint.h>

void la_set_trig(uint16_t val, uint16_t mask);
void la_set_samples(uint16_t count);
void la_arm(void);
void la_wait_done(void);
uint16_t la_get_sample(uint32_t index);

#endif
--------------------------------------------------------------------------------

File: lm32_lab_soc/firmware/logic_analyzer.c

--------------------------------------------------------------------------------
#include "hw.h"
#include "logic_analyzer.h"

void la_set_trig(uint16_t val, uint16_t mask) {
    LA_TRIGVAL = val;
    LA_TRIGMSK = mask;
}

void la_set_samples(uint16_t count) {
    LA_SAMPLES = count;
}

void la_arm(void) {
    LA_CTRL = 0x1;
}

void la_wait_done(void) {
    while (!(LA_STATUS & (1<<2)));
}

uint16_t la_get_sample(uint32_t index) {
    uint32_t v = LA_DATA(index);
    return (uint16_t)(v & 0xFFFF);
}
--------------------------------------------------------------------------------

5.5 usb_analyzer.h / usb_analyzer.c
-----------------------------------

File: lm32_lab_soc/firmware/usb_analyzer.h

--------------------------------------------------------------------------------
#ifndef USB_ANALYZER_H
#define USB_ANALYZER_H

#include <stdint.h>

void usb_arm(void);
void usb_wait_done(void);
uint32_t usb_get_status(void);
uint16_t usb_get_count(void);
uint32_t usb_get_entry(uint32_t index);

#endif
--------------------------------------------------------------------------------

File: lm32_lab_soc/firmware/usb_analyzer.c

--------------------------------------------------------------------------------
#include "hw.h"
#include "usb_analyzer.h"

void usb_arm(void) {
    USB_CTRL = 1;
}

void usb_wait_done(void) {
    while (!(USB_STATUS & 0x1));
}

uint32_t usb_get_status(void) {
    return USB_STATUS;
}

uint16_t usb_get_count(void) {
    return (uint16_t)(USB_COUNT & 0xFFFF);
}

uint32_t usb_get_entry(uint32_t index) {
    return USB_ENTRY(index);
}
--------------------------------------------------------------------------------

5.6 scope.h / scope.c
---------------------

File: lm32_lab_soc/firmware/scope.h

--------------------------------------------------------------------------------
#ifndef SCOPE_H
#define SCOPE_H

#include <stdint.h>

void scope_set(uint16_t samples, uint16_t decim);
void scope_arm(void);
void scope_wait_done(void);
uint16_t scope_get_sample(uint32_t index);

#endif
--------------------------------------------------------------------------------

File: lm32_lab_soc/firmware/scope.c

--------------------------------------------------------------------------------
#include "hw.h"
#include "scope.h"

static uint16_t sc_samples = 256;

void scope_set(uint16_t samples, uint16_t decim) {
    sc_samples = samples;
    SC_SAMPLES = samples;
    SC_DECIM   = decim;
}

void scope_arm(void) {
    SC_CTRL = 1;
}

void scope_wait_done(void) {
    while (!(SC_STATUS & 0x1));
}

uint16_t scope_get_sample(uint32_t index) {
    uint32_t v = SC_DATA(index);
    return (uint16_t)(v & 0x0FFF);
}
--------------------------------------------------------------------------------

5.7 crt0.S
----------

Minimal startup:

File: lm32_lab_soc/firmware/crt0.S

--------------------------------------------------------------------------------
    .section .text
    .globl _start
_start:
    la   r1, _stack_top
    la   r2, main
    calli r2

1:
    br   1b
--------------------------------------------------------------------------------

5.8 linker.ld
-------------

File: lm32_lab_soc/firmware/linker.ld

--------------------------------------------------------------------------------
MEMORY {
  rom (rx)  : ORIGIN = 0x00000000, LENGTH = 16K
  ram (rwx) : ORIGIN = 0x10000000, LENGTH = 8K
}

SECTIONS {
  .text : {
    *(.text*)
    *(.rodata*)
  } > rom

  .data : {
    *(.data*)
  } > ram AT > rom

  .bss : {
    *(.bss*)
    *(COMMON)
  } > ram

  PROVIDE(_stack_top = ORIGIN(ram) + LENGTH(ram));
}
--------------------------------------------------------------------------------

5.9 main.c – command interpreter
--------------------------------

File: lm32_lab_soc/firmware/main.c

--------------------------------------------------------------------------------
#include <stdint.h>
#include <string.h>
#include "hw.h"
#include "uart.h"
#include "dsp.h"
#include "logic_analyzer.h"
#include "usb_analyzer.h"
#include "scope.h"

#define LINE_MAX 128
#define MAX_TOK  8

static char line_buf[LINE_MAX];

static int tokenize(char *s, char *tok[], int max_tok) {
    int n = 0;
    while (*s && n < max_tok) {
        while (*s == ' ' || *s == '\t') s++;
        if (!*s) break;
        tok[n++] = s;
        while (*s && *s != ' ' && *s != '\t' && *s != '\r' && *s != '\n')
            s++;
        if (*s) {
            *s = 0;
            s++;
        }
    }
    return n;
}

static uint32_t parse_u32(const char *s) {
    uint32_t v = 0;
    int base = 10;
    if (s[0]=='0' && (s[1]=='x' || s[1]=='X')) {
        base = 16;
        s += 2;
    }
    while (*s) {
        char c = *s++;
        int d;
        if (c >= '0' && c <= '9') d = c - '0';
        else if (c >= 'a' && c <= 'f') d = 10 + (c - 'a');
        else if (c >= 'A' && c <= 'F') d = 10 + (c - 'A');
        else break;
        v = v * base + d;
    }
    return v;
}

static int32_t parse_s16(const char *s) {
    int neg = 0;
    if (*s == '-') { neg = 1; s++; }
    uint32_t u = parse_u32(s);
    int32_t v = (int32_t)(u & 0xFFFF);
    if (neg) v = -v;
    return v;
}

/* DSP commands */
static void cmd_dsp_reset(int argc, char *argv[]) {
    dsp_reset();
    uart_puts("OK\r\n");
}

static void cmd_dsp_set_tap(int argc, char *argv[]) {
    if (argc < 3) { uart_puts("ERR ARGS\r\n"); return; }
    uint32_t idx = parse_u32(argv[1]);
    int16_t  val = (int16_t)parse_s16(argv[2]);
    dsp_set_coeff(idx, val);
    uart_puts("OK\r\n");
}

static void cmd_dsp_run(int argc, char *argv[]) {
    if (argc < 2) { uart_puts("ERR ARGS\r\n"); return; }
    int16_t s = (int16_t)parse_s16(argv[1]);
    int32_t y = dsp_run_sample(s);
    uart_puts("RES ");
    uart_puthex((uint32_t)y);
    uart_puts("\r\nOK\r\n");
}

/* DDS commands */
static void cmd_dds_set(int argc, char *argv[]) {
    if (argc < 3) { uart_puts("ERR ARGS\r\n"); return; }
    uint32_t phase_inc = parse_u32(argv[1]);
    uint32_t ampl      = parse_u32(argv[2]) & 0xFFF;
    DDS_PHASE_INC = phase_inc;
    DDS_AMPL      = ampl;
    uart_puts("OK\r\n");
}

static void cmd_dds_en(int argc, char *argv[]) {
    DDS_CTRL = 1;
    uart_puts("OK\r\n");
}

static void cmd_dds_dis(int argc, char *argv[]) {
    DDS_CTRL = 0;
    uart_puts("OK\r\n");
}

/* Logic analyzer */
static uint16_t la_samples_cached = 256;

static void cmd_la_set_trig(int argc, char *argv[]) {
    if (argc < 3) { uart_puts("ERR ARGS\r\n"); return; }
    uint16_t val  = (uint16_t)parse_u32(argv[1]);
    uint16_t mask = (uint16_t)parse_u32(argv[2]);
    la_set_trig(val, mask);
    uart_puts("OK\r\n");
}

static void cmd_la_set_samples(int argc, char *argv[]) {
    if (argc < 2) { uart_puts("ERR ARGS\r\n"); return; }
    la_samples_cached = (uint16_t)parse_u32(argv[1]);
    la_set_samples(la_samples_cached);
    uart_puts("OK\r\n");
}

static void cmd_la_arm(int argc, char *argv[]) {
    la_arm();
    uart_puts("OK\r\n");
}

static void cmd_la_wait_done(int argc, char *argv[]) {
    la_wait_done();
    uart_puts("OK\r\n");
}

static void cmd_la_dump(int argc, char *argv[]) {
    for (uint32_t i = 0; i < la_samples_cached; i++) {
        uint16_t v = la_get_sample(i);
        uart_puthex((uint32_t)v);
        uart_puts("\r\n");
    }
    uart_puts("OK\r\n");
}

/* USB analyzer */
static void cmd_usb_arm(int argc, char *argv[]) {
    usb_arm();
    uart_puts("OK\r\n");
}

static void cmd_usb_wait_done(int argc, char *argv[]) {
    usb_wait_done();
    uart_puts("OK\r\n");
}

static void cmd_usb_info(int argc, char *argv[]) {
    uint32_t status = usb_get_status();
    uint16_t count  = usb_get_count();
    uart_puts("COUNT ");
    uart_puthex(count);
    uart_puts(" STATUS ");
    uart_puthex(status);
    uart_puts("\r\nOK\r\n");
}

static void cmd_usb_dump(int argc, char *argv[]) {
    uint16_t count = usb_get_count();
    for (uint32_t i = 0; i < count; i++) {
        uint32_t e = usb_get_entry(i);
        uart_puthex(e);
        uart_puts("\r\n");
    }
    uart_puts("OK\r\n");
}

/* Scope */
static uint16_t sc_samples_cached = 256;

static void cmd_sc_set(int argc, char *argv[]) {
    if (argc < 3) { uart_puts("ERR ARGS\r\n"); return; }
    sc_samples_cached = (uint16_t)parse_u32(argv[1]);
    uint16_t decim    = (uint16_t)parse_u32(argv[2]);
    scope_set(sc_samples_cached, decim);
    uart_puts("OK\r\n");
}

static void cmd_sc_arm(int argc, char *argv[]) {
    scope_arm();
    uart_puts("OK\r\n");
}

static void cmd_sc_wait_done(int argc, char *argv[]) {
    scope_wait_done();
    uart_puts("OK\r\n");
}

static void cmd_sc_dump(int argc, char *argv[]) {
    for (uint32_t i = 0; i < sc_samples_cached; i++) {
        uint16_t v = scope_get_sample(i);
        uart_puthex((uint32_t)v);
        uart_puts("\r\n");
    }
    uart_puts("OK\r\n");
}

int main(void) {
    GPIO_OUT = 0x1;

    uart_puts("LM32 Instrument SoC ready.\r\n");

    while (1) {
        int len = uart_readline(line_buf, LINE_MAX);
        if (len <= 0) continue;

        char *tok[MAX_TOK];
        int ntok = tokenize(line_buf, tok, MAX_TOK);
        if (ntok == 0) continue;

        if (!strcmp(tok[0], "DSP_RESET"))           cmd_dsp_reset(ntok, tok);
        else if (!strcmp(tok[0], "DSP_SET_TAP"))    cmd_dsp_set_tap(ntok, tok);
        else if (!strcmp(tok[0], "DSP_RUN"))        cmd_dsp_run(ntok, tok);
        else if (!strcmp(tok[0], "DDS_SET"))        cmd_dds_set(ntok, tok);
        else if (!strcmp(tok[0], "DDS_EN"))         cmd_dds_en(ntok, tok);
        else if (!strcmp(tok[0], "DDS_DIS"))        cmd_dds_dis(ntok, tok);
        else if (!strcmp(tok[0], "LA_SET_TRIG"))    cmd_la_set_trig(ntok, tok);
        else if (!strcmp(tok[0], "LA_SET_SAMPLES")) cmd_la_set_samples(ntok, tok);
        else if (!strcmp(tok[0], "LA_ARM"))         cmd_la_arm(ntok, tok);
        else if (!strcmp(tok[0], "LA_WAIT_DONE"))   cmd_la_wait_done(ntok, tok);
        else if (!strcmp(tok[0], "LA_DUMP"))        cmd_la_dump(ntok, tok);
        else if (!strcmp(tok[0], "USB_ARM"))        cmd_usb_arm(ntok, tok);
        else if (!strcmp(tok[0], "USB_WAIT_DONE"))  cmd_usb_wait_done(ntok, tok);
        else if (!strcmp(tok[0], "USB_INFO"))       cmd_usb_info(ntok, tok);
        else if (!strcmp(tok[0], "USB_DUMP"))       cmd_usb_dump(ntok, tok);
        else if (!strcmp(tok[0], "SC_SET"))         cmd_sc_set(ntok, tok);
        else if (!strcmp(tok[0], "SC_ARM"))         cmd_sc_arm(ntok, tok);
        else if (!strcmp(tok[0], "SC_WAIT_DONE"))   cmd_sc_wait_done(ntok, tok);
        else if (!strcmp(tok[0], "SC_DUMP"))        cmd_sc_dump(ntok, tok);
        else {
            uart_puts("ERR UNKNOWN\r\n");
        }
    }
    return 0;
}
--------------------------------------------------------------------------------

5.10 Makefile
-------------

File: lm32_lab_soc/firmware/Makefile

--------------------------------------------------------------------------------
CC      = lm32-elf-gcc
OBJCOPY = lm32-elf-objcopy
CFLAGS  = -Os -ffreestanding -nostdlib -Wall -Wextra

OBJS = crt0.o main.o uart.o dsp.o logic_analyzer.o usb_analyzer.o scope.o

all: firmware.hex

crt0.o: crt0.S
	$(CC) $(CFLAGS) -c crt0.S -o crt0.o

main.o: main.c hw.h uart.h dsp.h logic_analyzer.h usb_analyzer.h scope.h
	$(CC) $(CFLAGS) -c main.c -o main.o

uart.o: uart.c hw.h uart.h
	$(CC) $(CFLAGS) -c uart.c -o uart.o

dsp.o: dsp.c hw.h dsp.h
	$(CC) $(CFLAGS) -c dsp.c -o dsp.o

logic_analyzer.o: logic_analyzer.c hw.h logic_analyzer.h
	$(CC) $(CFLAGS) -c logic_analyzer.c -o logic_analyzer.o

usb_analyzer.o: usb_analyzer.c hw.h usb_analyzer.h
	$(CC) $(CFLAGS) -c usb_analyzer.c -o usb_analyzer.o

scope.o: scope.c hw.h scope.h
	$(CC) $(CFLAGS) -c scope.c -o scope.o

firmware.elf: $(OBJS) linker.ld
	$(CC) $(CFLAGS) -Wl,-Tlinker.ld -o firmware.elf $(OBJS)

firmware.hex: firmware.elf
	$(OBJCOPY) -O verilog firmware.elf firmware.hex

clean:
	rm -f *.o firmware.elf firmware.hex
--------------------------------------------------------------------------------

Build firmware:

cd lm32_lab_soc/firmware
make

This creates firmware.hex in firmware/, which wb_rom uses.

-------------------------------------------------------------------------------
6. QUARTUS PROJECT AND VOLATILE PROGRAMMING
-------------------------------------------------------------------------------

6.1 Create Quartus project
--------------------------

- Open Quartus Prime Lite.
- New Project Wizard:
  - Directory: lm32_lab_soc/quartus
  - Name: lm32_lab_soc
- Device: choose correct Cyclone IV device from DueProLogic docs (e.g. EP4CE6F17C8).
- When asked for files, add later.

6.2 Add source files
--------------------

Add:

- top/soc_top.v
- rtl/wb/*.v
- rtl/lm32/rtl/*.v (LM32 RTL files; ensure lm32_cpu.v is included)

Set the top‑level entity to soc_top.

6.3 Pin assignments
-------------------

Using the DueProLogic manual, map:

- clk_50 : main 50 MHz crystal pin.
- reset_n : a pushbutton or slide switch pin.
- uart_tx / uart_rx : pins that go to headers where you connect USB‑UART.
- leds[7:0] : LED pins.
- buttons[7:0] : button pins.
- la_probes[15:0] : header pins for logic analyzer.
- usb_dp, usb_dm : header pins connected to D+/D− sniff line (with proper protection).
- scope_in[11:0] : input bus from ADC or digital source.
- dds_out[11:0] : output bus for DDS to DAC or R‑2R ladder.

In Assignments → Pin Planner:

- Assign each port to a physical pin.
- Set I/O standard to 3.3-V LVCMOS where appropriate.

6.4 Compile
-----------

In Quartus:

- Processing → Start Compilation.
- Fix any errors related to LM32 port names or missing files.
- Ensure total logic/BRAM fits the EP4CE6 resources; if not, reduce depths (DEPTH/TAPS).

6.5 Program (volatile only)
---------------------------

- Tools → Programmer.
- Hardware Setup: select USB‑Blaster.
- Add the .sof file from lm32_lab_soc/quartus/output_files/.
- For the FPGA device:
  - Check Program/Configure.
- Do NOT add any EPCS/EPCQ flash device.
- Do NOT program a .pof.
- Click Start.

The LM32 SoC runs while board is powered. When you power‑cycle, the FPGA reloads
its configuration from the original onboard flash, and the factory/demo image
returns. Your SoC is not persistent.

-------------------------------------------------------------------------------
7. HOST PYTHON SCRIPTS
-------------------------------------------------------------------------------

Install Python dependencies:

pip install pyserial numpy scipy matplotlib

7.1 common.py
-------------

File: lm32_lab_soc/host/common.py

--------------------------------------------------------------------------------
import serial

class FpgaLink:
    def __init__(self, port, baud=115200):
        self.ser = serial.Serial(port, baudrate=baud, timeout=1)

    def cmd(self, line, expect_ok=True):
        self.ser.write((line + "\n").encode("ascii"))
        lines = []
        while True:
            l = self.ser.readline()
            if not l:
                break
            l = l.decode("ascii", errors="ignore").strip()
            if l == "OK":
                break
            if l.startswith("ERR"):
                if expect_ok:
                    raise RuntimeError("FPGA error: " + l)
                else:
                    lines.append(l)
                    break
            lines.append(l)
        return lines
--------------------------------------------------------------------------------

7.2 dsp_host.py
----------------

File: lm32_lab_soc/host/dsp_host.py

--------------------------------------------------------------------------------
import numpy as np
from common import FpgaLink
from scipy.signal import firwin

def configure_fir(fpga, taps):
    fpga.cmd("DSP_RESET")
    for i, c in enumerate(taps):
        q = int(np.round(c * 32767.0))
        if q < -32768: q = -32768
        if q >  32767: q =  32767
        fpga.cmd(f"DSP_SET_TAP {i} {q}")

def run_fir(fpga, samples):
    outputs = []
    for s in samples:
        q = int(np.round(s * 32767.0))
        resp = fpga.cmd(f"DSP_RUN {q}")
        for line in resp:
            if line.startswith("RES "):
                val_hex = line.split()[1]
                y = int(val_hex, 16)
                if y & 0x80000000:
                    y -= 0x100000000
                outputs.append(y / (32767.0*32767.0))
    return np.array(outputs)

def main():
    fpga = FpgaLink("/dev/ttyUSB0")

    taps = firwin(16, 0.1)
    configure_fir(fpga, taps)

    x = np.zeros(64)
    x[0] = 1.0
    y = run_fir(fpga, x)

    print("Impulse response:")
    for v in y[:16]:
        print(v)

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------

7.3 dds_host.py
---------------

File: lm32_lab_soc/host/dds_host.py

--------------------------------------------------------------------------------
from common import FpgaLink

def set_tone(fpga, fs, freq, amplitude=0.8):
    phase_bits = 24
    phase_scale = 1 << phase_bits
    phase_inc = int(round(freq / fs * phase_scale)) & (phase_scale - 1)
    ampl_q = int(round(amplitude * 0x7FF))
    if ampl_q < 0: ampl_q = 0
    if ampl_q > 0xFFF: ampl_q = 0xFFF
    fpga.cmd(f"DDS_SET {phase_inc} {ampl_q}")
    fpga.cmd("DDS_EN")

def stop_tone(fpga):
    fpga.cmd("DDS_DIS")

def main():
    fpga = FpgaLink("/dev/ttyUSB0")
    fs = 50_000_000.0
    freq = 100_000.0
    set_tone(fpga, fs, freq, amplitude=0.8)
    input("DDS tone active. Press Enter to stop...")
    stop_tone(fpga)

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------

7.4 logic_analyzer_host.py
--------------------------

File: lm32_lab_soc/host/logic_analyzer_host.py

--------------------------------------------------------------------------------
import numpy as np
import matplotlib.pyplot as plt
from common import FpgaLink

def capture_logic(fpga, trig_val=0, trig_mask=0, samples=256):
    fpga.cmd(f"LA_SET_TRIG {trig_val} {trig_mask}")
    fpga.cmd(f"LA_SET_SAMPLES {samples}")
    fpga.cmd("LA_ARM")
    fpga.cmd("LA_WAIT_DONE")
    lines = fpga.cmd("LA_DUMP")
    values = [int(l, 16) & 0xFFFF for l in lines]
    return np.array(values, dtype=np.uint16)

def main():
    fpga = FpgaLink("/dev/ttyUSB0")
    data = capture_logic(fpga, trig_val=0, trig_mask=0, samples=256)
    t = np.arange(len(data))
    plt.step(t, data, where='post')
    plt.title("Logic Analyzer Capture")
    plt.xlabel("Sample")
    plt.ylabel("Bits")
    plt.show()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------

7.5 scope_host.py
-----------------

File: lm32_lab_soc/host/scope_host.py

--------------------------------------------------------------------------------
import numpy as np
import matplotlib.pyplot as plt
from common import FpgaLink

def capture_scope(fpga, samples=256, decim=10):
    fpga.cmd(f"SC_SET {samples} {decim}")
    fpga.cmd("SC_ARM")
    fpga.cmd("SC_WAIT_DONE")
    lines = fpga.cmd("SC_DUMP")
    vals = []
    for l in lines:
        v = int(l, 16) & 0xFFF
        vals.append(v)
    return np.array(vals)

def main():
    fpga = FpgaLink("/dev/ttyUSB0")
    data = capture_scope(fpga, samples=512, decim=20)
    plt.plot(data)
    plt.title("Scope Capture")
    plt.xlabel("Sample")
    plt.ylabel("Code")
    plt.show()

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------

7.6 usb_analyzer_host.py
------------------------

File: lm32_lab_soc/host/usb_analyzer_host.py

--------------------------------------------------------------------------------
from common import FpgaLink

PID_TYPES = {
    0b0001: "OUT",
    0b1001: "IN",
    0b0101: "SOF",
    0b1101: "SETUP",
    0b0011: "DATA0",
    0b1011: "DATA1",
    0b0111: "DATA2",
    0b1111: "MDATA",
    0b0010: "ACK",
    0b1010: "NAK",
    0b1110: "STALL",
    0b0110: "NYET",
}

def capture_usb_events(fpga):
    fpga.cmd("USB_ARM")
    fpga.cmd("USB_WAIT_DONE")
    info = fpga.cmd("USB_INFO")
    count = 0
    for line in info:
        if line.startswith("COUNT "):
            parts = line.split()
            count = int(parts[1], 16)
    if count == 0:
        return []
    lines = fpga.cmd("USB_DUMP")
    events = []
    for l in lines:
        v = int(l, 16)
        dp = (v >> 17) & 1
        dm = (v >> 16) & 1
        ts = v & 0xFFFF
        events.append((ts, dp, dm))
    return events

def decode_usb_states(events):
    states = []
    for ts, dp, dm in events:
        if dp == 1 and dm == 0:
            s = 'J'
        elif dp == 0 and dm == 1:
            s = 'K'
        elif dp == 0 and dm == 0:
            s = 'SE0'
        else:
            s = 'SE1'
        states.append((ts, s))
    return states

def nrzi_decode(bit_times, bit_period_est):
    if not bit_times:
        return []
    bits = []
    prev_level = bit_times[0][1]
    last_time = bit_times[0][0]
    for t, level in bit_times[1:]:
        dt = t - last_time
        n_bits = max(1, int(round(dt / bit_period_est)))
        transition = (level != prev_level)
        bit = 0 if transition else 1
        bits.extend([bit] * n_bits)
        prev_level = level
        last_time = t
    return bits

def remove_bit_stuffing(bits):
    out = []
    ones = 0
    i = 0
    while i < len(bits):
        b = bits[i]
        out.append(b)
        if b == 1:
            ones += 1
            if ones == 6:
                i += 1
                ones = 0
        else:
            ones = 0
        i += 1
    return out

def bits_to_bytes(bits):
    bytes_out = []
    for i in range(0, len(bits), 8):
        if i+7 >= len(bits):
            break
        b = 0
        for j in range(8):
            if bits[i+j]:
                b |= (1 << j)
        bytes_out.append(b)
    return bytes_out

def decode_pid(byte):
    pid = byte & 0xF
    npid = (byte >> 4) & 0xF
    if ((pid ^ npid) & 0xF) != 0xF:
        return "BADPID"
    return PID_TYPES.get(pid, "UNKNOWN")

def decode_usb(events, fs_clock=50_000_000.0, usb_bitrate=12_000_000.0):
    states = decode_usb_states(events)
    nrzi_seq = []
    for ts, st in states:
        if st == 'J':
            level = 1
        elif st == 'K':
            level = 0
        else:
            continue
        nrzi_seq.append((ts, level))
    if len(nrzi_seq) < 2:
        print("Not enough data for decode.")
        return
    dt_list = [nrzi_seq[i+1][0] - nrzi_seq[i][0] for i in range(min(10, len(nrzi_seq)-1))]
    if not dt_list:
        print("No timing intervals.")
        return
    bit_period_est = sum(dt_list) / len(dt_list)
    bits = nrzi_decode(nrzi_seq, bit_period_est)
    bits = remove_bit_stuffing(bits)
    bytes_out = bits_to_bytes(bits)

    print("Raw bytes:", " ".join(f"{b:02X}" for b in bytes_out))
    if not bytes_out:
        return
    pid_name = decode_pid(bytes_out[0])
    print("PID:", pid_name)
    if pid_name in ("OUT", "IN", "SETUP"):
        if len(bytes_out) >= 3:
            addr = bytes_out[1] & 0x7F
            endp = (bytes_out[1] >> 7) | ((bytes_out[2] & 0x07) << 1)
            print(f"TOKEN addr={addr} ep={endp}")
    elif pid_name.startswith("DATA"):
        print(f"DATA length={len(bytes_out)-1} bytes")
    elif pid_name in ("ACK", "NAK", "STALL"):
        print(f"Handshake: {pid_name}")

def main():
    fpga = FpgaLink("/dev/ttyUSB0")
    events = capture_usb_events(fpga)
    print(f"Captured {len(events)} events")
    decode_usb(events)

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------

-------------------------------------------------------------------------------
8. RUNNING THE WHOLE SYSTEM
-------------------------------------------------------------------------------

1) Build firmware:

   cd lm32_lab_soc/firmware
   make

   Ensure firmware.hex exists.

2) Ensure firmware.hex is visible to Quartus (either copy it into quartus build
   directory or adjust wb_rom.v path accordingly).

3) Open Quartus project (lm32_lab_soc.qpf in lm32_lab_soc/quartus):

   - Add all RTL files and LM32 core files.
   - Set top-level entity to soc_top.
   - Assign correct pins from DueProLogic docs.

4) Compile:

   Processing → Start Compilation.

5) Program FPGA (volatile only):

   Tools → Programmer
   - Add lm32_lab_soc.sof
   - Select Cyclone IV device, check Program/Configure
   - DO NOT program any flash device (.pof).
   - Click Start.

   After programming, the FPGA runs the LM32 SoC. On power off/on, it reloads
   its original factory/demo configuration from flash, so your SoC vanishes.

6) Connect USB‑UART adapter:

   - TX from FPGA (uart_tx pin) → RX on USB‑UART.
   - RX from FPGA (uart_rx pin) → TX on USB‑UART.
   - Common GND.

7) On your PC, run a simple terminal to verify:

   - Connect at 115200 8N1.
   - You should see: "LM32 Instrument SoC ready."

8) Run Python scripts:

   - DSP example:
       cd lm32_lab_soc/host
       python dsp_host.py
   - DDS:
       python dds_host.py
   - Logic analyzer:
       python logic_analyzer_host.py
   - Scope:
       python scope_host.py
   - USB analyzer:
       python usb_analyzer_host.py

These scripts define DSP behavior, DDS parameters, and decode USB protocol on
the host. The FPGA board remains a volatile, reusable instrument; power cycling
returns it to its previous programmed image in flash.