#include <Arduino.h>

class DriverIface{public:virtual void init()=0;virtual void enable(bool en)=0;virtual void setDir(bool cw)=0;virtual void stepOnce(bool cw)=0;};
class TB6600Driver:public DriverIface{int ps,pd,pe;bool al;public:TB6600Driver(int s,int d,int e,bool a=true):ps(s),pd(d),pe(e),al(a){}void init(){pinMode(ps,OUTPUT);pinMode(pd,OUTPUT);pinMode(pe,OUTPUT);digitalWrite(pe,al?HIGH:LOW);digitalWrite(ps,HIGH);digitalWrite(pd,HIGH);}void enable(bool en){digitalWrite(pe,al?(!en?HIGH:LOW):(en?HIGH:LOW));}void setDir(bool cw){digitalWrite(pd,al?(cw?LOW:HIGH):(cw?HIGH:LOW));}void stepOnce(bool cw){if(al){digitalWrite(ps,LOW);digitalWrite(ps,HIGH);}else{digitalWrite(ps,HIGH);digitalWrite(ps,LOW);}}};
class ULN2003Driver:public DriverIface{int a,b,c,d;int idx=0;const int seq[8][4]={{1,0,0,0},{1,1,0,0},{0,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,1,1},{0,0,0,1},{1,0,0,1}};void apply(){digitalWrite(a,seq[idx][0]);digitalWrite(b,seq[idx][1]);digitalWrite(c,seq[idx][2]);digitalWrite(d,seq[idx][3]);}public:ULN2003Driver(int ia,int ib,int ic,int id):a(ia),b(ib),c(ic),d(id){}void init(){pinMode(a,OUTPUT);pinMode(b,OUTPUT);pinMode(c,OUTPUT);pinMode(d,OUTPUT);digitalWrite(a,LOW);digitalWrite(b,LOW);digitalWrite(c,LOW);digitalWrite(d,LOW);}void enable(bool en){if(!en){digitalWrite(a,LOW);digitalWrite(b,LOW);digitalWrite(c,LOW);digitalWrite(d,LOW);}}void setDir(bool cw){}void stepOnce(bool cw){idx=cw?((idx+1)%8):((idx+7)%8);apply();}};
struct Axis{String label;DriverIface* drv=nullptr;String drvType;bool inv=false;float spu=80.0f;float maxF=3000.0f;bool en=false;float pos=0.0f;int minEnd=-1;int maxEnd=-1;};
#define MAX_AXES 8
Axis axes[MAX_AXES];int axisCount=0;

enum Mode{MODE_TEST=0,MODE_3DP=1,MODE_CNC=2};
Mode modeSel=MODE_TEST;
float defF=1200.0f;bool absMode=true;

struct Heater{int pin=-1;int pwmCh=-1;int adcPin=-1;float target=0;float current=0;float kp=10.0f;float ki=0.02f;float kd=40.0f;float integ=0;float prevErr=0;float maxT=300.0f;float scale=300.0f;float offset=0.0f;} hotend,bed;
int fanPin=-1;int fanPwm=0;

#define QLEN 24
struct Move{bool valid=false;int32_t steps[MAX_AXES];bool dirCW[MAX_AXES];int32_t err[MAX_AXES];int32_t maxSteps=0;uint32_t periodUs=1000;};
volatile Move q[QLEN];volatile int qH=0;volatile int qT=0;
hw_timer_t* tmr=nullptr;portMUX_TYPE mux=portMUX_INITIALIZER_UNLOCKED;

void IRAM_ATTR isr(){portENTER_CRITICAL_ISR(&mux);if(qH==qT){portEXIT_CRITICAL_ISR(&mux);return;}Move& m=const_cast<Move&>(q[qH]);if(!m.valid){qH=(qH+1)%QLEN;portEXIT_CRITICAL_ISR(&mux);return;}for(int i=0;i<axisCount;i++){int32_t s=abs(m.steps[i]);if(s==0)continue;m.err[i]+=s;if(m.err[i]>=m.maxSteps){m.err[i]-=m.maxSteps;Axis& A=axes[i];if(A.en&&A.drv){if(A.minEnd>=0&&digitalRead(A.minEnd)==LOW&&(!m.dirCW[i])){m.steps[i]=0;continue;}if(A.maxEnd>=0&&digitalRead(A.maxEnd)==LOW&&(m.dirCW[i])){m.steps[i]=0;continue;}A.drv->stepOnce(m.dirCW[i]);A.pos+=(m.dirCW[i]?(1.0f/A.spu):(-1.0f/A.spu));}m.steps[i]+=(m.dirCW[i]?-1:+1);}}bool done=true;for(int i=0;i<axisCount;i++)if(m.steps[i]!=0){done=false;break;}if(done){m.valid=false;qH=(qH+1)%QLEN;}timerAlarmWrite(tmr,m.periodUs,true);portEXIT_CRITICAL_ISR(&mux);}

bool enq(const Move& m){portENTER_CRITICAL(&mux);int nt=(qT+1)%QLEN;if(nt==qH){portEXIT_CRITICAL(&mux);return false;}q[qT]=m;q[qT].valid=true;qT=nt;portEXIT_CRITICAL(&mux);return true;}
void setPeriod(uint32_t us){if(!tmr)return;timerAlarmDisable(tmr);timerAlarmWrite(tmr,us,true);timerAlarmEnable(tmr);}

Axis* findAxL(char L){for(int i=0;i<axisCount;i++){if(axes[i].label.length()==1&&axes[i].label[0]==L)return &axes[i];}return nullptr;}
Axis* findAxN(const String& n){for(int i=0;i<axisCount;i++)if(axes[i].label.equalsIgnoreCase(n))return &axes[i];return nullptr;}
bool addTB6600(const String& label,int s,int d,int e,bool inv,bool al){if(axisCount>=MAX_AXES)return false;auto* drv=new TB6600Driver(s,d,e,al);drv->init();Axis& A=axes[axisCount++];A.label=label;A.drv=drv;A.drvType="TB6600";A.inv=inv;A.spu=80.0f;A.maxF=3000.0f;A.en=false;A.pos=0.0f;A.minEnd=-1;A.maxEnd=-1;return true;}
bool addULN2003(const String& label,int a,int b,int c,int d,bool inv){if(axisCount>=MAX_AXES)return false;auto* drv=new ULN2003Driver(a,b,c,d);drv->init();Axis& A=axes[axisCount++];A.label=label;A.drv=drv;A.drvType="ULN2003";A.inv=inv;A.spu=2048.0f;A.maxF=600.0f;A.en=false;A.pos=0.0f;A.minEnd=-1;A.maxEnd=-1;return true;}
void clearAxes(){axisCount=0;}

void ok(){Serial.println("ok");}
void err(const char* m){Serial.print("error:");Serial.println(m);}

float fAfter(const String& s,char k,bool* f){int i=s.indexOf(k);if(i<0){if(f)*f=false;return 0.0f;}int j=i+1;String n;while(j<s.length()&&(isDigit(s[j])||s[j]=='.'||s[j]=='-'))n+=s[j++];if(f)*f=true;return n.toFloat();}
long lAfter(const String& s,char k,bool* f){int i=s.indexOf(k);if(i<0){if(f)*f=false;return 0;}int j=i+1;String n;while(j<s.length()&&(isDigit(s[j])||s[j]=='-'))n+=s[j++];if(f)*f=true;return n.toInt();}
bool word(const String& s,const String& key,String& out){int i=s.indexOf(key);if(i<0)return false;i+=key.length();while(i<s.length()&&s[i]==' ')i++;int j=i;while(j<s.length()&&s[j]!=' '&&s[j]!=','&&s[j]!=';'&&s[j]!='+'&&s[j]!='=')j++;out=s.substring(i,j);return true;}
bool wordEq(const String& s,const String& key,String& out){int i=s.indexOf(key);if(i<0)return false;i+=key.length();if(i<s.length()&&s[i]=='=')i++;while(i<s.length()&&s[i]==' ')i++;int j=i;while(j<s.length()&&s[j]!=' '&&s[j]!=','&&s[j]!=';'&&s[j]!='+')j++;out=s.substring(i,j);return true;}

uint32_t feedToUs(float F,float spu){float sps=(F/60.0f)*spu;if(sps<1.0f)sps=1.0f;uint32_t us=(uint32_t)(1000000.0f/sps);if(us<100)us=100;return us;}

void heaterUpdate(Heater& h){if(h.pin<0)return;if(h.adcPin>=0){int r=analogRead(h.adcPin);float v=(float)r/4095.0f;h.current=v*h.scale+h.offset;if(h.current<0)h.current=0;if(h.current>h.maxT)h.current=h.maxT;}float e=h.target-h.current;h.integ+=e;if(h.integ<-1000)h.integ=-1000;if(h.integ>1000)h.integ=1000;float d=e-h.prevErr;h.prevErr=e;float out=h.kp*e+h.ki*h.integ+h.kd*d;if(out<0)out=0;if(out>255)out=255;if(h.pwmCh>=0){ledcWrite(h.pwmCh,(int)out);}else{digitalWrite(h.pin,out>0?HIGH:LOW);}}

void queueMoveWords(const String& ln,float F){Move m;m.maxSteps=0;float primary=1.0f;for(int i=0;i<axisCount;i++){Axis& A=axes[i];float Feff=min(F,A.maxF);if(Feff<F)F=Feff;bool found=false;float val=0.0f;if(A.label.length()==1){val=fAfter(ln,A.label[0],&found);}else{String out;if(wordEq(ln,A.label,out)){val=out.toFloat();found=true;}}if(!found){m.steps[i]=0;m.dirCW[i]=true;m.err[i]=0;continue;}float tgt=absMode?val:(A.pos+val);float dlt=tgt-A.pos;int32_t st=(int32_t)round(dlt*A.spu);bool cw=st>=0;st=abs(st);if(st>m.maxSteps){m.maxSteps=st;primary=A.spu;}m.steps[i]=cw?st:-st;m.dirCW[i]=cw^A.inv;m.err[i]=0;A.drv->setDir(m.dirCW[i]);}if(m.maxSteps==0){ok();return;}m.periodUs=feedToUs(F,primary);if(!enq(m)){err("queue");return;}ok();}

void reportPos(){String s;for(int i=0;i<axisCount;i++){s+=axes[i].label+":"+String(axes[i].pos,3);if(i<axisCount-1)s+=" ";}Serial.println(s);ok();}

void execG(const String& ln){bool f;int g=(int)lAfter(ln,'G',&f);if(!f){err("G");return;}if(g==0||g==1){float F=defF;{bool ff;float v=fAfter(ln,'F',&ff);if(ff)F=v;}queueMoveWords(ln,F);}else if(g==4){bool p;long ms=lAfter(ln,'P',&p);if(!p){err("G4");return;}delay(ms);ok();}else if(g==28){for(int i=0;i<axisCount;i++){Axis& A=axes[i];A.pos=0.0f;}ok();}else if(g==90){absMode=true;ok();}else if(g==91){absMode=false;ok();}else{err("G?");}}

void execM(const String& ln){bool f;int m=(int)lAfter(ln,'M',&f);if(!f){err("M");return;}if(m==17){bool any=false;for(int i=0;i<axisCount;i++){char ax=axes[i].label.length()==1?axes[i].label[0]:0;if(ax&&ln.indexOf(ax)>=0){axes[i].en=true;axes[i].drv->enable(true);any=true;}}if(!any)for(int i=0;i<axisCount;i++){axes[i].en=true;axes[i].drv->enable(true);}ok();}else if(m==18){bool any=false;for(int i=0;i<axisCount;i++){char ax=axes[i].label.length()==1?axes[i].label[0]:0;if(ax&&ln.indexOf(ax)>=0){axes[i].en=false;axes[i].drv->enable(false);any=true;}}if(!any)for(int i=0;i<axisCount;i++){axes[i].en=false;axes[i].drv->enable(false);}ok();}else if(m==92){for(int i=0;i<axisCount;i++){if(axes[i].label.length()==1){char ax=axes[i].label[0];bool af;float v=fAfter(ln,ax,&af);if(af)axes[i].spu=v;}else{String out;if(wordEq(ln,axes[i].label,out))axes[i].spu=out.toFloat();}}ok();}else if(m==203){for(int i=0;i<axisCount;i++){if(axes[i].label.length()==1){char ax=axes[i].label[0];bool af;float v=fAfter(ln,ax,&af);if(af)axes[i].maxF=v;}else{String out;if(wordEq(ln,axes[i].label,out))axes[i].maxF=out.toFloat();}}ok();}else if(m==114){reportPos();}else if(m==115){Serial.println("FIRMWARE_NAME:ESP32StatelessMC MODES:TEST,3DP,CNC");ok();}else if(m==104){bool sF;float t=fAfter(ln,'S',&sF);hotend.target=sF?t:hotend.target;ok();}else if(m==109){bool sF;float t=fAfter(ln,'S',&sF);hotend.target=sF?t:hotend.target;unsigned long st=millis();while(fabs(hotend.current-hotend.target)>1.5&&millis()-st<600000){heaterUpdate(hotend);}ok();}else if(m==140){bool sF;float t=fAfter(ln,'S',&sF);bed.target=sF?t:bed.target;ok();}else if(m==190){bool sF;float t=fAfter(ln,'S',&sF);bed.target=sF?t:bed.target;unsigned long st=millis();while(fabs(bed.current-bed.target)>1.5&&millis()-st<600000){heaterUpdate(bed);}ok();}else if(m==105){Serial.print("T:");Serial.print(hotend.current,1);Serial.print(" B:");Serial.println(bed.current,1);ok();}else if(m==106){bool sF;float v=fAfter(ln,'S',&sF);fanPwm=sF?(int)v:255;if(fanPin>=0){if(fanPwm<=0)digitalWrite(fanPin,LOW);else digitalWrite(fanPin,HIGH);}ok();}else if(m==107){if(fanPin>=0)digitalWrite(fanPin,LOW);ok();}else if(m==740){String label;String out;if(word(ln,"M740 ",out))label=out;bool sf,df,ef,ifd,lfd;int ps=(int)lAfter(ln,'S',&sf);int pd=(int)lAfter(ln,'D',&df);int pe=(int)lAfter(ln,'E',&ef);int inv=(int)lAfter(ln,'I',&ifd);int act=(int)lAfter(ln,'L',&lfd);if(!(sf&&df&&ef)){err("M740");return;}if(!addTB6600(label,ps,pd,pe,(ifd?inv!=0:false),(lfd?act!=0:true))){err("AX");return;}ok();}else if(m==741){String label;String out;if(word(ln,"M741 ",out))label=out;bool af,bf,cf,df,ifd;int in1=(int)lAfter(ln,'A',&af);int in2=(int)lAfter(ln,'B',&bf);int in3=(int)lAfter(ln,'C',&cf);int in4=(int)lAfter(ln,'D',&df);int inv=(int)lAfter(ln,'I',&ifd);if(!(af&&bf&&cf&&df)){err("M741");return;}if(!addULN2003(label,in1,in2,in3,in4,(ifd?inv!=0:false))){err("AX");return;}ok();}else if(m==742){clearAxes();ok();}else if(m==760){String mstr;String out;if(wordEq(ln,"MODE",out))mstr=out;mstr.toUpperCase();if(mstr=="TEST")modeSel=MODE_TEST;else if(mstr=="3DP")modeSel=MODE_3DP;else if(mstr=="CNC")modeSel=MODE_CNC;ok();}else if(m==761){String out;if(wordEq(ln,"HOTEND_PIN",out)){hotend.pin=out.toInt();pinMode(hotend.pin,OUTPUT);hotend.pwmCh=0;ledcAttachPin(hotend.pin,hotend.pwmCh);ledcSetup(hotend.pwmCh,1000,8);}if(wordEq(ln,"HOTEND_ADC",out)){hotend.adcPin=out.toInt();}if(wordEq(ln,"HOTEND_SCALE",out)){hotend.scale=out.toFloat();}if(wordEq(ln,"HOTEND_OFFSET",out)){hotend.offset=out.toFloat();}if(wordEq(ln,"BED_PIN",out)){bed.pin=out.toInt();pinMode(bed.pin,OUTPUT);bed.pwmCh=1;ledcAttachPin(bed.pin,bed.pwmCh);ledcSetup(bed.pwmCh,1000,8);}if(wordEq(ln,"BED_ADC",out)){bed.adcPin=out.toInt();}if(wordEq(ln,"BED_SCALE",out)){bed.scale=out.toFloat();}if(wordEq(ln,"BED_OFFSET",out)){bed.offset=out.toFloat();}if(wordEq(ln,"FAN_PIN",out)){fanPin=out.toInt();pinMode(fanPin,OUTPUT);}ok();}else if(m==762){String out;String lbl;if(word(ln,"M762 ",out))lbl=out;Axis* A=findAxN(lbl);if(!A)A=(lbl.length()==1?findAxL(lbl[0]):nullptr);if(!A){err("AX");return;}String v;if(wordEq(ln,"MIN",v)){A->minEnd=v.toInt();pinMode(A->minEnd,INPUT_PULLUP);}if(wordEq(ln,"MAX",v)){A->maxEnd=v.toInt();pinMode(A->maxEnd,INPUT_PULLUP);}ok();}else{err("M?");}}

void execTest(const String& ln){String s=ln;String parts[64];int pc=0;int i=0;while(i<s.length()){while(i<s.length()&&(s[i]==' '||s[i]=='\t'))i++;int j=i;while(j<s.length()&&s[j]!='+'&&s[j]!=' '&&s[j]!='\t')j++;if(j>i){parts[pc++]=s.substring(i,j);}if(pc>=64)break;i=(j<s.length()&&s[j]=='+')?j+1:j+1;}if(pc<1){err("TEST");return;}long nMot=parts[0].toInt();int cur=1;bool any=false;while(cur<pc){String label=parts[cur++];if(cur>=pc){err("STEPS");return;}long steps=parts[cur++].toInt();if(cur>=pc){err("DIR");return;}String dir=parts[cur++];bool cw=dir.equalsIgnoreCase("cw")||dir.equalsIgnoreCase("clockwise");if(dir.equalsIgnoreCase("cc")||dir.equalsIgnoreCase("counter")||dir.equalsIgnoreCase("counterclockwise"))cw=false;String act=(cur<pc)?parts[cur]:"";bool hasAct=false;if(act.equalsIgnoreCase("start")||act.equalsIgnoreCase("stop")||act.equalsIgnoreCase("hlt")||act.equalsIgnoreCase("sel")){hasAct=true;cur++;}if(hasAct&&act.equalsIgnoreCase("sel")){if(cur>=pc){err("SEL");return;}String list=parts[cur++];int p=0;while(p<list.length()){while(p<list.length()&&(list[p]==','||list[p]==' '))p++;int q=p;while(q<list.length()&&list[q]!=','&&list[q]!=' ')q++;String lab=list.substring(p,q);Axis* A=findAxN(lab);if(!A)A=(lab.length()==1?findAxL(lab[0]):nullptr);if(A){A->en=true;A->drv->enable(true);}p=q+1;}any=true;continue;}if(hasAct&&(act.equalsIgnoreCase("stop")||act.equalsIgnoreCase("hlt"))){qH=qT;ok();continue;}Axis* A=findAxN(label);if(!A)A=(label.length()==1?findAxL(label[0]):nullptr);if(!A){String pS,pD,pE,pA,pB,pC,pD4;bool hS=wordEq(ln,"S",pS);bool hD=wordEq(ln,"D",pD);bool hE=wordEq(ln,"E",pE);if(hS&&hD&&hE){addTB6600(label,pS.toInt(),pD.toInt(),pE.toInt(),false,true);}else{bool hA=wordEq(ln,"A",pA);bool hB=wordEq(ln,"B",pB);bool hC=wordEq(ln,"C",pC);bool hD2=wordEq(ln,"D",pD4);if(hA&&hB&&hC&&hD2){addULN2003(label,pA.toInt(),pB.toInt(),pC.toInt(),pD4.toInt(),false);}else{err("PINS");return;}}A=findAxN(label);}A->en=true;A->drv->enable(true);Move m;m.maxSteps=abs(steps);for(int n=0;n<axisCount;n++){m.steps[n]=0;m.dirCW[n]=true;m.err[n]=0;}bool d=(steps>=0)^A->inv;m.steps[(int)(A-axes)]=(steps>=0)?abs(steps):-abs(steps);m.dirCW[(int)(A-axes)]=d;A->drv->setDir(d);m.periodUs=1000;if(!enq(m)){err("QUEUE");return;}any=true;if(nMot>0)nMot--;if(nMot==0)break;}if(any)ok();else err("NONE");}

void execLine(const String& lnIn){String ln=lnIn;ln.trim();if(!ln.length())return;char c=ln[0];if(c=='G'){execG(ln);}else if(c=='M'){execM(ln);}else{if(modeSel==MODE_TEST)execTest(ln);else execTest(ln);}}

void readSerial(){static String buf;while(Serial.available()){char ch=(char)Serial.read();if(ch=='\r')continue;if(ch=='\n'){buf.trim();if(buf.length())execLine(buf);buf="";}else{buf+=ch;}}}

void setupTimer(uint32_t us){if(tmr)timerEnd(tmr);tmr=timerBegin(0,80,true);timerAttachInterrupt(tmr,&isr,true);timerAlarmWrite(tmr,us,true);timerAlarmEnable(tmr);}

void setup(){Serial.begin(115200);delay(200);Serial.println("start");Serial.println("echo:ESP32StatelessMC-TEST/3DP/CNC");setupTimer(1000);}

void loop(){readSerial();heaterUpdate(hotend);heaterUpdate(bed);static uint32_t last=1000;portENTER_CRITICAL(&mux);if(qH!=qT&&q[qH].valid){uint32_t p=q[qH].periodUs;portEXIT_CRITICAL(&mux);if(p!=last&&p>=100){setPeriod(p);last=p;}}else{portEXIT_CRITICAL(&mux);}}