======================================================================
END‑TO‑END: VexRiscv + GEMM‑CAPABLE NPU SoC ON CYCLONE IV DUEPROLOGIC
         + RASPBERRY PI 5 + HUGGING FACE OFFLOAD (VOLATILE ONLY)
======================================================================

This is a full, non‑minimal, reproducible flow:

- FPGA: Altera Cyclone IV FPGA Development Board – DueProLogic
  - Uses the **built‑in USB‑Blaster** for JTAG programming
- Soft processor: **VexRiscv** (RV32IM) with Wishbone bus
- SoC peripherals:
  - 64 KB on‑chip RAM (for code + data), preloaded from firmware.hex
  - UART (Wishbone‑mapped) for host communication
  - GEMM‑capable NPU (int16 inputs, int32 accumulation):
    - Computes C[M×N] = A[M×K] · B[K×N] for small tiles
- Firmware: bare‑metal C, compiled for RV32IM
- Host: Raspberry Pi 5 (16 GB) using Python over UART
- Model: Hugging Face Stable Diffusion text‑to‑image
  - Uses NPU to compute a real GEMM on text embeddings
- Configuration: **volatile only**
  - Program SRAM via .sof
  - After power‑cycle, FPGA reverts to original flash image


==================================================
1. PREPARE: TOOLING, BOARD, AND HOST
==================================================

HARDWARE:

- **Altera Cyclone IV FPGA Development Board – DueProLogic**
  - Has built‑in USB‑Blaster (JTAG) over USB
- **Raspberry Pi 5 (16 GB RAM)**
- **USB‑A ↔ USB‑B (or relevant) cable**:
  - Connects DueProLogic’s USB‑Blaster port to Raspberry Pi 5
- **USB‑UART dongle (3.3 V logic)**:
  - To talk to the SoC’s UART
- Dupont wires to connect USB‑UART to DueProLogic header pins

SOFTWARE:

On dev machine (x86_64 Linux recommended; Pi 5 is possible but slower):

- **Java + SBT** (for SpinalHDL / VexRiscv)
- **Quartus Lite** with Cyclone IV support
- **RISC‑V toolchain** (`riscv32-unknown-elf-gcc`, `objcopy`)

On Raspberry Pi 5:

- `openFPGALoader` for JTAG programming via built‑in USB‑Blaster
- Python packages:
  - `pyserial`
  - `torch`
  - `diffusers`
  - `transformers`
  - `accelerate`
  - `safetensors`
  - `Pillow` (for saving images)


==================================================
2. GENERATE VEXRISCV CORE (WISHBONE)
==================================================

STEP 2.1 – Clone VexRiscv:

  git clone https://github.com/SpinalHDL/VexRiscv.git
  cd VexRiscv

STEP 2.2 – Create generator: `src/main/scala/GenVexRiscv.scala`

  import spinal.core._
  import vexriscv._
  import vexriscv.plugin._

  object GenVexRiscvWishbone {
    def main(args: Array[String]) {
      SpinalVerilog(
        new VexRiscv(
          VexRiscvConfig(
            plugins = List(
              new IBusSimplePlugin(
                resetVector = 0x00000000l,
                cmdForkOnSecondStage = false,
                prediction = STATIC,
                compressedGen = false
              ),
              new DBusSimplePlugin(),
              new DecoderSimplePlugin(),
              new RegFilePlugin(RegFileConfig(
                regFileReadyKind = SYNC,
                zeroBoot = true
              )),
              new IntAluPlugin(),
              new MulPlugin,
              new DivPlugin,
              new CsrPlugin(CsrPluginConfig.smallest),
              new WishboneSlavePlugin(
                addressWidth = 32,
                dataWidth    = 32
              )
            )
          )
        )
      )
    }
  }

STEP 2.3 – Generate Verilog:

  sbt "runMain GenVexRiscvWishbone"

This will generate `VexRiscv.v` in the output directory. Copy `VexRiscv.v`
into your SoC HDL project directory.


==================================================
3. SOC RTL: VEXRISCV + RAM + UART + GEMM NPU
==================================================

All of the following Verilog files go into a single project directory along
with `VexRiscv.v` and (later) `firmware.hex`.

We’ll implement:

- `simple_ram_wb.v` – 64 KB RAM with Wishbone interface
- `uart_rx.v`, `uart_tx.v` – UART primitives
- `uart_wb.v` – Wishbone‑mapped UART
- `npu_gemm_wb.v` – GEMM NPU
- `wb_interconnect.v` – Wishbone interconnect
- `soc_top.v` – top‑level module

--------------------------------------------------
3.1 simple_ram_wb.v (main RAM)
--------------------------------------------------

  // simple_ram_wb.v
  // 64 KB single-port RAM, Wishbone slave, preload from firmware.hex
  module simple_ram_wb #(
      parameter MEM_SIZE = 64*1024
  )(
      input  wire        clk,
      input  wire        rst,
      input  wire        wb_cyc,
      input  wire        wb_stb,
      input  wire        wb_we,
      input  wire [3:0]  wb_sel,
      input  wire [31:0] wb_adr,
      input  wire [31:0] wb_dat_w,
      output reg  [31:0] wb_dat_r,
      output reg         wb_ack
  );
      localparam WORDS = MEM_SIZE / 4;
      reg [31:0] mem [0:WORDS-1];

      initial begin
          $readmemh("firmware.hex", mem);
      end

      wire [31:0] word_addr = wb_adr[31:2];

      always @(posedge clk or posedge rst) begin
          if (rst) begin
              wb_ack   <= 1'b0;
              wb_dat_r <= 32'd0;
          end else begin
              wb_ack <= 1'b0;
              if (wb_cyc && wb_stb && !wb_ack) begin
                  wb_dat_r <= mem[word_addr];
                  wb_ack   <= 1'b1;
                  if (wb_we) begin
                      if (wb_sel[0]) mem[word_addr][7:0]   <= wb_dat_w[7:0];
                      if (wb_sel[1]) mem[word_addr][15:8]  <= wb_dat_w[15:8];
                      if (wb_sel[2]) mem[word_addr][23:16] <= wb_dat_w[23:16];
                      if (wb_sel[3]) mem[word_addr][31:24] <= wb_dat_w[31:24];
                  end
              end
          end
      end
  endmodule


--------------------------------------------------
3.2 uart_rx.v
--------------------------------------------------

  // uart_rx.v
  // Simple 8N1 UART receiver
  module uart_rx #(
      parameter CLK_FREQ = 50000000,
      parameter BAUD     = 115200
  )(
      input  wire clk,
      input  wire rst,
      input  wire rx,
      output reg  [7:0] data,
      output reg        valid
  );
      localparam integer DIVISOR      = CLK_FREQ / BAUD;
      localparam integer HALF_DIVISOR = DIVISOR / 2;

      reg [15:0] cnt;
      reg [3:0]  bit_idx;
      reg        busy;
      reg        rx_d1, rx_d2;

      always @(posedge clk) begin
          rx_d1 <= rx;
          rx_d2 <= rx_d1;
      end

      always @(posedge clk or posedge rst) begin
          if (rst) begin
              cnt     <= 0;
              bit_idx <= 0;
              busy    <= 0;
              valid   <= 0;
              data    <= 8'd0;
          end else begin
              valid <= 0;
              if (!busy) begin
                  if (rx_d2 == 1'b0) begin
                      busy    <= 1'b1;
                      cnt     <= HALF_DIVISOR;
                      bit_idx <= 0;
                  end
              end else begin
                  if (cnt == 0) begin
                      cnt <= DIVISOR - 1;
                      if (bit_idx == 0) begin
                          bit_idx <= bit_idx + 1;
                      end else if (bit_idx >= 1 && bit_idx <= 8) begin
                          data    <= {rx_d2, data[7:1]};
                          bit_idx <= bit_idx + 1;
                      end else if (bit_idx == 9) begin
                          busy  <= 1'b0;
                          valid <= 1'b1;
                      end
                  end else begin
                      cnt <= cnt - 1;
                  end
              end
          end
      end
  endmodule


--------------------------------------------------
3.3 uart_tx.v
--------------------------------------------------

  // uart_tx.v
  // Simple 8N1 UART transmitter
  module uart_tx #(
      parameter CLK_FREQ = 50000000,
      parameter BAUD     = 115200
  )(
      input  wire clk,
      input  wire rst,
      input  wire [7:0] data,
      input  wire       start,
      output reg        tx,
      output reg        busy
  );
      localparam integer DIVISOR = CLK_FREQ / BAUD;

      reg [15:0] cnt;
      reg [3:0]  bit_idx;
      reg [9:0]  shreg;

      always @(posedge clk or posedge rst) begin
          if (rst) begin
              tx      <= 1'b1;
              busy    <= 1'b0;
              cnt     <= 0;
              bit_idx <= 0;
              shreg   <= 10'h3FF;
          end else begin
              if (!busy) begin
                  if (start) begin
                      shreg   <= {1'b1, data, 1'b0};
                      busy    <= 1'b1;
                      bit_idx <= 0;
                      cnt     <= DIVISOR - 1;
                  end
              end else begin
                  if (cnt == 0) begin
                      tx    <= shreg[0];
                      shreg <= {1'b1, shreg[9:1]};
                      bit_idx <= bit_idx + 1;
                      cnt     <= DIVISOR - 1;
                      if (bit_idx == 9) begin
                          busy <= 1'b0;
                      end
                  end else begin
                      cnt <= cnt - 1;
                  end
              end
          end
      end
  endmodule


--------------------------------------------------
3.4 uart_wb.v (Wishbone UART)
--------------------------------------------------

  // uart_wb.v
  module uart_wb #(
      parameter CLK_FREQ = 50000000,
      parameter BAUD     = 115200
  )(
      input  wire        clk,
      input  wire        rst,
      input  wire        rx,
      output wire        tx,
      input  wire        wb_cyc,
      input  wire        wb_stb,
      input  wire        wb_we,
      input  wire [3:0]  wb_sel,
      input  wire [31:0] wb_adr,
      input  wire [31:0] wb_dat_w,
      output reg  [31:0] wb_dat_r,
      output reg         wb_ack
  );
      wire [3:0] addr = wb_adr[5:2];

      wire [7:0] rx_data;
      wire       rx_valid;
      reg        rx_ready;
      reg [7:0]  rx_buf;

      uart_rx #(
          .CLK_FREQ(CLK_FREQ),
          .BAUD(BAUD)
      ) u_rx (
          .clk(clk),
          .rst(rst),
          .rx(rx),
          .data(rx_data),
          .valid(rx_valid)
      );

      wire       tx_busy;
      reg  [7:0] tx_data;
      reg        tx_start;

      uart_tx #(
          .CLK_FREQ(CLK_FREQ),
          .BAUD(BAUD)
      ) u_tx (
          .clk(clk),
          .rst(rst),
          .data(tx_data),
          .start(tx_start),
          .tx(tx),
          .busy(tx_busy)
      );

      always @(posedge clk or posedge rst) begin
          if (rst) begin
              rx_ready <= 1'b0;
              rx_buf   <= 8'd0;
              tx_start <= 1'b0;
              wb_ack   <= 1'b0;
              wb_dat_r <= 32'd0;
          end else begin
              tx_start <= 1'b0;
              wb_ack   <= 1'b0;

              if (rx_valid) begin
                  rx_buf   <= rx_data;
                  rx_ready <= 1'b1;
              end

              if (wb_cyc && wb_stb && !wb_ack) begin
                  wb_ack <= 1'b1;
                  if (wb_we) begin
                      if (addr == 4'd0 && wb_sel != 4'b0000) begin
                          if (!tx_busy) begin
                              tx_data  <= wb_dat_w[7:0];
                              tx_start <= 1'b1;
                          end
                      end
                      wb_dat_r <= 32'd0;
                  end else begin
                      case (addr)
                          4'd0: begin
                              wb_dat_r[7:0]  = rx_buf;
                              wb_dat_r[31]   = rx_ready;
                              rx_ready       <= 1'b0;
                          end
                          4'd1: begin
                              wb_dat_r[0]    = tx_busy;
                          end
                          default: wb_dat_r = 32'd0;
                      endcase
                  end
              end
          end
      end
  endmodule


--------------------------------------------------
3.5 npu_gemm_wb.v (GEMM NPU)
--------------------------------------------------

  // npu_gemm_wb.v
  // GEMM NPU: C[MxN] = A[MxK] * B[KxN], int16 inputs, int32 outputs.
  module npu_gemm_wb #(
      parameter MAX_M = 16,
      parameter MAX_N = 16,
      parameter MAX_K = 16
  )(
      input  wire        clk,
      input  wire        rst,
      input  wire        wb_cyc,
      input  wire        wb_stb,
      input  wire        wb_we,
      input  wire [3:0]  wb_sel,
      input  wire [31:0] wb_adr,
      input  wire [31:0] wb_dat_w,
      output reg  [31:0] wb_dat_r,
      output reg         wb_ack
  );
      localparam MAX_A = MAX_M * MAX_K;
      localparam MAX_B = MAX_K * MAX_N;
      localparam MAX_C = MAX_M * MAX_N;

      // Registers (word offset)
      // 0: CTRL  (W: bit0=start; R: bit0=busy, bit1=done)
      // 1: M_N   (lower16=M, upper16=N)
      // 2: K     (lower16=K)
      // 3: A_IDX
      // 4: A_DATA
      // 5: B_IDX
      // 6: B_DATA
      // 7: C_IDX
      // 8: C_DATA

      wire [4:0] addr = wb_adr[6:2];

      reg [15:0] cfg_M;
      reg [15:0] cfg_N;
      reg [15:0] cfg_K;

      reg [15:0] a_idx_reg;
      reg [15:0] b_idx_reg;
      reg [15:0] c_idx_reg;

      reg        busy;
      reg        done;

      reg [15:0] mem_A [0:MAX_A-1];
      reg [15:0] mem_B [0:MAX_B-1];
      reg [31:0] mem_C [0:MAX_C-1];

      localparam S_IDLE = 0;
      localparam S_RUN  = 1;

      reg [1:0]  state;
      reg [15:0] i_m;
      reg [15:0] i_n;
      reg [15:0] i_k;
      reg [31:0] acc;

      always @(posedge clk or posedge rst) begin
          if (rst) begin
              cfg_M     <= 16'd0;
              cfg_N     <= 16'd0;
              cfg_K     <= 16'd0;
              a_idx_reg <= 16'd0;
              b_idx_reg <= 16'd0;
              c_idx_reg <= 16'd0;
              busy      <= 1'b0;
              done      <= 1'b0;
              state     <= S_IDLE;
              i_m       <= 16'd0;
              i_n       <= 16'd0;
              i_k       <= 16'd0;
              acc       <= 32'd0;
              wb_ack    <= 1'b0;
              wb_dat_r  <= 32'd0;
          end else begin
              wb_ack <= 1'b0;

              // Wishbone access
              if (wb_cyc && wb_stb && !wb_ack) begin
                  wb_ack <= 1'b1;
                  if (wb_we) begin
                      case (addr)
                          5'd0: begin
                              if (wb_sel[0] && wb_dat_w[0] && !busy) begin
                                  if (cfg_M != 16'd0 && cfg_N != 16'd0 && cfg_K != 16'd0 &&
                                      cfg_M <= MAX_M && cfg_N <= MAX_N && cfg_K <= MAX_K) begin
                                      busy  <= 1'b1;
                                      done  <= 1'b0;
                                      state <= S_RUN;
                                      i_m   <= 16'd0;
                                      i_n   <= 16'd0;
                                      i_k   <= 16'd0;
                                      acc   <= 32'd0;
                                  end
                              end
                          end
                          5'd1: begin
                              if (wb_sel[0]) cfg_M[7:0]  <= wb_dat_w[7:0];
                              if (wb_sel[1]) cfg_M[15:8] <= wb_dat_w[15:8];
                              if (wb_sel[2]) cfg_N[7:0]  <= wb_dat_w[23:16];
                              if (wb_sel[3]) cfg_N[15:8] <= wb_dat_w[31:24];
                          end
                          5'd2: begin
                              if (wb_sel[0]) cfg_K[7:0]  <= wb_dat_w[7:0];
                              if (wb_sel[1]) cfg_K[15:8] <= wb_dat_w[15:8];
                          end
                          5'd3: begin
                              if (wb_sel[0]) a_idx_reg[7:0]  <= wb_dat_w[7:0];
                              if (wb_sel[1]) a_idx_reg[15:8] <= wb_dat_w[15:8];
                          end
                          5'd4: begin
                              if (a_idx_reg < MAX_A)
                                  mem_A[a_idx_reg] <= wb_dat_w[15:0];
                          end
                          5'd5: begin
                              if (wb_sel[0]) b_idx_reg[7:0]  <= wb_dat_w[7:0];
                              if (wb_sel[1]) b_idx_reg[15:8] <= wb_dat_w[15:8];
                          end
                          5'd6: begin
                              if (b_idx_reg < MAX_B)
                                  mem_B[b_idx_reg] <= wb_dat_w[15:0];
                          end
                          5'd7: begin
                              if (wb_sel[0]) c_idx_reg[7:0]  <= wb_dat_w[7:0];
                              if (wb_sel[1]) c_idx_reg[15:8] <= wb_dat_w[15:8];
                          end
                          default: ;
                      endcase
                  end else begin
                      case (addr)
                          5'd0: begin
                              wb_dat_r[0] = busy;
                              wb_dat_r[1] = done;
                              done <= 1'b0;
                          end
                          5'd1: wb_dat_r = {cfg_N, cfg_M};
                          5'd2: wb_dat_r = {16'd0, cfg_K};
                          5'd3: wb_dat_r = {16'd0, a_idx_reg};
                          5'd4: wb_dat_r = {16'd0,
                                            (a_idx_reg < MAX_A) ? mem_A[a_idx_reg] : 16'd0};
                          5'd5: wb_dat_r = {16'd0, b_idx_reg};
                          5'd6: wb_dat_r = {16'd0,
                                            (b_idx_reg < MAX_B) ? mem_B[b_idx_reg] : 16'd0};
                          5'd7: wb_dat_r = {16'd0, c_idx_reg};
                          5'd8: wb_dat_r = (c_idx_reg < MAX_C) ? mem_C[c_idx_reg] : 32'd0;
                          default: wb_dat_r = 32'd0;
                      endcase
                  end
              end

              // GEMM FSM
              case (state)
                  S_IDLE: begin
                  end
                  S_RUN: begin
                      if (i_m < cfg_M) begin
                          if (i_n < cfg_N) begin
                              if (i_k < cfg_K) begin
                                  integer idxA;
                                  integer idxB;
                                  integer idxC;
                                  idxA = i_m * cfg_K + i_k;
                                  idxB = i_k * cfg_N + i_n;
                                  idxC = i_m * cfg_N + i_n;
                                  if (idxA < MAX_A && idxB < MAX_B && idxC < MAX_C) begin
                                      acc <= acc + $signed(mem_A[idxA]) * $signed(mem_B[idxB]);
                                  end
                                  i_k <= i_k + 16'd1;
                              end else begin
                                  integer idxC2;
                                  idxC2 = i_m * cfg_N + i_n;
                                  if (idxC2 < MAX_C)
                                      mem_C[idxC2] <= acc;
                                  acc <= 32'd0;
                                  i_k <= 16'd0;
                                  i_n <= i_n + 16'd1;
                              end
                          end else begin
                              i_n <= 16'd0;
                              i_m <= i_m + 16'd1;
                          end
                      end else begin
                          busy  <= 1'b0;
                          done  <= 1'b1;
                          state <= S_IDLE;
                      end
                  end
              endcase
          end
      end

  endmodule


--------------------------------------------------
3.6 wb_interconnect.v (Wishbone crossbar)
--------------------------------------------------

  // wb_interconnect.v
  module wb_interconnect (
      input  wire        clk,
      input  wire        rst,
      // Master
      input  wire        m_cyc,
      input  wire        m_stb,
      input  wire        m_we,
      input  wire [3:0]  m_sel,
      input  wire [31:0] m_adr,
      input  wire [31:0] m_dat_w,
      output reg  [31:0] m_dat_r,
      output reg         m_ack,
      // RAM
      output reg         ram_cyc,
      output reg         ram_stb,
      output reg         ram_we,
      output reg  [3:0]  ram_sel,
      output reg  [31:0] ram_adr,
      output reg  [31:0] ram_dat_w,
      input  wire [31:0] ram_dat_r,
      input  wire        ram_ack,
      // UART
      output reg         uart_cyc,
      output reg         uart_stb,
      output reg         uart_we,
      output reg  [3:0]  uart_sel,
      output reg  [31:0] uart_adr,
      output reg  [31:0] uart_dat_w,
      input  wire [31:0] uart_dat_r,
      input  wire        uart_ack,
      // NPU
      output reg         npu_cyc,
      output reg         npu_stb,
      output reg         npu_we,
      output reg  [3:0]  npu_sel,
      output reg  [31:0] npu_adr,
      output reg  [31:0] npu_dat_w,
      input  wire [31:0] npu_dat_r,
      input  wire        npu_ack
  );
      always @(*) begin
          ram_cyc   = 1'b0;
          ram_stb   = 1'b0;
          ram_we    = m_we;
          ram_sel   = m_sel;
          ram_adr   = m_adr;
          ram_dat_w = m_dat_w;

          uart_cyc   = 1'b0;
          uart_stb   = 1'b0;
          uart_we    = m_we;
          uart_sel   = m_sel;
          uart_adr   = m_adr;
          uart_dat_w = m_dat_w;

          npu_cyc   = 1'b0;
          npu_stb   = 1'b0;
          npu_we    = m_we;
          npu_sel   = m_sel;
          npu_adr   = m_adr;
          npu_dat_w = m_dat_w;

          m_dat_r   = 32'd0;
          m_ack     = 1'b0;

          if (m_cyc && m_stb) begin
              if (m_adr[31:16] == 16'h0000) begin
                  ram_cyc = m_cyc;
                  ram_stb = m_stb;
                  m_dat_r = ram_dat_r;
                  m_ack   = ram_ack;
              end else if (m_adr[31:24] == 8'h10) begin
                  uart_cyc = m_cyc;
                  uart_stb = m_stb;
                  m_dat_r  = uart_dat_r;
                  m_ack    = uart_ack;
              end else if (m_adr[31:24] == 8'h20) begin
                  npu_cyc = m_cyc;
                  npu_stb = m_stb;
                  m_dat_r = npu_dat_r;
                  m_ack   = npu_ack;
              end else begin
                  m_dat_r = 32'd0;
                  m_ack   = 1'b1;
              end
          end
      end
  endmodule


--------------------------------------------------
3.7 soc_top.v (top-level)
--------------------------------------------------

  // soc_top.v
  module soc_top (
      input  wire clk_50,
      input  wire rst_n,
      input  wire uart_rx,
      output wire uart_tx
  );
      wire clk = clk_50;
      wire rst = ~rst_n;

      wire        wb_cyc;
      wire        wb_stb;
      wire        wb_we;
      wire [3:0]  wb_sel;
      wire [31:0] wb_adr;
      wire [31:0] wb_dat_w;
      wire [31:0] wb_dat_r;
      wire        wb_ack;

      VexRiscv cpu (
          .clk  (clk),
          .reset(rst),
          .io_busWishbone_CYC       (wb_cyc),
          .io_busWishbone_STB       (wb_stb),
          .io_busWishbone_WE        (wb_we),
          .io_busWishbone_SEL       (wb_sel),
          .io_busWishbone_ADR       (wb_adr),
          .io_busWishbone_DAT_MOSI  (wb_dat_w),
          .io_busWishbone_DAT_MISO  (wb_dat_r),
          .io_busWishbone_ACK       (wb_ack)
      );

      wire        ram_cyc, ram_stb, ram_we, ram_ack;
      wire [3:0]  ram_sel;
      wire [31:0] ram_adr, ram_dat_w, ram_dat_r;

      wire        uart_cyc, uart_stb, uart_we, uart_ack;
      wire [3:0]  uart_sel;
      wire [31:0] uart_adr, uart_dat_w, uart_dat_r;

      wire        npu_cyc, npu_stb, npu_we, npu_ack;
      wire [3:0]  npu_sel;
      wire [31:0] npu_adr, npu_dat_w, npu_dat_r;

      wb_interconnect xbar (
          .clk      (clk),
          .rst      (rst),
          .m_cyc    (wb_cyc),
          .m_stb    (wb_stb),
          .m_we     (wb_we),
          .m_sel    (wb_sel),
          .m_adr    (wb_adr),
          .m_dat_w  (wb_dat_w),
          .m_dat_r  (wb_dat_r),
          .m_ack    (wb_ack),

          .ram_cyc  (ram_cyc),
          .ram_stb  (ram_stb),
          .ram_we   (ram_we),
          .ram_sel  (ram_sel),
          .ram_adr  (ram_adr),
          .ram_dat_w(ram_dat_w),
          .ram_dat_r(ram_dat_r),
          .ram_ack  (ram_ack),

          .uart_cyc (uart_cyc),
          .uart_stb (uart_stb),
          .uart_we  (uart_we),
          .uart_sel (uart_sel),
          .uart_adr (uart_adr),
          .uart_dat_w(uart_dat_w),
          .uart_dat_r(uart_dat_r),
          .uart_ack (uart_ack),

          .npu_cyc  (npu_cyc),
          .npu_stb  (npu_stb),
          .npu_we   (npu_we),
          .npu_sel  (npu_sel),
          .npu_adr  (npu_adr),
          .npu_dat_w(npu_dat_w),
          .npu_dat_r(npu_dat_r),
          .npu_ack  (npu_ack)
      );

      simple_ram_wb #(
          .MEM_SIZE(64*1024)
      ) ram0 (
          .clk    (clk),
          .rst    (rst),
          .wb_cyc (ram_cyc),
          .wb_stb (ram_stb),
          .wb_we  (ram_we),
          .wb_sel (ram_sel),
          .wb_adr (ram_adr),
          .wb_dat_w(ram_dat_w),
          .wb_dat_r(ram_dat_r),
          .wb_ack (ram_ack)
      );

      uart_wb #(
          .CLK_FREQ(50000000),
          .BAUD(115200)
      ) uart0 (
          .clk    (clk),
          .rst    (rst),
          .rx     (uart_rx),
          .tx     (uart_tx),
          .wb_cyc (uart_cyc),
          .wb_stb (uart_stb),
          .wb_we  (uart_we),
          .wb_sel (uart_sel),
          .wb_adr (uart_adr),
          .wb_dat_w(uart_dat_w),
          .wb_dat_r(uart_dat_r),
          .wb_ack (uart_ack)
      );

      npu_gemm_wb #(
          .MAX_M(16),
          .MAX_N(16),
          .MAX_K(16)
      ) npu0 (
          .clk    (clk),
          .rst    (rst),
          .wb_cyc (npu_cyc),
          .wb_stb (npu_stb),
          .wb_we  (npu_we),
          .wb_sel (npu_sel),
          .wb_adr (npu_adr),
          .wb_dat_w(npu_dat_w),
          .wb_dat_r(npu_dat_r),
          .wb_ack (npu_ack)
      );

  endmodule


==================================================
4. FIRMWARE FOR GEMM NPU (BARE-METAL C)
==================================================

Memory map:

- RAM:  0x00000000
- UART: 0x10000000
- NPU:  0x20000000

NPU registers (word offsets):

- 0x00: CTRL    (W: bit0=start; R: bit0=busy, bit1=done)
- 0x04: M_N     (lower16=M, upper16=N)
- 0x08: K       (lower16=K)
- 0x0C: A_IDX
- 0x10: A_DATA
- 0x14: B_IDX
- 0x18: B_DATA
- 0x1C: C_IDX
- 0x20: C_DATA

UART protocol for GEMM:

- Host → SoC:
  - 0xAA (sync)
  - 0x02 (CMD_GEMM)
  - M (u8), N (u8), K (u8) – all ≤16
  - A[M*K] elements as int16 (little‑endian)
  - B[K*N] elements as int16 (little‑endian)
- SoC → Host:
  - 0x55 (sync)
  - C[M*N] elements as int32 (little‑endian)

--------------------------------------------------
4.1 firmware.c
--------------------------------------------------

  #include <stdint.h>

  #define UART_BASE   0x10000000u
  #define UART_DATA   (*(volatile uint32_t*)(UART_BASE + 0x0))
  #define UART_STATUS (*(volatile uint32_t*)(UART_BASE + 0x4))

  #define NPU_BASE    0x20000000u
  #define NPU_CTRL    (*(volatile uint32_t*)(NPU_BASE + 0x0))
  #define NPU_MN      (*(volatile uint32_t*)(NPU_BASE + 0x4))
  #define NPU_K       (*(volatile uint32_t*)(NPU_BASE + 0x8))
  #define NPU_A_IDX   (*(volatile uint32_t*)(NPU_BASE + 0xC))
  #define NPU_A_DATA  (*(volatile uint32_t*)(NPU_BASE + 0x10))
  #define NPU_B_IDX   (*(volatile uint32_t*)(NPU_BASE + 0x14))
  #define NPU_B_DATA  (*(volatile uint32_t*)(NPU_BASE + 0x18))
  #define NPU_C_IDX   (*(volatile uint32_t*)(NPU_BASE + 0x1C))
  #define NPU_C_DATA  (*(volatile uint32_t*)(NPU_BASE + 0x20))

  static void uart_putc(uint8_t c) {
      while (UART_STATUS & 0x1u) ;
      UART_DATA = c;
  }

  static uint8_t uart_getc(void) {
      uint32_t v;
      do {
          v = UART_DATA;
      } while ((v & 0x80000000u) == 0);
      return (uint8_t)(v & 0xFF);
  }

  static void uart_write(const uint8_t* buf, uint32_t len) {
      for (uint32_t i = 0; i < len; i++) uart_putc(buf[i]);
  }

  #define SYNC_CMD  0xAA
  #define CMD_GEMM  0x02
  #define SYNC_RESP 0x55

  static void npu_gemm(const int16_t* A, const int16_t* B,
                       uint8_t M, uint8_t N, uint8_t K,
                       int32_t* C_out) {
      if (M == 0 || N == 0 || K == 0) return;
      if (M > 16 || N > 16 || K > 16) return;

      uint32_t mn = ((uint32_t)N << 16) | (uint32_t)M;
      NPU_MN = mn;
      NPU_K  = (uint32_t)K;

      uint16_t totalA = (uint16_t)M * (uint16_t)K;
      uint16_t totalB = (uint16_t)K * (uint16_t)N;
      uint16_t totalC = (uint16_t)M * (uint16_t)N;

      for (uint16_t i = 0; i < totalA; i++) {
          NPU_A_IDX  = i;
          NPU_A_DATA = (uint16_t)A[i];
      }

      for (uint16_t i = 0; i < totalB; i++) {
          NPU_B_IDX  = i;
          NPU_B_DATA = (uint16_t)B[i];
      }

      NPU_CTRL = 1u;

      while (NPU_CTRL & 0x1u) { }

      for (uint16_t i = 0; i < totalC; i++) {
          NPU_C_IDX = i;
          C_out[i]  = (int32_t)NPU_C_DATA;
      }
  }

  void main(void) {
      while (1) {
          uint8_t sync = uart_getc();
          if (sync != SYNC_CMD) continue;

          uint8_t cmd = uart_getc();
          if (cmd != CMD_GEMM) continue;

          uint8_t M = uart_getc();
          uint8_t N = uart_getc();
          uint8_t K = uart_getc();
          if (M == 0 || N == 0 || K == 0) continue;
          if (M > 16 || N > 16 || K > 16) continue;

          uint16_t totalA = (uint16_t)M * (uint16_t)K;
          uint16_t totalB = (uint16_t)K * (uint16_t)N;
          uint16_t totalC = (uint16_t)M * (uint16_t)N;

          static int16_t A_buf[16*16];
          static int16_t B_buf[16*16];
          static int32_t C_buf[16*16];

          for (uint16_t i = 0; i < totalA; i++) {
              uint8_t lo = uart_getc();
              uint8_t hi = uart_getc();
              A_buf[i] = (int16_t)((uint16_t)lo | ((uint16_t)hi << 8));
          }

          for (uint16_t i = 0; i < totalB; i++) {
              uint8_t lo = uart_getc();
              uint8_t hi = uart_getc();
              B_buf[i] = (int16_t)((uint16_t)lo | ((uint16_t)hi << 8));
          }

          npu_gemm(A_buf, B_buf, M, N, K, C_buf);

          uart_putc(SYNC_RESP);

          for (uint16_t i = 0; i < totalC; i++) {
              int32_t v = C_buf[i];
              uart_putc((uint8_t)(v & 0xFF));
              uart_putc((uint8_t)((v >> 8) & 0xFF));
              uart_putc((uint8_t)((v >> 16) & 0xFF));
              uart_putc((uint8_t)((v >> 24) & 0xFF));
          }
      }
  }


--------------------------------------------------
4.2 Build firmware → firmware.hex
--------------------------------------------------

On your dev machine:

  riscv32-unknown-elf-gcc -Os -march=rv32im -mabi=ilp32 -nostdlib -ffreestanding \
      -Wl,-Bstatic,-Ttext=0x00000000,-Map=firmware.map \
      -o firmware.elf firmware.c

  riscv32-unknown-elf-objcopy -O binary firmware.elf firmware.bin

  python3 - << 'EOF'
  data = open("firmware.bin", "rb").read()
  if len(data) % 4 != 0:
      data += b'\00' * (4 - (len(data) % 4))
  words = []
  for i in range(0, len(data), 4):
      w = data[i] | (data[i+1]<<8) | (data[i+2]<<16) | (data[i+3]<<24)
      words.append(w)
  with open("firmware.hex", "w") as f:
      for w in words:
          f.write("{:08x}\n".format(w))
  EOF

Ensure `firmware.hex` is in the same directory as `simple_ram_wb.v`.


==================================================
5. QUARTUS PROJECT FOR DUEPROLOGIC (BUILT‑IN BLASTER)
==================================================

1. Create new Quartus project:
   - Family: Cyclone IV
   - Device: match DueProLogic’s EP4CE device.

2. Add files:
   - `VexRiscv.v`
   - `soc_top.v`
   - `wb_interconnect.v`
   - `simple_ram_wb.v`
   - `uart_rx.v`
   - `uart_tx.v`
   - `uart_wb.v`
   - `npu_gemm_wb.v`
   - `firmware.hex` (just in project directory)

3. Set `soc_top` as top‑level.

4. Pin Planner:
   - `clk_50` → 50 MHz oscillator pin on DueProLogic
   - `rst_n`  → reset button pin or header (active low)
   - `uart_rx` → header pin wired to USB‑UART TX
   - `uart_tx` → header pin wired to USB‑UART RX
   - I/O standard: `3.3‑V LVTTL`

5. Compile project → produce `soc_top.sof`.


==================================================
6. PROGRAM FPGA (VOLATILE) USING BUILT‑IN USB‑BLASTER
==================================================

On Raspberry Pi 5:

1. Connect DueProLogic’s USB‑Blaster USB port directly to Pi 5.

2. Install openFPGALoader:

   sudo apt update
   sudo apt install cmake g++ pkg-config libftdi1-dev libusb-1.0-0-dev
   git clone https://github.com/trabucayre/openFPGALoader.git
   cd openFPGALoader
   mkdir build && cd build
   cmake ..
   make -j4
   sudo make install

3. Copy `soc_top.sof` onto the Pi (e.g., `scp`).

4. Program SRAM:

   openFPGALoader -c usb-blaster soc_top.sof

This uses the **built‑in USB‑Blaster** and only programs SRAM. After power‑cycle,
the FPGA returns to its original flash image (volatile behavior).


==================================================
7. HOST GEMM CLIENT ON RASPBERRY PI 5
==================================================

Wire USB‑UART:

- Dongle TX → pin assigned to `uart_rx`
- Dongle RX → pin assigned to `uart_tx`
- GND → GND

Find the serial device:

  ls /dev/ttyUSB*

Assume `/dev/ttyUSB0`.

--------------------------------------------------
7.1 fpga_gemm_client.py
--------------------------------------------------

  #!/usr/bin/env python3
  import serial
  import struct
  import time
  import random

  SYNC_CMD  = 0xAA
  CMD_GEMM  = 0x02
  SYNC_RESP = 0x55

  class FPGAGemmClient:
      def __init__(self, port="/dev/ttyUSB0", baud=115200, timeout=2.0):
          self.ser = serial.Serial(port, baudrate=baud, timeout=timeout)
          time.sleep(0.2)

      def close(self):
          self.ser.close()

      def gemm(self, A, B, M, N, K):
          if M < 1 or M > 16 or N < 1 or N > 16 or K < 1 or K > 16:
              raise ValueError("M,N,K must be 1..16")
          if len(A) != M*K:
              raise ValueError("A size mismatch")
          if len(B) != K*N:
              raise ValueError("B size mismatch")

          pkt = bytearray()
          pkt.append(SYNC_CMD)
          pkt.append(CMD_GEMM)
          pkt.append(M & 0xFF)
          pkt.append(N & 0xFF)
          pkt.append(K & 0xFF)

          for x in A:
              pkt += struct.pack("<h", int(x))
          for x in B:
              pkt += struct.pack("<h", int(x))

          self.ser.write(pkt)

          sync = self.ser.read(1)
          if not sync or sync[0] != SYNC_RESP:
              raise RuntimeError("Bad sync from FPGA GEMM")

          totalC = M*N
          res_bytes = self.ser.read(4*totalC)
          if len(res_bytes) != 4*totalC:
              raise RuntimeError("Incomplete C from FPGA")

          C = list(struct.unpack("<" + "i"*totalC, res_bytes))
          return C

  def test():
      cli = FPGAGemmClient("/dev/ttyUSB0", 115200)
      try:
          M, N, K = 4, 4, 4
          A = [random.randint(-4, 4) for _ in range(M*K)]
          B = [random.randint(-4, 4) for _ in range(K*N)]

          C_hw = cli.gemm(A, B, M, N, K)

          def gemm_sw(A, B, M, N, K):
              C = [0]*(M*N)
              for m in range(M):
                  for n in range(N):
                      acc = 0
                      for k in range(K):
                          acc += A[m*K + k] * B[k*N + n]
                      C[m*N + n] = acc
              return C

          C_sw = gemm_sw(A, B, M, N, K)
          print("HW:", C_hw)
          print("SW:", C_sw)
          print("MATCH" if C_hw == C_sw else "MISMATCH")
      finally:
          cli.close()

  if __name__ == "__main__":
      test()

Install pyserial:

  pip install pyserial

Test:

  python3 fpga_gemm_client.py


==================================================
8. HUGGING FACE TEXT‑TO‑IMAGE + GEMM OFFLOAD
==================================================

On the Pi (or any machine with Python + serial access to the board):

  pip install torch diffusers transformers accelerate safetensors pillow

--------------------------------------------------
8.1 hf_sd_gemm_fpga.py
--------------------------------------------------

  #!/usr/bin/env python3
  import torch
  from diffusers import StableDiffusionPipeline
  from fpga_gemm_client import FPGAGemmClient
  import numpy as np

  def main():
      fpga = FPGAGemmClient("/dev/ttyUSB0", 115200)

      pipe = StableDiffusionPipeline.from_pretrained(
          "runwayml/stable-diffusion-v1-5",
          torch_dtype=torch.float32
      )
      device = "cpu"
      pipe = pipe.to(device)

      prompt = "a futuristic robot in a neon-lit workshop"
      text_inputs = pipe.tokenizer(
          [prompt],
          padding="max_length",
          max_length=pipe.tokenizer.model_max_length,
          truncation=True,
          return_tensors="pt"
      )

      with torch.no_grad():
          text_embeds = pipe.text_encoder(text_inputs.input_ids.to(device))[0]

      emb = text_embeds[:, 0, :]   # [1, hidden]
      hidden_dim = emb.shape[-1]
      emb_np = emb.cpu().numpy().reshape(-1).astype(np.float32)

      K = 16
      M = 1
      N = 16

      if hidden_dim < K:
          raise RuntimeError("Hidden dim < 16")

      x_slice = emb_np[:K]

      scale = 128.0
      x_q = np.clip(np.round(x_slice * (1.0 / scale)), -32768, 32767).astype(np.int16)

      np.random.seed(42)
      W = np.random.randint(-8, 8, size=(K, N), dtype=np.int16)

      A = x_q.tolist()
      B = W.flatten().tolist()

      C_hw = fpga.gemm(A, B, M, N, K)

      C_fp = (np.array(C_hw, dtype=np.float32) / scale)
      print("FPGA GEMM output (float approx):", C_fp)

      image = pipe(prompt, num_inference_steps=20, guidance_scale=7.5).images[0]
      image.save("sd_gemm_fpga_demo.png")
      print("Saved sd_gemm_fpga_demo.png")

  if __name__ == "__main__":
      main()


==================================================
9. END‑TO‑END CHECKLIST
==================================================

1. Generate `VexRiscv.v` with WishboneSlavePlugin.
2. Create all Verilog files above (`soc_top.v`, `wb_interconnect.v`,
   `simple_ram_wb.v`, `uart_rx.v`, `uart_tx.v`, `uart_wb.v`, `npu_gemm_wb.v`).
3. Build `firmware.elf`, `firmware.bin`, `firmware.hex`.
4. Create Quartus project for DueProLogic, add HDL files, top `soc_top`.
5. Assign pins for `clk_50`, `rst_n`, `uart_rx`, `uart_tx`.
6. Compile in Quartus → `soc_top.sof`.
7. On Pi 5:
   - Plug DueProLogic’s built‑in USB‑Blaster into Pi.
   - Run:

     openFPGALoader -c usb-blaster soc_top.sof

   - FPGA is now configured **volatily**.

8. Wire USB‑UART → test with `fpga_gemm_client.py` → see HW/SW GEMM match.
9. Run `hf_sd_gemm_fpga.py` → see FPGA GEMM used in a real text‑embedding
   projection + generate `sd_gemm_fpga_demo.png`.

At this point you have:

- A **VexRiscv‑based soft SoC** with:
  - 64 KB on‑chip RAM
  - UART
  - **GEMM‑capable NPU** (int16 × int16 → int32)
- Fully **volatile configuration** via the **built‑in USB‑Blaster** on DueProLogic.
- A Hugging Face Stable Diffusion pipeline that calls your NPU as a real,
  working kernel.

From here you can scale: more tiles, more MAC lanes, DMA, additional cores,
and deeper integration into UNet/attention workloads.